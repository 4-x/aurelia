{"version":3,"file":"index.system.js","sources":["../src/ast.ts","../src/attribute-pattern.ts","../src/attribute-parser.ts","../src/binding-command.ts","../src/common.ts","../src/expression-parser.ts","../src/configuration.ts","../src/resource-model.ts","../src/semantic-model.ts"],"sourcesContent":["export class AttrSyntax {\n  public readonly rawName: string;\n  public readonly rawValue: string;\n  public readonly target: string;\n  public readonly command: string | null;\n\n  constructor(rawName: string, rawValue: string, target: string, command: string | null) {\n    this.rawName = rawName;\n    this.rawValue = rawValue;\n    this.target = target;\n    this.command = command;\n  }\n}\n","import { Class, DI, IContainer, IRegistry, IResolver, PLATFORM, Registration, Reporter } from '@aurelia/kernel';\nimport { AttrSyntax } from './ast';\n\nexport interface AttributePatternDefinition {\n  pattern: string;\n  symbols: string;\n}\n\n/** @internal */\nexport interface ICharSpec {\n  chars: string;\n  repeat: boolean;\n  isSymbol: boolean;\n  isInverted: boolean;\n  has(char: string): boolean;\n  equals(other: ICharSpec): boolean;\n}\n\n/** @internal */\nexport class CharSpec implements ICharSpec {\n  public chars: string;\n  public repeat: boolean;\n  public isSymbol: boolean;\n  public isInverted: boolean;\n\n  public has: (char: string) => boolean;\n\n  constructor(chars: string, repeat: boolean, isSymbol: boolean, isInverted: boolean) {\n    this.chars = chars;\n    this.repeat = repeat;\n    this.isSymbol = isSymbol;\n    this.isInverted = isInverted;\n    if (isInverted) {\n      switch (chars.length) {\n        case 0:\n          this.has = this.hasOfNoneInverse;\n          break;\n        case 1:\n          this.has = this.hasOfSingleInverse;\n          break;\n        default:\n          this.has = this.hasOfMultipleInverse;\n      }\n    } else {\n      switch (chars.length) {\n        case 0:\n          this.has = this.hasOfNone;\n          break;\n        case 1:\n          this.has = this.hasOfSingle;\n          break;\n        default:\n          this.has = this.hasOfMultiple;\n      }\n    }\n  }\n\n  public equals(other: ICharSpec): boolean {\n    return this.chars === other.chars\n        && this.repeat === other.repeat\n        && this.isSymbol === other.isSymbol\n        && this.isInverted === other.isInverted;\n  }\n\n  private hasOfMultiple(char: string): boolean {\n    return this.chars.indexOf(char) !== -1;\n  }\n\n  private hasOfSingle(char: string): boolean {\n    return this.chars === char;\n  }\n\n  private hasOfNone(char: string): boolean {\n    return false;\n  }\n\n  private hasOfMultipleInverse(char: string): boolean {\n    return this.chars.indexOf(char) === -1;\n  }\n\n  private hasOfSingleInverse(char: string): boolean {\n    return this.chars !== char;\n  }\n\n  private hasOfNoneInverse(char: string): boolean {\n    return true;\n  }\n}\n\nexport class Interpretation {\n  public parts: ReadonlyArray<string>;\n  public get pattern(): string | null {\n    const value = this._pattern;\n    if (value === '') {\n      return null;\n    } else {\n      return value;\n    }\n  }\n  public set pattern(value: string | null) {\n    if (value === null) {\n      this._pattern = '';\n      this.parts = PLATFORM.emptyArray;\n    } else {\n      this._pattern = value;\n      this.parts = this.partsRecord[value];\n    }\n  }\n  private _pattern: string;\n  private readonly currentRecord: Record<string, string>;\n  private readonly partsRecord: Record<string, string[]>;\n\n  constructor() {\n    this._pattern = '';\n    this.parts = PLATFORM.emptyArray;\n    this.currentRecord = {};\n    this.partsRecord = {};\n  }\n\n  public append(pattern: string, ch: string): void {\n    const { currentRecord } = this;\n    if (currentRecord[pattern] === undefined) {\n      currentRecord[pattern] = ch;\n    } else {\n      currentRecord[pattern] += ch;\n    }\n  }\n\n  public next(pattern: string): void {\n    const { currentRecord } = this;\n    if (currentRecord[pattern] !== undefined) {\n      const { partsRecord } = this;\n      if (partsRecord[pattern] === undefined) {\n        partsRecord[pattern] = [currentRecord[pattern]];\n      } else {\n        partsRecord[pattern].push(currentRecord[pattern]);\n      }\n      currentRecord[pattern] = undefined;\n    }\n  }\n}\n\n/** @internal */\nexport class State {\n  public charSpec: ICharSpec;\n  public nextStates: State[];\n  public types: SegmentTypes | null;\n  public patterns: string[];\n  public isEndpoint: boolean;\n  public get pattern(): string | null {\n    return this.isEndpoint ? this.patterns[0] : null;\n  }\n\n  constructor(charSpec: ICharSpec, ...patterns: string[]) {\n    this.charSpec = charSpec;\n    this.nextStates = [];\n    this.types = null;\n    this.patterns = patterns;\n    this.isEndpoint = false;\n  }\n\n  public findChild(charSpec: ICharSpec): State {\n    const nextStates = this.nextStates;\n    const len = nextStates.length;\n    let child: State = null;\n    for (let i = 0; i < len; ++i) {\n      child = nextStates[i];\n      if (charSpec.equals(child.charSpec)) {\n        return child;\n      }\n    }\n    return null;\n  }\n\n  public append(charSpec: ICharSpec, pattern: string): State {\n    const { patterns } = this;\n    if (patterns.indexOf(pattern) === -1) {\n      patterns.push(pattern);\n    }\n    let state = this.findChild(charSpec);\n    if (state === null) {\n      state = new State(charSpec, pattern);\n      this.nextStates.push(state);\n      if (charSpec.repeat) {\n        state.nextStates.push(state);\n      }\n    }\n    return state;\n  }\n\n  public findMatches(ch: string, interpretation: Interpretation): State[] {\n    // TODO: reuse preallocated arrays\n    const results = [];\n    const nextStates = this.nextStates;\n    const len = nextStates.length;\n    let childLen = 0;\n    let child: State = null;\n    let i = 0;\n    let j = 0;\n    for (; i < len; ++i) {\n      child = nextStates[i];\n      if (child.charSpec.has(ch)) {\n        results.push(child);\n        childLen = child.patterns.length;\n        j = 0;\n        if (child.charSpec.isSymbol) {\n          for (; j < childLen; ++j) {\n            interpretation.next(child.patterns[j]);\n          }\n        } else {\n          for (; j < childLen; ++j) {\n            interpretation.append(child.patterns[j], ch);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\n/** @internal */\nexport interface ISegment {\n  text: string;\n  eachChar(callback: (spec: CharSpec) => void): void;\n}\n\n/** @internal */\nexport class StaticSegment implements ISegment {\n  public text: string;\n  private readonly len: number;\n  private readonly specs: CharSpec[];\n\n  constructor(text: string) {\n    this.text = text;\n    const len = this.len = text.length;\n    const specs = this.specs = [];\n    for (let i = 0; i < len; ++i) {\n      specs.push(new CharSpec(text[i], false, false, false));\n    }\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    const { len, specs } = this;\n    for (let i = 0; i < len; ++i) {\n      callback(specs[i]);\n    }\n  }\n}\n\n/** @internal */\nexport class DynamicSegment implements ISegment {\n  public text: string;\n  private readonly spec: CharSpec;\n\n  constructor(symbols: string) {\n    this.text = 'PART';\n    this.spec = new CharSpec(symbols, true, false, true);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this.spec);\n  }\n}\n\n/** @internal */\nexport class SymbolSegment implements ISegment {\n  public text: string;\n  private readonly spec: CharSpec;\n\n  constructor(text: string) {\n    this.text = text;\n    this.spec = new CharSpec(text, false, true, false);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this.spec);\n  }\n}\n\n/** @internal */\nexport class SegmentTypes {\n  public statics: number;\n  public dynamics: number;\n  public symbols: number;\n\n  constructor() {\n    this.statics = 0;\n    this.dynamics = 0;\n    this.symbols = 0;\n  }\n}\n\nexport interface ISyntaxInterpreter {\n  add(def: AttributePatternDefinition): void;\n  add(defs: AttributePatternDefinition[]): void;\n  add(defOrDefs: AttributePatternDefinition | AttributePatternDefinition[]): void;\n  interpret(value: string): Interpretation;\n}\n\nexport const ISyntaxInterpreter = DI.createInterface<ISyntaxInterpreter>('ISyntaxInterpreter').withDefault(x => x.singleton(SyntaxInterpreter));\n\n/** @internal */\nexport class SyntaxInterpreter {\n  public rootState: State;\n  private readonly initialStates: State[];\n\n  constructor() {\n    this.rootState = new State(null);\n    this.initialStates = [this.rootState];\n  }\n\n  public add(def: AttributePatternDefinition): void;\n  public add(defs: AttributePatternDefinition[]): void;\n  public add(defOrDefs: AttributePatternDefinition | AttributePatternDefinition[]): void {\n    let i = 0;\n    if (Array.isArray(defOrDefs)) {\n      const ii = defOrDefs.length;\n      for (; i < ii; ++i) {\n        this.add(defOrDefs[i]);\n      }\n      return;\n    }\n    let currentState = this.rootState;\n    const def = defOrDefs;\n    const pattern = def.pattern;\n    const types = new SegmentTypes();\n    const segments = this.parse(def, types);\n    const len = segments.length;\n    const callback = (ch: ICharSpec): void => {\n      currentState = currentState.append(ch, pattern);\n    };\n    for (i = 0; i < len; ++i) {\n      segments[i].eachChar(callback);\n    }\n    currentState.types = types;\n    currentState.isEndpoint = true;\n  }\n\n  public interpret(name: string): Interpretation {\n    const interpretation = new Interpretation();\n    let states = this.initialStates;\n    const len = name.length;\n    for (let i = 0; i < len; ++i) {\n      states = this.getNextStates(states, name.charAt(i), interpretation);\n      if (states.length === 0) {\n        break;\n      }\n    }\n\n    states.sort((a, b) => {\n      if (a.isEndpoint) {\n        if (!b.isEndpoint) {\n          return -1;\n        }\n      } else if (b.isEndpoint) {\n        return 1;\n      } else {\n        return 0;\n      }\n      const aTypes = a.types;\n      const bTypes = b.types;\n      if (aTypes.statics !== bTypes.statics) {\n        return bTypes.statics - aTypes.statics;\n      }\n      if (aTypes.dynamics !== bTypes.dynamics) {\n        return bTypes.dynamics - aTypes.dynamics;\n      }\n      if (aTypes.symbols !== bTypes.symbols) {\n        return bTypes.symbols - aTypes.symbols;\n      }\n      return 0;\n    });\n\n    if (states.length > 0) {\n      const state = states[0];\n      if (!state.charSpec.isSymbol) {\n        interpretation.next(state.pattern);\n      }\n      interpretation.pattern = state.pattern;\n    }\n    return interpretation;\n  }\n\n  public getNextStates(states: State[], ch: string, interpretation: Interpretation): State[] {\n    // TODO: reuse preallocated arrays\n    const nextStates: State[] = [];\n    let state: State = null;\n    const len = states.length;\n    for (let i = 0; i < len; ++i) {\n      state = states[i];\n      nextStates.push(...state.findMatches(ch, interpretation));\n    }\n\n    return nextStates;\n  }\n\n  private parse(def: AttributePatternDefinition, types: SegmentTypes): ISegment[] {\n    const result = [];\n    const pattern = def.pattern;\n    const len = pattern.length;\n    let i = 0;\n    let start = 0;\n    let c = '';\n\n    while (i < len) {\n      c = pattern.charAt(i);\n      if (def.symbols.indexOf(c) === -1) {\n        if (i === start) {\n          if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {\n            start = i = (i + 4);\n            result.push(new DynamicSegment(def.symbols));\n            ++types.dynamics;\n          } else {\n            ++i;\n          }\n        } else {\n          ++i;\n        }\n      } else if (i !== start) {\n        result.push(new StaticSegment(pattern.slice(start, i)));\n        ++types.statics;\n        start = i;\n      } else {\n        result.push(new SymbolSegment(pattern.slice(start, i + 1)));\n        ++types.symbols;\n        start = ++i;\n      }\n    }\n    if (start !== i) {\n      result.push(new StaticSegment(pattern.slice(start, i)));\n      ++types.statics;\n    }\n\n    return result;\n  }\n}\n\nfunction validatePrototype(handler: IAttributePatternHandler, patternDefs: AttributePatternDefinition[]): void {\n  for (const def of patternDefs) {\n    // note: we're intentionally not throwing here\n    if (!(def.pattern in handler)) {\n      Reporter.write(401, def); // TODO: organize error codes\n    } else if (typeof handler[def.pattern] !== 'function') {\n      Reporter.write(402, def); // TODO: organize error codes\n    }\n  }\n}\n\nexport interface IAttributePattern {\n  $patternDefs: AttributePatternDefinition[];\n}\n\nexport interface IAttributePatternHandler {\n  [pattern: string]: (rawName: string, rawValue: string, parts: ReadonlyArray<string>) => AttrSyntax;\n}\n\nexport const IAttributePattern = DI.createInterface<IAttributePattern>('IAttributePattern').noDefault();\n\ntype DecoratableAttributePattern<TProto, TClass> = Class<TProto & Partial<IAttributePattern | IAttributePatternHandler>, TClass> & Partial<IRegistry>;\ntype DecoratedAttributePattern<TProto, TClass> =  Class<TProto & IAttributePattern | IAttributePatternHandler, TClass> & IRegistry;\n\ntype AttributePatternDecorator = <TProto, TClass>(target: DecoratableAttributePattern<TProto, TClass>) => DecoratedAttributePattern<TProto, TClass>;\n\nexport function attributePattern(...patternDefs: AttributePatternDefinition[]): AttributePatternDecorator {\n  return function decorator<TProto, TClass>(target: DecoratableAttributePattern<TProto, TClass>): DecoratedAttributePattern<TProto, TClass> {\n    const proto = target.prototype;\n    // Note: the prototype is really meant to be an intersection type between IAttrubutePattern and IAttributePatternHandler, but\n    // a type with an index signature cannot be intersected with anything else that has normal property names.\n    // So we're forced to use a union type and cast it here.\n    validatePrototype(proto as IAttributePatternHandler, patternDefs);\n    proto.$patternDefs = patternDefs;\n\n    target.register = function register(container: IContainer): IResolver {\n      return Registration.singleton(IAttributePattern, target).register(container, IAttributePattern);\n    };\n    return target as DecoratedAttributePattern<TProto, TClass>;\n  } as AttributePatternDecorator;\n}\n\nexport interface DotSeparatedAttributePattern extends IAttributePattern {}\nexport class DotSeparatedAttributePattern implements DotSeparatedAttributePattern {\n  public static register: IRegistry['register'];\n\n  public ['PART.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);\n  }\n\n  public ['PART.PART.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], parts[2]);\n  }\n}\nattributePattern(\n  { pattern: 'PART.PART', symbols: '.' },\n  { pattern: 'PART.PART.PART', symbols: '.' }\n)(DotSeparatedAttributePattern);\n\nexport interface RefAttributePattern extends IAttributePattern {}\nexport class RefAttributePattern implements RefAttributePattern {\n  public static register: IRegistry['register'];\n\n  public ['ref'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, 'ref', null);\n  }\n\n  public ['ref.PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, 'ref', parts[1]);\n  }\n}\nattributePattern(\n  { pattern: 'ref', symbols: '' },\n  { pattern: 'ref.PART', symbols: '.' }\n)(RefAttributePattern);\n\nexport interface ColonPrefixedBindAttributePattern extends IAttributePattern {}\nexport class ColonPrefixedBindAttributePattern implements ColonPrefixedBindAttributePattern  {\n  public static register: IRegistry['register'];\n\n  public [':PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'bind');\n  }\n}\nattributePattern({ pattern: ':PART', symbols: ':' })(ColonPrefixedBindAttributePattern);\n\nexport interface AtPrefixedTriggerAttributePattern extends IAttributePattern {}\nexport class AtPrefixedTriggerAttributePattern implements AtPrefixedTriggerAttributePattern  {\n  public static register: IRegistry['register'];\n\n  public ['@PART'](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');\n  }\n}\nattributePattern({ pattern: '@PART', symbols: '@' })(AtPrefixedTriggerAttributePattern);\n","import { all, DI, InjectArray, Profiler } from '@aurelia/kernel';\nimport { AttrSyntax } from './ast';\nimport { IAttributePattern, IAttributePatternHandler, Interpretation, ISyntaxInterpreter } from './attribute-pattern';\n\nexport interface IAttributeParser {\n  parse(name: string, value: string): AttrSyntax;\n}\n\nexport const IAttributeParser = DI.createInterface<IAttributeParser>('IAttributeParser').withDefault(x => x.singleton(AttributeParser));\n\nconst { enter, leave } = Profiler.createTimer('AttributeParser');\n\n/** @internal */\nexport class AttributeParser implements IAttributeParser {\n  public static readonly inject: InjectArray = [ISyntaxInterpreter, all(IAttributePattern)];\n\n  private readonly interpreter: ISyntaxInterpreter;\n  private readonly cache: Record<string, Interpretation>;\n  private readonly patterns: Record<string, IAttributePatternHandler>;\n\n  constructor(interpreter: ISyntaxInterpreter, attrPatterns: IAttributePattern[]) {\n    this.interpreter = interpreter;\n    this.cache = {};\n    const patterns: AttributeParser['patterns'] = this.patterns = {};\n    attrPatterns.forEach(attrPattern => {\n      const defs = attrPattern.$patternDefs;\n      interpreter.add(defs);\n      defs.forEach(def => {\n        patterns[def.pattern] = attrPattern as unknown as IAttributePatternHandler;\n      });\n    });\n  }\n\n  public parse(name: string, value: string): AttrSyntax {\n    if (Profiler.enabled) { enter(); }\n    let interpretation = this.cache[name];\n    if (interpretation === undefined) {\n      interpretation = this.cache[name] = this.interpreter.interpret(name);\n    }\n    const pattern = interpretation.pattern;\n    if (pattern === null) {\n      if (Profiler.enabled) { leave(); }\n      return new AttrSyntax(name, value, name, null);\n    } else {\n      if (Profiler.enabled) { leave(); }\n      return this.patterns[pattern][pattern](name, value, interpretation.parts);\n    }\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IRegistry,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  PLATFORM,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  AttributeInstruction,\n  BindingMode,\n  BindingType,\n  CallBindingInstruction,\n  ForOfStatement,\n  FromViewBindingInstruction,\n  IsBindingBehavior,\n  ITargetedInstruction,\n  IteratorBindingInstruction,\n  OneTimeBindingInstruction,\n  ToViewBindingInstruction,\n  TwoWayBindingInstruction\n} from '@aurelia/runtime';\nimport { BindingSymbol, PlainAttributeSymbol, SymbolFlags } from './semantic-model';\n\nexport interface IBindingCommand {\n  bindingType: BindingType;\n  compile(binding: PlainAttributeSymbol | BindingSymbol): ITargetedInstruction;\n}\n\nexport interface IBindingCommandDefinition extends IResourceDefinition { }\n\nexport interface IBindingCommandType extends IResourceType<IBindingCommandDefinition, IBindingCommand, Class<IBindingCommand>> { }\n\nexport interface IBindingCommandResource extends\n  IResourceKind<IBindingCommandDefinition, IBindingCommand, Class<IBindingCommand>> { }\n\ntype BindingCommandDecorator = <TProto, TClass>(target: Class<TProto, TClass> & Partial<IBindingCommandType>) => Class<TProto, TClass> & IBindingCommandType;\n\nfunction register(this: IBindingCommandType, container: IContainer): void {\n  const resourceKey = BindingCommandResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n}\n\nexport function bindingCommand(name: string): BindingCommandDecorator;\nexport function bindingCommand(definition: IBindingCommandDefinition): BindingCommandDecorator;\nexport function bindingCommand(nameOrDefinition: string | IBindingCommandDefinition): BindingCommandDecorator {\n  return target => BindingCommandResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IBindingCommandResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IBindingCommandResource, Type: T & Partial<IBindingCommandType>): Type is T & IBindingCommandType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable>(this: IBindingCommandResource, name: string, ctor: T): T & IBindingCommandType;\nfunction define<T extends Constructable>(this: IBindingCommandResource, definition: IBindingCommandDefinition, ctor: T): T & IBindingCommandType;\nfunction define<T extends Constructable>(this: IBindingCommandResource, nameOrDefinition: string | IBindingCommandDefinition, ctor: T): T & IBindingCommandType {\n  const Type = ctor as T & IBindingCommandType;\n  const WritableType = Type as T & Writable<IBindingCommandType>;\n  const description = typeof nameOrDefinition === 'string' ? { name: nameOrDefinition, target: null } : nameOrDefinition;\n\n  WritableType.kind = BindingCommandResource as IBindingCommandResource;\n  WritableType.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const BindingCommandResource: IBindingCommandResource = {\n  name: 'binding-command',\n  keyFrom,\n  isType,\n  define\n};\n\nexport function getTarget(binding: PlainAttributeSymbol | BindingSymbol, camelCase: boolean): string {\n  if (binding.flags & SymbolFlags.isBinding) {\n    return (binding as BindingSymbol).bindable.propName;\n  } else if (camelCase) {\n    return PLATFORM.camelCase((binding as PlainAttributeSymbol).syntax.target);\n  } else {\n    return (binding as PlainAttributeSymbol).syntax.target;\n  }\n}\n\nexport function getMode(binding: PlainAttributeSymbol | BindingSymbol): BindingMode {\n  if (binding.flags & SymbolFlags.isBinding) {\n    return (binding as BindingSymbol).bindable.mode;\n  } else {\n    return commandToMode[(binding as PlainAttributeSymbol).syntax.command];\n  }\n}\n\nexport interface OneTimeBindingCommand extends IBindingCommand {}\nexport class OneTimeBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.OneTimeCommand;\n\n  constructor() {\n    this.bindingType = BindingType.OneTimeCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new OneTimeBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('one-time', OneTimeBindingCommand);\n\nexport interface ToViewBindingCommand extends IBindingCommand {}\nexport class ToViewBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.ToViewCommand;\n\n  constructor() {\n    this.bindingType = BindingType.ToViewCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new ToViewBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('to-view', ToViewBindingCommand);\n\nexport interface FromViewBindingCommand extends IBindingCommand {}\nexport class FromViewBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.FromViewCommand;\n\n  constructor() {\n    this.bindingType = BindingType.FromViewCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new FromViewBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('from-view', FromViewBindingCommand);\n\nexport interface TwoWayBindingCommand extends IBindingCommand {}\nexport class TwoWayBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.TwoWayCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TwoWayCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new TwoWayBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('two-way', TwoWayBindingCommand);\n\n// Not bothering to throw on non-existing modes, should never happen anyway.\n// Keeping all array elements of the same type for better optimizeability.\nconst modeToProperty = ['', '$1', '$2', '', '$4', '', '$6'];\nconst commandToMode = {\n  'bind': BindingMode.toView,\n  'one-time': BindingMode.oneTime,\n  'to-view': BindingMode.toView,\n  'from-view': BindingMode.fromView,\n  'two-way': BindingMode.twoWay,\n};\n\nexport interface DefaultBindingCommand extends IBindingCommand {}\nexport class DefaultBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.BindCommand;\n  public readonly $1: typeof OneTimeBindingCommand.prototype.compile;\n  public readonly $2: typeof ToViewBindingCommand.prototype.compile;\n  public readonly $4: typeof FromViewBindingCommand.prototype.compile;\n  public readonly $6: typeof TwoWayBindingCommand.prototype.compile;\n\n  constructor() {\n    this.bindingType = BindingType.BindCommand;\n    this.$1 = OneTimeBindingCommand.prototype.compile;\n    this.$2 = ToViewBindingCommand.prototype.compile;\n    this.$4 = FromViewBindingCommand.prototype.compile;\n    this.$6 = TwoWayBindingCommand.prototype.compile;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return this[modeToProperty[getMode(binding)]](binding);\n  }\n}\nBindingCommandResource.define('bind', DefaultBindingCommand);\n\nexport interface CallBindingCommand extends IBindingCommand {}\nexport class CallBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.CallCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CallCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new CallBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, true));\n  }\n}\nBindingCommandResource.define('call', CallBindingCommand);\n\nexport interface ForBindingCommand extends IBindingCommand {}\nexport class ForBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.ForCommand;\n\n  constructor() {\n    this.bindingType = BindingType.ForCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): AttributeInstruction {\n    return new IteratorBindingInstruction(binding.expression as ForOfStatement, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('for', ForBindingCommand);\n","/** @internal */\nexport function unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\n/** @internal */\nexport const enum Access {\n  Reset                   = 0b0000000000000,\n  Ancestor                = 0b0000111111111,\n  This                    = 0b0001000000000,\n  Scope                   = 0b0010000000000,\n  Member                  = 0b0100000000000,\n  Keyed                   = 0b1000000000000\n}\n/** @internal */\nexport const enum Precedence {\n  Variadic                = 0b000111101,\n  Assign                  = 0b000111110,\n  Conditional             = 0b000111111,\n  LogicalOR               = 0b001000000,\n  LogicalAND              = 0b010000000,\n  Equality                = 0b011000000,\n  Relational              = 0b100000000,\n  Additive                = 0b101000000,\n  Multiplicative          = 0b110000000,\n  Binary                  = 0b111000000,\n  LeftHandSide            = 0b111000001,\n  Primary                 = 0b111000010,\n  Unary                   = 0b111000011,\n}\n/** @internal */\nexport const enum Token {\n  EOF                     = 0b110000000000_000_000000,\n  ExpressionTerminal      = 0b100000000000_000_000000,\n  AccessScopeTerminal     = 0b010000000000_000_000000,\n  ClosingToken            = 0b001000000000_000_000000,\n  OpeningToken            = 0b000100000000_000_000000,\n  BinaryOp                = 0b000010000000_000_000000,\n  UnaryOp                 = 0b000001000000_000_000000,\n  LeftHandSide            = 0b000000100000_000_000000,\n  StringOrNumericLiteral  = 0b000000011000_000_000000,\n  NumericLiteral          = 0b000000010000_000_000000,\n  StringLiteral           = 0b000000001000_000_000000,\n  IdentifierName          = 0b000000000110_000_000000,\n  Keyword                 = 0b000000000100_000_000000,\n  Identifier              = 0b000000000010_000_000000,\n  Contextual              = 0b000000000001_000_000000,\n  Precedence              = 0b000000000000_111_000000,\n  Type                    = 0b000000000000_000_111111,\n  FalseKeyword            = 0b000000000100_000_000000,\n  TrueKeyword             = 0b000000000100_000_000001,\n  NullKeyword             = 0b000000000100_000_000010,\n  UndefinedKeyword        = 0b000000000100_000_000011,\n  ThisScope               = 0b000000000110_000_000100,\n  ParentScope             = 0b000000000110_000_000101,\n  OpenParen               = 0b010100100000_000_000110,\n  OpenBrace               = 0b000100000000_000_000111,\n  Dot                     = 0b000000100000_000_001000,\n  CloseBrace              = 0b111000000000_000_001001,\n  CloseParen              = 0b111000000000_000_001010,\n  Comma                   = 0b110000000000_000_001011,\n  OpenBracket             = 0b010100100000_000_001100,\n  CloseBracket            = 0b111000000000_000_001101,\n  Colon                   = 0b110000000000_000_001110,\n  Question                = 0b110000000000_000_001111,\n  Ampersand               = 0b110000000000_000_010000,\n  Bar                     = 0b110000000000_000_010011,\n  BarBar                  = 0b110010000000_010_010100,\n  AmpersandAmpersand      = 0b110010000000_011_010101,\n  EqualsEquals            = 0b110010000000_100_010110,\n  ExclamationEquals       = 0b110010000000_100_010111,\n  EqualsEqualsEquals      = 0b110010000000_100_011000,\n  ExclamationEqualsEquals = 0b110010000000_100_011001,\n  LessThan                = 0b110010000000_101_011010,\n  GreaterThan             = 0b110010000000_101_011011,\n  LessThanEquals          = 0b110010000000_101_011100,\n  GreaterThanEquals       = 0b110010000000_101_011101,\n  InKeyword               = 0b110010000100_101_011110,\n  InstanceOfKeyword       = 0b110010000100_101_011111,\n  Plus                    = 0b010011000000_110_100000,\n  Minus                   = 0b010011000000_110_100001,\n  TypeofKeyword           = 0b000001000100_000_100010,\n  VoidKeyword             = 0b000001000100_000_100011,\n  Asterisk                = 0b110010000000_111_100100,\n  Percent                 = 0b110010000000_111_100101,\n  Slash                   = 0b110010000000_111_100110,\n  Equals                  = 0b100000000000_000_100111,\n  Exclamation             = 0b000001000000_000_101000,\n  TemplateTail            = 0b010000100000_000_101001,\n  TemplateContinuation    = 0b010000100000_000_101010,\n  OfKeyword               = 0b100000000101_000_101011\n}\n\n/** @internal */\nexport const enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n","import { Profiler, Reporter } from '@aurelia/kernel';\nimport {\n  AccessKeyed,\n  AccessMember,\n  AccessScope,\n  AccessThis,\n  ArrayBindingPattern,\n  ArrayLiteral,\n  Assign,\n  Binary,\n  BinaryOperator,\n  BindingBehavior,\n  BindingIdentifier,\n  BindingIdentifierOrPattern,\n  BindingType,\n  CallFunction,\n  CallMember,\n  CallScope,\n  Conditional,\n  ExpressionKind,\n  ForOfStatement,\n  IForOfStatement,\n  IInterpolationExpression,\n  Interpolation,\n  IPrimitiveLiteralExpression,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsConditional,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsPrimary,\n  IsUnary,\n  IsValueConverter,\n  ObjectBindingPattern,\n  ObjectLiteral,\n  PrimitiveLiteral,\n  TaggedTemplate,\n  Template,\n  Unary,\n  UnaryOperator,\n  ValueConverter\n} from '@aurelia/runtime';\nimport { Access, Char, Precedence, Token, unescapeCode } from './common';\n\nconst { enter, leave } = Profiler.createTimer('ExpressionParser');\n\nconst $false = PrimitiveLiteral.$false;\nconst $true = PrimitiveLiteral.$true;\nconst $null = PrimitiveLiteral.$null;\nconst $undefined = PrimitiveLiteral.$undefined;\nconst $this = AccessThis.$this;\nconst $parent = AccessThis.$parent;\n\n/** @internal */\nexport class ParserState {\n  public index: number;\n  public startIndex: number;\n  public input: string;\n  public lastIndex: number;\n  public length: number;\n  public currentToken: Token;\n  public tokenValue: string | number;\n  public currentChar: number;\n  public assignable: boolean;\n  public get tokenRaw(): string {\n    return this.input.slice(this.startIndex, this.index);\n  }\n\n  constructor(input: string) {\n    this.index = 0;\n    this.startIndex = 0;\n    this.lastIndex = 0;\n    this.input = input;\n    this.length = input.length;\n    this.currentToken = Token.EOF;\n    this.tokenValue = '';\n    this.currentChar = input.charCodeAt(0);\n    this.assignable = true;\n  }\n}\n\nconst $state = new ParserState('');\n\nconst enum SyntaxError {\n  InvalidExpressionStart = 100,\n  UnconsumedToken = 101,\n  DoubleDot = 102,\n  InvalidMemberExpression = 103,\n  UnexpectedEndOfExpression = 104,\n  ExpectedIdentifier = 105,\n  InvalidForDeclaration = 106,\n  InvalidObjectLiteralPropertyDefinition = 107,\n  UnterminatedQuote = 108,\n  UnterminatedTemplate = 109,\n  MissingExpectedToken = 110,\n  UnexpectedCharacter = 111,\n  MissingValueConverter = 112,\n  MissingBindingBehavior = 113\n}\n\nconst enum SemanticError {\n  NotAssignable = 150,\n  UnexpectedForOf = 151\n}\n\nexport function parseExpression<TType extends BindingType = BindingType.BindCommand>(input: string, bindingType?: TType):\n  TType extends BindingType.Interpolation ? IInterpolationExpression :\n  TType extends BindingType.ForCommand ? IForOfStatement :\n  IsBindingBehavior {\n\n  $state.input = input;\n  $state.length = input.length;\n  $state.index = 0;\n  $state.currentChar = input.charCodeAt(0);\n  return parse($state, Access.Reset, Precedence.Variadic, bindingType === undefined ? BindingType.BindCommand : bindingType);\n}\n\n/** @internal */\n// JUSTIFICATION: This is performance-critical code which follows a subset of the well-known ES spec.\n// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the\n// single source of information for being able to figure it out.\n// It generally does not need to change unless the spec changes or spec violations are found, or optimization\n// opportunities are found (which would likely not fix these warnings in any case).\n// It's therefore not considered to have any tangible impact on the maintainability of the code base.\n// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\n// tslint:disable-next-line:no-big-function cognitive-complexity\nexport function parse<TPrec extends Precedence, TType extends BindingType>(state: ParserState, access: Access, minPrecedence: TPrec, bindingType: TType):\n  TPrec extends Precedence.Unary ? IsUnary :\n  TPrec extends Precedence.Binary ? IsBinary :\n  TPrec extends Precedence.LeftHandSide ? IsLeftHandSide :\n  TPrec extends Precedence.Assign ? IsAssign :\n  TPrec extends Precedence.Conditional ? IsConditional :\n  TPrec extends Precedence.Primary ? IsPrimary :\n  TPrec extends Precedence.Multiplicative ? IsBinary :\n  TPrec extends Precedence.Additive ? IsBinary :\n  TPrec extends Precedence.Relational ? IsBinary :\n  TPrec extends Precedence.Equality ? IsBinary :\n  TPrec extends Precedence.LogicalAND ? IsBinary :\n  TPrec extends Precedence.LogicalOR ? IsBinary :\n  TPrec extends Precedence.Variadic ?\n    TType extends BindingType.Interpolation ? IInterpolationExpression :\n    TType extends BindingType.ForCommand ? IForOfStatement :\n    never : never {\n  if (Profiler.enabled) { enter(); }\n\n  if (state.index === 0) {\n    if (bindingType & BindingType.Interpolation) {\n      if (Profiler.enabled) { leave(); }\n      // tslint:disable-next-line:no-any\n      return parseInterpolation(state) as any;\n    }\n    nextToken(state);\n    if (state.currentToken & Token.ExpressionTerminal) {\n      if (Profiler.enabled) { leave(); }\n      throw Reporter.error(SyntaxError.InvalidExpressionStart, { state });\n    }\n  }\n\n  state.assignable = Precedence.Binary > minPrecedence;\n  let result = undefined as IsExpressionOrStatement;\n\n  if (state.currentToken & Token.UnaryOp) {\n    /** parseUnaryExpression\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     *   1. LeftHandSideExpression\n     *   2. void UnaryExpression\n     *   3. typeof UnaryExpression\n     *   4. + UnaryExpression\n     *   5. - UnaryExpression\n     *   6. ! UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     *   2,3,4,5,6 = false\n     *   1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[state.currentToken & Token.Type] as UnaryOperator;\n    nextToken(state);\n    result = new Unary(op, parse(state, access, Precedence.LeftHandSide, bindingType));\n    state.assignable = false;\n  } else {\n    /** parsePrimaryExpression\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     *   1. this\n     *   2. IdentifierName\n     *   3. Literal\n     *   4. ArrayLiteral\n     *   5. ObjectLiteral\n     *   6. TemplateLiteral\n     *   7. ParenthesizedExpression\n     *\n     * Literal :\n     *    NullLiteral\n     *    BooleanLiteral\n     *    NumericLiteral\n     *    StringLiteral\n     *\n     * ParenthesizedExpression :\n     *   ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     *   1,3,4,5,6,7 = false\n     *   2 = true\n     */\n    primary: switch (state.currentToken) {\n    case Token.ParentScope: // $parent\n      state.assignable = false;\n      do {\n        nextToken(state);\n        access++; // ancestor\n        if (consumeOpt(state, Token.Dot)) {\n          if ((state.currentToken as Token) === Token.Dot) {\n            if (Profiler.enabled) { leave(); }\n            throw Reporter.error(SyntaxError.DoubleDot, { state });\n          } else if ((state.currentToken as Token) === Token.EOF) {\n            if (Profiler.enabled) { leave(); }\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n        } else if (state.currentToken & Token.AccessScopeTerminal) {\n          const ancestor = access & Access.Ancestor;\n          result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThis(ancestor);\n          access = Access.This;\n          break primary;\n        } else {\n          if (Profiler.enabled) { leave(); }\n          throw Reporter.error(SyntaxError.InvalidMemberExpression, { state });\n        }\n      } while (state.currentToken === Token.ParentScope);\n    // falls through\n    case Token.Identifier: // identifier\n      if (bindingType & BindingType.IsIterator) {\n        result = new BindingIdentifier(state.tokenValue as string);\n      } else {\n        result = new AccessScope(state.tokenValue as string, access & Access.Ancestor);\n        access = Access.Scope;\n      }\n      state.assignable = true;\n      nextToken(state);\n      break;\n    case Token.ThisScope: // $this\n      state.assignable = false;\n      nextToken(state);\n      result = $this;\n      access = Access.This;\n      break;\n    case Token.OpenParen: // parenthesized expression\n      nextToken(state);\n      result = parse(state, Access.Reset, Precedence.Assign, bindingType);\n      consume(state, Token.CloseParen);\n      access = Access.Reset;\n      break;\n    case Token.OpenBracket:\n      result = parseArrayLiteralExpression(state, access, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.OpenBrace:\n      result = parseObjectLiteralExpression(state, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.TemplateTail:\n      result = new Template([state.tokenValue as string]);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.TemplateContinuation:\n      result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, false);\n      access = Access.Reset;\n      break;\n    case Token.StringLiteral:\n    case Token.NumericLiteral:\n      result = new PrimitiveLiteral(state.tokenValue);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.NullKeyword:\n    case Token.UndefinedKeyword:\n    case Token.TrueKeyword:\n    case Token.FalseKeyword:\n      result = TokenValues[state.currentToken & Token.Type] as IPrimitiveLiteralExpression;\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    default:\n      if (state.index >= state.length) {\n        if (Profiler.enabled) { leave(); }\n        throw Reporter.error(SyntaxError.UnexpectedEndOfExpression, { state });\n      } else {\n        if (Profiler.enabled) { leave(); }\n        throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n      }\n    }\n\n    if (bindingType & BindingType.IsIterator) {\n      if (Profiler.enabled) { leave(); }\n      // tslint:disable-next-line:no-any\n      return parseForOfStatement(state, result as BindingIdentifierOrPattern) as any;\n    }\n    if (Precedence.LeftHandSide < minPrecedence) {\n      if (Profiler.enabled) { leave(); }\n      // tslint:disable-next-line:no-any\n      return result as any;\n    }\n\n    /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     * MemberExpression :\n     *   1. PrimaryExpression\n     *   2. MemberExpression [ AssignmentExpression ]\n     *   3. MemberExpression . IdentifierName\n     *   4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,4 = false\n     *   2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     *   1. MemberExpression Arguments\n     *   2. CallExpression Arguments\n     *   3. CallExpression [ AssignmentExpression ]\n     *   4. CallExpression . IdentifierName\n     *   5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,2,5 = false\n     *   3,4 = true\n     */\n    let name = state.tokenValue as string;\n    while ((state.currentToken & Token.LeftHandSide) > 0) {\n      switch ((state.currentToken as Token)) {\n        case Token.Dot:\n          state.assignable = true;\n          nextToken(state);\n          if ((state.currentToken & Token.IdentifierName) === 0) {\n            if (Profiler.enabled) { leave(); }\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n          name = state.tokenValue as string;\n          nextToken(state);\n          // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags\n          access = ((access & (Access.This | Access.Scope)) << 1) | (access & Access.Member) | ((access & Access.Keyed) >> 1);\n          if ((state.currentToken as Token) === Token.OpenParen) {\n            if (access === Access.Reset) { // if the left hand side is a literal, make sure we parse a CallMember\n              access = Access.Member;\n            }\n            continue;\n          }\n          if (access & Access.Scope) {\n            result = new AccessScope(name, (result as AccessScope | AccessThis).ancestor);\n          } else { // if it's not $Scope, it's $Member\n            result = new AccessMember(result as IsLeftHandSide, name);\n          }\n          continue;\n        case Token.OpenBracket:\n          state.assignable = true;\n          nextToken(state);\n          access = Access.Keyed;\n          result = new AccessKeyed(result as IsLeftHandSide, parse(state, Access.Reset, Precedence.Assign, bindingType));\n          consume(state, Token.CloseBracket);\n          break;\n        case Token.OpenParen:\n          state.assignable = false;\n          nextToken(state);\n          const args = new Array<IsAssign>();\n          while ((state.currentToken as Token) !== Token.CloseParen) {\n            args.push(parse(state, Access.Reset, Precedence.Assign, bindingType));\n            if (!consumeOpt(state, Token.Comma)) {\n              break;\n            }\n          }\n          consume(state, Token.CloseParen);\n          if (access & Access.Scope) {\n            result = new CallScope(name, args, (result as AccessScope | AccessThis).ancestor);\n          } else if (access & Access.Member) {\n            result = new CallMember(result as IsLeftHandSide, name, args);\n          } else {\n            result = new CallFunction(result as IsLeftHandSide, args);\n          }\n          access = 0;\n          break;\n        case Token.TemplateTail:\n          state.assignable = false;\n          const strings = [state.tokenValue as string];\n          result = new TaggedTemplate(strings, strings, result as IsLeftHandSide);\n          nextToken(state);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, true);\n        default:\n      }\n    }\n  }\n\n  if (Precedence.Binary < minPrecedence) {\n    if (Profiler.enabled) { leave(); }\n    // tslint:disable-next-line:no-any\n    return result as any;\n  }\n\n  /** parseBinaryExpression\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   *   UnaryExpression\n   *   MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   *   MultiplicativeExpression\n   *   AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   *   AdditiveExpression\n   *   RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   *   RelationalExpression\n   *   EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   *   EqualityExpression\n   *   LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   *   LogicalANDExpression\n   *   LogicalORExpression || LogicalANDExpression\n   */\n  while ((state.currentToken & Token.BinaryOp) > 0) {\n    const opToken = state.currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken(state);\n    result = new Binary(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(state, access, opToken & Token.Precedence, bindingType));\n    state.assignable = false;\n  }\n  if (Precedence.Conditional < minPrecedence) {\n    if (Profiler.enabled) { leave(); }\n    // tslint:disable-next-line:no-any\n    return result as any;\n  }\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   *   1. BinaryExpression\n   *   2. BinaryExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n\n  if (consumeOpt(state, Token.Question)) {\n    const yes = parse(state, access, Precedence.Assign, bindingType);\n    consume(state, Token.Colon);\n    result = new Conditional(result as IsBinary, yes, parse(state, access, Precedence.Assign, bindingType));\n    state.assignable = false;\n  }\n  if (Precedence.Assign < minPrecedence) {\n    if (Profiler.enabled) { leave(); }\n    // tslint:disable-next-line:no-any\n    return result as any;\n  }\n\n  /** parseAssignmentExpression\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   *   1. ConditionalExpression\n   *   2. LeftHandSideExpression = AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n  if (consumeOpt(state, Token.Equals)) {\n    if (!state.assignable) {\n      if (Profiler.enabled) { leave(); }\n      throw Reporter.error(SemanticError.NotAssignable, { state });\n    }\n    result = new Assign(result as IsAssignable, parse(state, access, Precedence.Assign, bindingType));\n  }\n  if (Precedence.Variadic < minPrecedence) {\n    if (Profiler.enabled) { leave(); }\n    // tslint:disable-next-line:no-any\n    return result as any;\n  }\n\n  /** parseValueConverter\n   */\n  while (consumeOpt(state, Token.Bar)) {\n    if (state.currentToken === Token.EOF) {\n      if (Profiler.enabled) { leave(); }\n      throw Reporter.error(112);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new ValueConverter(result as IsValueConverter, name, args);\n  }\n\n  /** parseBindingBehavior\n   */\n  while (consumeOpt(state, Token.Ampersand)) {\n    if (state.currentToken === Token.EOF) {\n      if (Profiler.enabled) { leave(); }\n      throw Reporter.error(113);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new BindingBehavior(result as IsBindingBehavior, name, args);\n  }\n  if (state.currentToken !== Token.EOF) {\n    if (bindingType & BindingType.Interpolation) {\n      if (Profiler.enabled) { leave(); }\n      // tslint:disable-next-line:no-any\n      return result as any;\n    }\n    if (state.tokenRaw === 'of') {\n      if (Profiler.enabled) { leave(); }\n      throw Reporter.error(SemanticError.UnexpectedForOf, { state });\n    }\n    if (Profiler.enabled) { leave(); }\n    throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n  }\n  if (Profiler.enabled) { leave(); }\n  // tslint:disable-next-line:no-any\n  return result as any;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteral\n *\n * ArrayLiteral :\n *   [ Elision(opt) ]\n *   [ ElementList ]\n *   [ ElementList, Elision(opt) ]\n *\n * ElementList :\n *   Elision(opt) AssignmentExpression\n *   ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n *  ,\n *  Elision ,\n */\nfunction parseArrayLiteralExpression(state: ParserState, access: Access, bindingType: BindingType): ArrayBindingPattern | ArrayLiteral {\n  nextToken(state);\n  const elements = new Array<IsAssign>();\n  while (state.currentToken !== Token.CloseBracket) {\n    if (consumeOpt(state, Token.Comma)) {\n      elements.push($undefined);\n      if ((state.currentToken as Token) === Token.CloseBracket) {\n        break;\n      }\n    } else {\n      elements.push(parse(state, access, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      if (consumeOpt(state, Token.Comma)) {\n        if ((state.currentToken as Token) === Token.CloseBracket) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  consume(state, Token.CloseBracket);\n  if (bindingType & BindingType.IsIterator) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    state.assignable = false;\n    return new ArrayLiteral(elements);\n  }\n}\n\nfunction parseForOfStatement(state: ParserState, result: BindingIdentifierOrPattern): ForOfStatement {\n  if ((result.$kind & ExpressionKind.IsForDeclaration) === 0) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  if (state.currentToken !== Token.OfKeyword) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  nextToken(state);\n  const declaration = result;\n  const statement = parse(state, Access.Reset, Precedence.Variadic, BindingType.None);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteral :\n *   { }\n *   { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n *   PropertyDefinition\n *   PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n *   IdentifierName\n *   PropertyName : AssignmentExpression\n *\n * PropertyName :\n *   IdentifierName\n *   StringLiteral\n *   NumericLiteral\n */\nfunction parseObjectLiteralExpression(state: ParserState, bindingType: BindingType): ObjectBindingPattern | ObjectLiteral {\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken(state);\n  while (state.currentToken !== Token.CloseBrace) {\n    keys.push(state.tokenValue);\n    // Literal = mandatory colon\n    if (state.currentToken & Token.StringOrNumericLiteral) {\n      nextToken(state);\n      consume(state, Token.Colon);\n      values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n    } else if (state.currentToken & Token.IdentifierName) {\n      // IdentifierName = optional colon\n      const { currentChar, currentToken, index } = state;\n      nextToken(state);\n      if (consumeOpt(state, Token.Colon)) {\n        values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      } else {\n        // Shorthand\n        state.currentChar = currentChar;\n        state.currentToken = currentToken;\n        state.index = index;\n        values.push(parse(state, Access.Reset, Precedence.Primary, bindingType & ~BindingType.IsIterator));\n      }\n    } else {\n      throw Reporter.error(SyntaxError.InvalidObjectLiteralPropertyDefinition, { state });\n    }\n    if ((state.currentToken as Token) !== Token.CloseBrace) {\n      consume(state, Token.Comma);\n    }\n  }\n  consume(state, Token.CloseBrace);\n  if (bindingType & BindingType.IsIterator) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    state.assignable = false;\n    return new ObjectLiteral(keys, values);\n  }\n}\n\nfunction parseInterpolation(state: ParserState): Interpolation {\n  const parts = [];\n  const expressions = [];\n  const length = state.length;\n  let result = '';\n  while (state.index < length) {\n    switch (state.currentChar) {\n      case Char.Dollar:\n        if (state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          state.index += 2;\n          state.currentChar = state.input.charCodeAt(state.index);\n          nextToken(state);\n          const expression = parse(state, Access.Reset, Precedence.Variadic, BindingType.Interpolation);\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += String.fromCharCode(unescapeCode(nextChar(state)));\n        break;\n      default:\n        result += String.fromCharCode(state.currentChar);\n    }\n    nextChar(state);\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions);\n  }\n  return null;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * Template :\n *   NoSubstitutionTemplate\n *   TemplateHead\n *\n * NoSubstitutionTemplate :\n *   ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n *   ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n *   TemplateMiddle\n *   TemplateTail\n *\n * TemplateMiddle :\n *   } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n *   } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n *   TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n *   $ [lookahead ≠ {]\n *   \\ EscapeSequence\n *   SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(state: ParserState, access: Access, bindingType: BindingType, result: IsLeftHandSide, tagged: boolean): TaggedTemplate | Template {\n  const cooked = [state.tokenValue as string];\n  // TODO: properly implement raw parts / decide whether we want this\n  consume(state, Token.TemplateContinuation);\n  const expressions = [parse(state, access, Precedence.Assign, bindingType)];\n  while ((state.currentToken = scanTemplateTail(state)) !== Token.TemplateTail) {\n    cooked.push(state.tokenValue as string);\n    consume(state, Token.TemplateContinuation);\n    expressions.push(parse(state, access, Precedence.Assign, bindingType));\n  }\n  cooked.push(state.tokenValue as string);\n  state.assignable = false;\n  if (tagged) {\n    nextToken(state);\n    return new TaggedTemplate(cooked, cooked, result, expressions);\n  } else {\n    nextToken(state);\n    return new Template(cooked, expressions);\n  }\n}\n\nfunction nextToken(state: ParserState): void {\n  while (state.index < state.length) {\n    state.startIndex = state.index;\n    if ((state.currentToken = CharScanners[state.currentChar](state)) !== null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  state.currentToken = Token.EOF;\n}\n\nfunction nextChar(state: ParserState): number {\n  return state.currentChar = state.input.charCodeAt(++state.index);\n}\n\nfunction scanIdentifier(state: ParserState): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar(state)]);\n\n  const token: Token|undefined = KeywordLookup[state.tokenValue = state.tokenRaw];\n  return token === undefined ? Token.Identifier : token;\n}\n\nfunction scanNumber(state: ParserState, isFloat: boolean): Token {\n  let char = state.currentChar;\n  if (isFloat === false) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n\n    if (char !== Char.Dot) {\n      state.tokenValue = parseInt(state.tokenRaw, 10);\n      return Token.NumericLiteral;\n    }\n    // past this point it's always a float\n    char = nextChar(state);\n    if (state.index >= state.length) {\n      // unless the number ends with a dot - that behaves a little different in native ES expressions\n      // but in our AST that behavior has no effect because numbers are always stored in variables\n      state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);\n      return Token.NumericLiteral;\n    }\n  }\n\n  if (char <= Char.Nine && char >= Char.Zero) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n  } else {\n    state.currentChar = state.input.charCodeAt(--state.index);\n  }\n\n  state.tokenValue = parseFloat(state.tokenRaw);\n  return Token.NumericLiteral;\n}\n\nfunction scanString(state: ParserState): Token {\n  const quote = state.currentChar;\n  nextChar(state); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = state.index;\n\n  while (state.currentChar !== quote) {\n    if (state.currentChar === Char.Backslash) {\n      buffer.push(state.input.slice(marker, state.index));\n      nextChar(state);\n      unescaped = unescapeCode(state.currentChar);\n      nextChar(state);\n      buffer.push(String.fromCharCode(unescaped));\n      marker = state.index;\n    } else if (state.index >= state.length) {\n      throw Reporter.error(SyntaxError.UnterminatedQuote, { state });\n    } else {\n      nextChar(state);\n    }\n  }\n\n  const last = state.input.slice(marker, state.index);\n  nextChar(state); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  state.tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(state: ParserState): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar(state) !== Char.Backtick) {\n    if (state.currentChar === Char.Dollar) {\n      if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n        state.index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if (state.currentChar === Char.Backslash) {\n      result += String.fromCharCode(unescapeCode(nextChar(state)));\n    } else {\n      if (state.index >= state.length) {\n        throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n      }\n      result += String.fromCharCode(state.currentChar);\n    }\n  }\n\n  nextChar(state);\n  state.tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nfunction scanTemplateTail(state: ParserState): Token {\n  if (state.index >= state.length) {\n    throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n  }\n  state.index--;\n  return scanTemplate(state);\n}\n\nfunction consumeOpt(state: ParserState, token: Token): boolean {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n    return true;\n  }\n\n  return false;\n}\n\nfunction consume(state: ParserState, token: Token): void {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n  } else {\n    throw Reporter.error(SyntaxError.MissingExpectedToken, { state, expected: token });\n  }\n}\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, '$this', '$parent',\n\n  '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\\'', '\"',\n\n  '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of'\n];\n\nconst KeywordLookup: {\n  [key: string]: Token;\n} = Object.create(null);\nKeywordLookup.true = Token.TrueKeyword;\nKeywordLookup.null = Token.NullKeyword;\nKeywordLookup.false = Token.FalseKeyword;\nKeywordLookup.undefined = Token.UndefinedKeyword;\nKeywordLookup.$this = Token.ThisScope;\nKeywordLookup.$parent = Token.ParentScope;\nKeywordLookup.in = Token.InKeyword;\nKeywordLookup.instanceof = Token.InstanceOfKeyword;\nKeywordLookup.typeof = Token.TypeofKeyword;\nKeywordLookup.void = Token.VoidKeyword;\nKeywordLookup.of = Token.OfKeyword;\n\n/**\n * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n * Single values are denoted by the second value being a 0\n *\n * Copied from output generated with \"node build/generate-unicode.js\"\n *\n * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n */\nconst codes = {\n  /* [$0-9A-Za_a-z] */\n  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n  IdStart: /*IdentifierStart*/[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n  Digit: /*DecimalNumber*/[0x30, 0x3A],\n  Skip: /*Skippable*/[0, 0x21, 0x7F, 0xA1]\n};\n\n/**\n * Decompress the ranges into an array of numbers so that the char code\n * can be used as an index to the lookup\n */\nfunction decompress(lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void {\n  const rangeCount = compressed.length;\n  for (let i = 0; i < rangeCount; i += 2) {\n    const start = compressed[i];\n    let end = compressed[i + 1];\n    end = end > 0 ? end : start + 1;\n    if (lookup) {\n      lookup.fill(value as CharScanner | number, start, end);\n    }\n    if ($set) {\n      for (let ch = start; ch < end; ch++) {\n        $set.add(ch);\n      }\n    }\n  }\n}\n\n// CharFuncLookup functions\nfunction returnToken(token: Token): (s: ParserState) => Token {\n  return s => {\n    nextChar(s);\n    return token;\n  };\n}\nconst unexpectedCharacter: CharScanner = s => {\n  throw Reporter.error(SyntaxError.UnexpectedCharacter, { state: s });\n};\nunexpectedCharacter.notMapped = true;\n\n// ASCII IdentifierPart lookup\nconst AsciiIdParts = new Set();\ndecompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n\n// IdentifierPart lookup\nconst IdParts = new Uint8Array(0xFFFF);\n// tslint:disable-next-line:no-any\ndecompress(IdParts as any, null, codes.IdStart, 1);\n// tslint:disable-next-line:no-any\ndecompress(IdParts as any, null, codes.Digit, 1);\n\ntype CharScanner = ((p: ParserState) => Token | null) & { notMapped?: boolean };\n\n// Character scanning function lookup\nconst CharScanners = new Array<CharScanner>(0xFFFF);\nCharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\ndecompress(CharScanners, null, codes.Skip, s => {\n  nextChar(s);\n  return null;\n});\ndecompress(CharScanners, null, codes.IdStart, scanIdentifier);\ndecompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));\n\nCharScanners[Char.DoubleQuote] =\nCharScanners[Char.SingleQuote] = s => {\n  return scanString(s);\n};\nCharScanners[Char.Backtick] = s => {\n  return scanTemplate(s);\n};\n\n// !, !=, !==\nCharScanners[Char.Exclamation] = s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Exclamation;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.ExclamationEquals;\n  }\n  nextChar(s);\n  return Token.ExclamationEqualsEquals;\n};\n\n// =, ==, ===\nCharScanners[Char.Equals] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Equals;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.EqualsEquals;\n  }\n  nextChar(s);\n  return Token.EqualsEqualsEquals;\n};\n\n// &, &&\nCharScanners[Char.Ampersand] = s => {\n  if (nextChar(s) !== Char.Ampersand) {\n    return Token.Ampersand;\n  }\n  nextChar(s);\n  return Token.AmpersandAmpersand;\n};\n\n// |, ||\nCharScanners[Char.Bar] = s => {\n  if (nextChar(s) !== Char.Bar) {\n    return Token.Bar;\n  }\n  nextChar(s);\n  return Token.BarBar;\n};\n\n// .\nCharScanners[Char.Dot] = s => {\n  if (nextChar(s) <= Char.Nine && s.currentChar >= Char.Zero) {\n    return scanNumber(s, true);\n  }\n  return Token.Dot;\n};\n\n// <, <=\nCharScanners[Char.LessThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.LessThan;\n  }\n  nextChar(s);\n  return Token.LessThanEquals;\n};\n\n// >, >=\nCharScanners[Char.GreaterThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.GreaterThan;\n  }\n  nextChar(s);\n  return Token.GreaterThanEquals;\n};\n\nCharScanners[Char.Percent]      = returnToken(Token.Percent);\nCharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\nCharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\nCharScanners[Char.Asterisk]     = returnToken(Token.Asterisk);\nCharScanners[Char.Plus]         = returnToken(Token.Plus);\nCharScanners[Char.Comma]        = returnToken(Token.Comma);\nCharScanners[Char.Minus]        = returnToken(Token.Minus);\nCharScanners[Char.Slash]        = returnToken(Token.Slash);\nCharScanners[Char.Colon]        = returnToken(Token.Colon);\nCharScanners[Char.Question]     = returnToken(Token.Question);\nCharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\nCharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\nCharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\nCharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n","import { DI, IContainer, IRegistry } from '@aurelia/kernel';\nimport { IExpressionParser, RuntimeBasicConfiguration } from '@aurelia/runtime';\nimport {\n  AtPrefixedTriggerAttributePattern,\n  ColonPrefixedBindAttributePattern,\n  DotSeparatedAttributePattern,\n  RefAttributePattern\n} from './attribute-pattern';\nimport {\n  CallBindingCommand,\n  DefaultBindingCommand,\n  ForBindingCommand,\n  FromViewBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  TwoWayBindingCommand\n} from './binding-command';\nimport { parseExpression } from './expression-parser';\n\nexport const IExpressionParserRegistration: IRegistry = {\n  register(container: IContainer): void {\n    container.registerTransformer(IExpressionParser, parser => {\n      parser['parseCore'] = parseExpression;\n      return parser;\n    });\n  }\n};\n\n/**\n * Default runtime/environment-agnostic implementations for the following interfaces:\n * - `IExpressionParser`\n */\nexport const DefaultComponents = [\n  IExpressionParserRegistration\n];\n\nexport const AtPrefixedTriggerAttributePatternRegistration = AtPrefixedTriggerAttributePattern as IRegistry;\nexport const ColonPrefixedBindAttributePatternRegistration = ColonPrefixedBindAttributePattern as IRegistry;\nexport const RefAttributePatternRegistration = RefAttributePattern as IRegistry;\nexport const DotSeparatedAttributePatternRegistration = DotSeparatedAttributePattern as IRegistry;\n\n/**\n * Default binding syntax for the following attribute name patterns:\n * - `ref`\n * - `target.command` (dot-separated)\n */\nexport const DefaultBindingSyntax = [\n  RefAttributePatternRegistration,\n  DotSeparatedAttributePatternRegistration\n];\n\n/**\n * Binding syntax for short-hand attribute name patterns:\n * - `@target` (short-hand for `target.trigger`)\n * - `:target` (short-hand for `target.bind`)\n */\nexport const ShortHandBindingSyntax = [\n  AtPrefixedTriggerAttributePatternRegistration,\n  ColonPrefixedBindAttributePatternRegistration\n];\n\nexport const CallBindingCommandRegistration = CallBindingCommand as IRegistry;\nexport const DefaultBindingCommandRegistration = DefaultBindingCommand as IRegistry;\nexport const ForBindingCommandRegistration = ForBindingCommand as IRegistry;\nexport const FromViewBindingCommandRegistration = FromViewBindingCommand as IRegistry;\nexport const OneTimeBindingCommandRegistration = OneTimeBindingCommand as IRegistry;\nexport const ToViewBindingCommandRegistration = ToViewBindingCommand as IRegistry;\nexport const TwoWayBindingCommandRegistration = TwoWayBindingCommand as IRegistry;\n\n/**\n * Default runtime/environment-agnostic binding commands:\n * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way`\n * - Function call: `.call`\n * - Collection observation: `.for`\n */\nexport const DefaultBindingLanguage = [\n  DefaultBindingCommandRegistration,\n  OneTimeBindingCommandRegistration,\n  FromViewBindingCommandRegistration,\n  ToViewBindingCommandRegistration,\n  TwoWayBindingCommandRegistration,\n  CallBindingCommandRegistration,\n  ForBindingCommandRegistration\n];\n\n/**\n * A DI configuration object containing runtime/environment-agnostic registrations:\n * - `BasicConfiguration` from `@aurelia/runtime`\n * - `DefaultComponents`\n * - `DefaultBindingSyntax`\n * - `DefaultBindingLanguage`\n */\nexport const BasicConfiguration = {\n  /**\n   * Apply this configuration to the provided container.\n   */\n  register(container: IContainer): IContainer {\n    return RuntimeBasicConfiguration\n      .register(container)\n      .register(\n        ...DefaultComponents,\n        ...DefaultBindingSyntax,\n        ...DefaultBindingLanguage\n      );\n  },\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n};\n","import { IResourceDescriptions, PLATFORM, Reporter } from '@aurelia/kernel';\nimport {\n  AttributeDefinition,\n  BindingMode,\n  CustomAttributeResource,\n  CustomElementResource,\n  IBindableDescription,\n  TemplateDefinition\n} from '@aurelia/runtime';\nimport { AttrSyntax } from './ast';\nimport { BindingCommandResource, IBindingCommand } from './binding-command';\n\n/**\n * A pre-processed piece of information about declared custom elements, attributes and\n * binding commands, optimized for consumption by the template compiler.\n */\nexport class ResourceModel {\n  private readonly resources: IResourceDescriptions;\n  private readonly elementLookup: Record<string, ElementInfo>;\n  private readonly attributeLookup: Record<string, AttrInfo>;\n  private readonly commandLookup: Record<string, IBindingCommand>;\n\n  constructor(resources: IResourceDescriptions) {\n    this.resources = resources;\n    this.elementLookup = {};\n    this.attributeLookup = {};\n    this.commandLookup = {};\n  }\n\n  /**\n   * Retrieve information about a custom element resource.\n   *\n   * @param element The original DOM element.\n   *\n   * @returns The resource information if the element exists, or `null` if it does not exist.\n   */\n  public getElementInfo(name: string): ElementInfo | null {\n    let result = this.elementLookup[name];\n    if (result === undefined) {\n      const def = this.resources.find(CustomElementResource, name);\n      if (def === null) {\n        result = null;\n      } else {\n        result = createElementInfo(def);\n      }\n      this.elementLookup[name] = result;\n    }\n    return result;\n  }\n\n  /**\n   * Retrieve information about a custom attribute resource.\n   *\n   * @param syntax The parsed `AttrSyntax`\n   *\n   * @returns The resource information if the attribute exists, or `null` if it does not exist.\n   */\n  public getAttributeInfo(syntax: AttrSyntax): AttrInfo | null {\n    const name = PLATFORM.camelCase(syntax.target);\n    let result = this.attributeLookup[name];\n    if (result === undefined) {\n      const def = this.resources.find(CustomAttributeResource, name);\n      if (def === null) {\n        result = null;\n      } else {\n        result = createAttributeInfo(def);\n      }\n      this.attributeLookup[name] = result;\n    }\n    return result;\n  }\n\n  /**\n   * Retrieve a binding command resource.\n   *\n   * @param name The parsed `AttrSyntax`\n   *\n   * @returns An instance of the command if it exists, or `null` if it does not exist.\n   */\n  public getBindingCommand(syntax: AttrSyntax): IBindingCommand | null {\n    const name = syntax.command;\n    if (name === null) {\n      return null;\n    }\n    let result = this.commandLookup[name];\n    if (result === undefined) {\n      result = this.resources.create(BindingCommandResource, name);\n      if (result === null) {\n        // unknown binding command\n        throw Reporter.error(0); // TODO: create error code\n      }\n      this.commandLookup[name] = result;\n    }\n    return result;\n  }\n}\n\nfunction createElementInfo(def: TemplateDefinition): ElementInfo {\n  const info = new ElementInfo(def.name, def.containerless);\n  const bindables = def.bindables;\n  const defaultBindingMode = BindingMode.toView;\n\n  let bindable: IBindableDescription;\n  let prop: string;\n  let attr: string;\n  let mode: BindingMode;\n\n  for (prop in bindables) {\n    bindable = bindables[prop];\n    // explicitly provided property name has priority over the implicit property name\n    if (bindable.property !== undefined) {\n      prop = bindable.property;\n    }\n    // explicitly provided attribute name has priority over the derived implicit attribute name\n    if (bindable.attribute !== undefined) {\n      attr = bindable.attribute;\n    } else {\n      // derive the attribute name from the resolved property name\n      attr = PLATFORM.kebabCase(prop);\n    }\n    if (bindable.mode !== undefined && bindable.mode !== BindingMode.default) {\n      mode = bindable.mode;\n    } else {\n      mode = defaultBindingMode;\n    }\n    info.bindables[attr] = new BindableInfo(prop, mode);\n  }\n  return info;\n}\n\nfunction createAttributeInfo(def: AttributeDefinition): AttrInfo {\n  const info = new AttrInfo(def.name, def.isTemplateController);\n  const bindables = def.bindables;\n  const defaultBindingMode = def.defaultBindingMode !== undefined && def.defaultBindingMode !== BindingMode.default\n    ? def.defaultBindingMode\n    : BindingMode.toView;\n\n  let bindable: IBindableDescription;\n  let prop: string;\n  let mode: BindingMode;\n  let bindableCount: number = 0;\n\n  for (prop in bindables) {\n    ++bindableCount;\n    bindable = bindables[prop];\n    // explicitly provided property name has priority over the implicit property name\n    if (bindable.property !== undefined) {\n      prop = bindable.property;\n    }\n    if (bindable.mode !== undefined && bindable.mode !== BindingMode.default) {\n      mode = bindable.mode;\n    } else {\n      mode = defaultBindingMode;\n    }\n    info.bindables[prop] = new BindableInfo(prop, mode);\n    // set to first bindable by convention\n    if (info.bindable === null) {\n      info.bindable = info.bindables[prop];\n    }\n  }\n  // if no bindables are present, default to \"value\"\n  if (info.bindable === null) {\n    info.bindable = new BindableInfo('value', defaultBindingMode);\n  }\n  if (def.hasDynamicOptions || bindableCount > 1) {\n    info.hasDynamicOptions = true;\n  }\n  return info;\n}\n\n/**\n * A pre-processed piece of information about a defined bindable property on a custom\n * element or attribute, optimized for consumption by the template compiler.\n */\nexport class BindableInfo {\n  /**\n   * The pre-processed *property* (not attribute) name of the bindable, which is\n   * (in order of priority):\n   *\n   * 1. The `property` from the description (if defined)\n   * 2. The name of the property of the bindable itself\n   */\n  public propName: string;\n  /**\n   * The pre-processed (default) bindingMode of the bindable, which is (in order of priority):\n   *\n   * 1. The `mode` from the bindable (if defined and not bindingMode.default)\n   * 2. The `defaultBindingMode` (if it's an attribute, defined, and not bindingMode.default)\n   * 3. `bindingMode.toView`\n   */\n  public mode: BindingMode;\n\n  constructor(propName: string, mode: BindingMode) {\n    this.propName = propName;\n    this.mode = mode;\n  }\n}\n\n/**\n * Pre-processed information about a custom element resource, optimized\n * for consumption by the template compiler.\n */\nexport class ElementInfo {\n  public name: string;\n  public containerless: boolean;\n\n  /**\n   * A lookup of the bindables of this element, indexed by the (pre-processed)\n   * attribute names as they would be found in parsed markup.\n   */\n  public bindables: Record<string, BindableInfo>;\n\n  constructor(name: string, containerless: boolean) {\n    this.name = name;\n    this.containerless = containerless;\n    this.bindables = {};\n  }\n}\n\n/**\n * Pre-processed information about a custom attribute resource, optimized\n * for consumption by the template compiler.\n */\nexport class AttrInfo {\n  public name: string;\n\n  /**\n   * A lookup of the bindables of this attribute, indexed by the (pre-processed)\n   * bindable names as they would be found in the attribute value.\n   *\n   * Only applicable to multi attribute bindings (semicolon-separated).\n   */\n  public bindables: Record<string, BindableInfo>;\n  /**\n   * The single or first bindable of this attribute, or a default 'value'\n   * bindable if no bindables were defined on the attribute.\n   *\n   * Only applicable to single attribute bindings (where the attribute value\n   * contains no semicolons)\n   */\n  public bindable: BindableInfo;\n\n  public isTemplateController: boolean;\n\n  public hasDynamicOptions: boolean;\n\n  constructor(name: string, isTemplateController: boolean) {\n    this.name = name;\n    this.bindables = {};\n    this.bindable = null;\n    this.isTemplateController = isTemplateController;\n    this.hasDynamicOptions = false;\n  }\n}\n","import { AnyBindingExpression, IDOM, IInterpolationExpression, INode } from '@aurelia/runtime';\nimport { AttrSyntax } from './ast';\nimport { IBindingCommand } from './binding-command';\nimport { AttrInfo, BindableInfo, ElementInfo } from './resource-model';\n\nexport const enum SymbolFlags {\n  type                 = 0b000000_111111111,\n  isTemplateController = 0b000000_000000001,\n  isReplacePart        = 0b000000_000000010,\n  isCustomAttribute    = 0b000000_000000100,\n  isPlainAttribute     = 0b000000_000001000,\n  isCustomElement      = 0b000000_000010000,\n  isLetElement         = 0b000000_000100000,\n  isPlainElement       = 0b000000_001000000,\n  isText               = 0b000000_010000000,\n  isBinding            = 0b000000_100000000,\n  hasMarker            = 0b000001_000000000,\n  hasTemplate          = 0b000010_000000000,\n  hasAttributes        = 0b000100_000000000,\n  hasBindings          = 0b001000_000000000,\n  hasChildNodes        = 0b010000_000000000,\n  hasParts             = 0b100000_000000000,\n}\n\nfunction createMarker(dom: IDOM): INode {\n  const marker = dom.createElement('au-m');\n  dom.makeTarget(marker);\n  return marker;\n}\n\nexport interface ISymbol {\n  flags: SymbolFlags;\n}\n\nexport interface IAttributeSymbol extends ISymbol {\n  syntax: AttrSyntax;\n}\n\nexport interface ISymbolWithBindings extends ISymbol {\n  bindings: BindingSymbol[];\n}\n\nexport interface IResourceAttributeSymbol extends ISymbolWithBindings {\n  res: string;\n  bindings: BindingSymbol[];\n}\n\nexport interface INodeSymbol extends ISymbol {\n  physicalNode: INode;\n}\n\nexport interface IParentNodeSymbol extends INodeSymbol {\n  physicalNode: INode;\n  templateController: TemplateControllerSymbol;\n}\n\nexport interface ISymbolWithTemplate extends INodeSymbol {\n  physicalNode: INode;\n  template: IParentNodeSymbol;\n}\n\nexport interface IElementSymbol extends IParentNodeSymbol {\n  attributes: IAttributeSymbol[];\n  childNodes: INodeSymbol[];\n  isTarget: boolean;\n}\n\nexport interface ISymbolWithMarker extends INodeSymbol {\n  marker: INode;\n}\n\n/**\n * A html attribute that is associated with a registered resource, specifically a template controller.\n */\nexport class TemplateControllerSymbol implements IResourceAttributeSymbol, IParentNodeSymbol, ISymbolWithTemplate, ISymbolWithMarker {\n  public flags: SymbolFlags;\n  public res: string;\n  public partName: string | null;\n  public physicalNode: INode | null;\n  public syntax: AttrSyntax;\n  public template: IParentNodeSymbol | null;\n  public templateController: TemplateControllerSymbol | null;\n  public marker: INode;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(dom: IDOM, syntax: AttrSyntax, info: AttrInfo, partName: string | null) {\n    this.flags = SymbolFlags.isTemplateController | SymbolFlags.hasMarker;\n    this.res = info.name;\n    this.partName = partName;\n    this.physicalNode = null;\n    this.syntax = syntax;\n    this.template = null;\n    this.templateController = null;\n    this.marker = createMarker(dom);\n    this._bindings = null;\n  }\n}\n\n/**\n * Wrapper for an element (with all of its attributes, regardless of the order in which they are declared)\n * that has a replace-part attribute on it.\n *\n * This element will be lifted from the DOM just like a template controller.\n */\nexport class ReplacePartSymbol implements ISymbolWithTemplate {\n  public flags: SymbolFlags;\n  public name: string;\n  public physicalNode: INode | null;\n  public parent: IParentNodeSymbol | null;\n  public template: IParentNodeSymbol | null;\n\n  constructor(name: string) {\n    this.flags = SymbolFlags.isReplacePart;\n    this.name = name;\n    this.physicalNode = null;\n    this.parent = null;\n    this.template = null;\n  }\n}\n\n/**\n * A html attribute that is associated with a registered resource, but not a template controller.\n */\nexport class CustomAttributeSymbol implements IAttributeSymbol, IResourceAttributeSymbol {\n  public flags: SymbolFlags;\n  public res: string;\n  public syntax: AttrSyntax;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(syntax: AttrSyntax, info: AttrInfo) {\n    this.flags = SymbolFlags.isCustomAttribute;\n    this.res = info.name;\n    this.syntax = syntax;\n    this._bindings = null;\n  }\n}\n\n/**\n * An attribute, with either a binding command or an interpolation, whose target is the html\n * attribute of the element.\n *\n * This will never target a bindable property of a custom attribute or element;\n */\nexport class PlainAttributeSymbol implements IAttributeSymbol {\n  public flags: SymbolFlags;\n  public syntax: AttrSyntax;\n  public command: IBindingCommand | null;\n  public expression: AnyBindingExpression | null;\n\n  constructor(\n    syntax: AttrSyntax,\n    command: IBindingCommand | null,\n    expression: AnyBindingExpression | null\n  ) {\n    this.flags = SymbolFlags.isPlainAttribute;\n    this.syntax = syntax;\n    this.command = command;\n    this.expression = expression;\n  }\n}\n\n/**\n * Either an attribute on an custom element that maps to a declared bindable property of that element,\n * a single-value bound custom attribute, or one of several bindables that were extracted from the attribute\n * value of a dynamicOptions custom attribute.\n *\n * This will always target a bindable property of a custom attribute or element;\n */\nexport class BindingSymbol implements ISymbol {\n  public flags: SymbolFlags;\n  public command: IBindingCommand | null;\n  public bindable: BindableInfo;\n  public expression: AnyBindingExpression | null;\n  public rawValue: string;\n  public target: string;\n\n  constructor(\n    command: IBindingCommand | null,\n    bindable: BindableInfo,\n    expression: AnyBindingExpression | null,\n    rawValue: string,\n    target: string\n  ) {\n    this.flags = SymbolFlags.isBinding;\n    this.command = command;\n    this.bindable = bindable;\n    this.expression = expression;\n    this.rawValue = rawValue;\n    this.target = target;\n  }\n}\n\n/**\n * A html element that is associated with a registered resource either via its (lowerCase) `nodeName`\n * or the value of its `as-element` attribute.\n */\nexport class CustomElementSymbol implements IElementSymbol, ISymbolWithBindings, ISymbolWithMarker {\n  public flags: SymbolFlags;\n  public res: string;\n  public physicalNode: INode;\n  public bindables: Record<string, BindableInfo>;\n  public isTarget: true;\n  public templateController: TemplateControllerSymbol | null;\n  public isContainerless: boolean;\n  public marker: INode | null;\n\n  private _attributes: IAttributeSymbol[] | null;\n  public get attributes(): IAttributeSymbol[] {\n    if (this._attributes === null) {\n      this._attributes = [];\n      this.flags |= SymbolFlags.hasAttributes;\n    }\n    return this._attributes;\n  }\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  private _childNodes: INodeSymbol[] | null;\n  public get childNodes(): INodeSymbol[] {\n    if (this._childNodes === null) {\n      this._childNodes = [];\n      this.flags |= SymbolFlags.hasChildNodes;\n    }\n    return this._childNodes;\n  }\n\n  private _parts: ReplacePartSymbol[] | null;\n  public get parts(): ReplacePartSymbol[] {\n    if (this._parts === null) {\n      this._parts = [];\n      this.flags |= SymbolFlags.hasParts;\n    }\n    return this._parts;\n  }\n\n  constructor(dom: IDOM, node: INode, info: ElementInfo) {\n    this.flags = SymbolFlags.isCustomElement;\n    this.res = info.name;\n    this.physicalNode = node;\n    this.bindables = info.bindables;\n    this.isTarget = true;\n    this.templateController = null;\n    if (info.containerless) {\n      this.isContainerless = true;\n      this.marker = createMarker(dom);\n      this.flags |= SymbolFlags.hasMarker;\n    } else {\n      this.isContainerless = false;\n      this.marker = null;\n    }\n    this._attributes = null;\n    this._bindings = null;\n    this._childNodes = null;\n    this._parts = null;\n  }\n}\n\nexport class LetElementSymbol implements INodeSymbol, ISymbolWithBindings, ISymbolWithMarker {\n  public flags: SymbolFlags;\n  public physicalNode: INode;\n  public toViewModel: boolean;\n  public marker: INode;\n\n  private _bindings: BindingSymbol[] | null;\n  public get bindings(): BindingSymbol[] {\n    if (this._bindings === null) {\n      this._bindings = [];\n      this.flags |= SymbolFlags.hasBindings;\n    }\n    return this._bindings;\n  }\n\n  constructor(dom: IDOM, node: INode) {\n    this.flags = SymbolFlags.isLetElement | SymbolFlags.hasMarker;\n    this.physicalNode = node;\n    this.toViewModel = false;\n    this.marker = createMarker(dom);\n    this._bindings = null;\n  }\n}\n\n/**\n * A normal html element that may or may not have attribute behaviors and/or child node behaviors.\n *\n * It is possible for a PlainElementSymbol to not yield any instructions during compilation.\n */\nexport class PlainElementSymbol implements IElementSymbol {\n  public flags: SymbolFlags;\n  public physicalNode: INode;\n  public isTarget: boolean;\n  public templateController: TemplateControllerSymbol | null;\n  public hasSlots?: boolean;\n\n  private _attributes: IAttributeSymbol[] | null;\n  public get attributes(): IAttributeSymbol[] {\n    if (this._attributes === null) {\n      this._attributes = [];\n      this.flags |= SymbolFlags.hasAttributes;\n    }\n    return this._attributes;\n  }\n\n  private _childNodes: INodeSymbol[] | null;\n  public get childNodes(): INodeSymbol[] {\n    if (this._childNodes === null) {\n      this._childNodes = [];\n      this.flags |= SymbolFlags.hasChildNodes;\n    }\n    return this._childNodes;\n  }\n\n  constructor(node: INode) {\n    this.flags = SymbolFlags.isPlainElement;\n    this.physicalNode = node;\n    this.isTarget = false;\n    this.templateController = null;\n    this._attributes = null;\n    this._childNodes = null;\n  }\n}\n\n/**\n * A standalone text node that has an interpolation.\n */\nexport class TextSymbol implements INodeSymbol, ISymbolWithMarker {\n  public flags: SymbolFlags;\n  public physicalNode: INode;\n  public interpolation: IInterpolationExpression;\n  public marker: INode;\n\n  constructor(dom: IDOM, node: INode, interpolation: IInterpolationExpression) {\n    this.flags = SymbolFlags.isText | SymbolFlags.hasMarker;\n    this.physicalNode = node;\n    this.interpolation = interpolation;\n    this.marker = createMarker(dom);\n  }\n}\n"],"names":["enter","leave"],"mappings":"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"}