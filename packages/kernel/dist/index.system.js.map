{"version":3,"file":"index.system.js","sources":["../src/platform.ts","../src/reporter.ts","../src/di.ts","../src/path.ts","../src/profiler.ts","../src/resource.ts","../src/eventaggregator.ts","../src/functions.ts"],"sourcesContent":["import { IPerformanceEntry, ITimerHandler, IWindowOrWorkerGlobalScope, IPerformance } from './interfaces';\n\n// tslint:disable-next-line:no-redundant-jump\nfunction $noop(): void { return; }\n\ndeclare var process: { versions: { node: unknown } };\ndeclare var global: IWindowOrWorkerGlobalScope;\ndeclare var self: IWindowOrWorkerGlobalScope;\ndeclare var window: IWindowOrWorkerGlobalScope;\ndeclare function setTimeout(handler: (...args: unknown[]) => void, timeout: number): unknown;\n\nconst $global: IWindowOrWorkerGlobalScope = (function (): IWindowOrWorkerGlobalScope {\n  // https://github.com/Microsoft/tslint-microsoft-contrib/issues/415\n  // tslint:disable:no-typeof-undefined\n  if (typeof global !== 'undefined') {\n    return global as unknown as IWindowOrWorkerGlobalScope;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  // tslint:enable:no-typeof-undefined\n  try {\n    // Not all environments allow eval and Function. Use only as a last resort:\n    // tslint:disable-next-line:no-function-constructor-with-string-args function-constructor\n    return new Function('return this')();\n  } catch {\n    // If all fails, give up and create an object.\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as IWindowOrWorkerGlobalScope;\n  }\n})();\n\nconst isBrowserLike = (\n  typeof window !== 'undefined'\n  && typeof (window as unknown as { document: unknown }).document !== 'undefined'\n);\n\nconst isWebWorkerLike = (\n  typeof self === 'object'\n  && self.constructor != null\n  && self.constructor.name === 'DedicatedWorkerGlobalScope'\n);\n\nconst isNodeLike = (\n  typeof process !== 'undefined'\n  && process.versions != null\n  && process.versions.node != null\n);\n\n// performance.now polyfill for non-browser envs based on https://github.com/myrne/performance-now\nconst $now = (function (): () => number {\n  let getNanoSeconds: () => number;\n  let hrtime: (time?: [number, number]) => [number, number];\n  let moduleLoadTime: number;\n  let nodeLoadTime: number;\n  let upTime: number;\n\n  if ($global.performance != null && $global.performance.now != null) {\n    const $performance = $global.performance;\n    return function (): number {\n      return $performance.now();\n    };\n  } else if ($global.process != null && $global.process.hrtime != null) {\n    const now = function (): number {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = $global.process.hrtime;\n    getNanoSeconds = function (): number {\n      let hr: [number, number];\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = $global.process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n    return now;\n  } else {\n    throw new Error('Unsupported runtime'); // Can't really happen, can it?\n  }\n})();\n\n// performance.mark / measure polyfill based on https://github.com/blackswanny/performance-polyfill\n// note: this is NOT intended to be a polyfill for browsers that don't support it; it's just for NodeJS\n// TODO: probably want to move environment-specific logic to the appropriate runtime (e.g. the NodeJS polyfill\n// to runtime-html-jsdom)\nconst {\n  $mark,\n  $measure,\n  $getEntriesByName,\n  $getEntriesByType,\n  $clearMarks,\n  $clearMeasures\n} = (function (): {\n  $mark: IWindowOrWorkerGlobalScope['performance']['mark'];\n  $measure: IWindowOrWorkerGlobalScope['performance']['measure'];\n  $getEntriesByName: IWindowOrWorkerGlobalScope['performance']['getEntriesByName'];\n  $getEntriesByType: IWindowOrWorkerGlobalScope['performance']['getEntriesByType'];\n  $clearMarks: IWindowOrWorkerGlobalScope['performance']['clearMarks'];\n  $clearMeasures: IWindowOrWorkerGlobalScope['performance']['clearMeasures'];\n } {\n  if (\n    $global.performance != null &&\n    $global.performance.mark != null &&\n    $global.performance.measure != null &&\n    $global.performance.getEntriesByName != null &&\n    $global.performance.getEntriesByType != null &&\n    $global.performance.clearMarks != null &&\n    $global.performance.clearMeasures != null\n  ) {\n    const $performance = $global.performance;\n    return {\n      $mark: function(name: string): void {\n        $performance.mark(name);\n      },\n      $measure: function(name: string, start?: string, end?: string): void {\n        $performance.measure(name, start, end);\n      },\n      $getEntriesByName: function(name: string): IPerformanceEntry[] {\n        return $performance.getEntriesByName(name);\n      },\n      $getEntriesByType: function(type: string): IPerformanceEntry[] {\n        return $performance.getEntriesByType(type);\n      },\n      $clearMarks: function(name?: string): void {\n        $performance.clearMarks(name);\n      },\n      $clearMeasures: function(name?: string): void {\n        $performance.clearMeasures(name);\n      }\n    };\n  } else if ($global.process != null && $global.process.hrtime != null) {\n    const entries: IPerformanceEntry[] = [];\n    const marksIndex: Record<string, IPerformanceEntry> = {};\n\n    const filterEntries = function (key: keyof IPerformanceEntry, value: string): IPerformanceEntry[] {\n      let i = 0;\n      const n = entries.length;\n      const result = [];\n      for (; i < n; i++) {\n        if (entries[i][key] === value) {\n          result.push(entries[i]);\n        }\n      }\n      return\tresult;\n    };\n\n    const clearEntries = function (type: string, name?: string): void {\n      let i = entries.length;\n      let entry: IPerformanceEntry;\n      while (i--) {\n        entry = entries[i];\n        if (entry.entryType === type && (name === void 0 || entry.name === name)) {\n          entries.splice(i, 1);\n        }\n      }\n    };\n\n    return {\n      $mark: function(name: string): void {\n        const mark: IPerformanceEntry = {\n          name,\n          entryType: 'mark',\n          startTime: $now(),\n          duration: 0\n        };\n        entries.push(mark);\n        marksIndex[name] = mark;\n      },\n      $measure: function(name: string, startMark?: string, endMark?: string): void {\n        let startTime: number;\n        let endTime: number;\n\n        if (endMark != null) {\n          if (marksIndex[endMark] == null) {\n            throw new SyntaxError(`Failed to execute 'measure' on 'Performance': The mark '${endMark}' does not exist.`);\n          }\n          if (marksIndex[endMark] !== void 0) {\n            endTime = marksIndex[endMark].startTime;\n          } else {\n            endTime = $now();\n          }\n        } else {\n          endTime = $now();\n        }\n        if (startMark != null) {\n          if (marksIndex[startMark] == null) {\n            throw new SyntaxError(`Failed to execute 'measure' on 'Performance': The mark '${startMark}' does not exist.`);\n          }\n          if (marksIndex[startMark] !== void 0) {\n            startTime = marksIndex[startMark].startTime;\n          } else {\n            startTime = 0;\n          }\n        } else {\n          startTime = 0;\n        }\n\n        entries.push({\n          name,\n          entryType: 'measure',\n          startTime,\n          duration: endTime - startTime\n        });\n      },\n      $getEntriesByName: function(name: string): IPerformanceEntry[] {\n        return filterEntries('name', name);\n      },\n      $getEntriesByType: function(type: string): IPerformanceEntry[] {\n        return filterEntries('entryType', type);\n      },\n      $clearMarks: function(name?: string): void {\n        clearEntries('mark', name);\n      },\n      $clearMeasures: function(name?: string): void {\n        clearEntries('measure', name);\n      }\n    };\n  } else {\n    throw new Error('Unsupported runtime'); // Can't really happen, can it?\n  }\n})();\n\n// RAF polyfill for non-browser envs from https://github.com/chrisdickinson/raf/blob/master/index.js\nconst { $raf, $caf } = (function (): { $raf(callback: (time: number) => void): number; $caf(handle: number): void } {\n  let raf: (callback: (time: number) => void) => number = $global.requestAnimationFrame;\n  let caf: (handle: number) => void = $global.cancelAnimationFrame;\n\n  if (raf === void 0 || caf === void 0) {\n    let last = 0;\n    let id = 0;\n    const queue: { handle: number; cancelled: boolean; callback(time: number): void }[] = [];\n    const frameDuration = 1000 / 60;\n\n    raf = function(callback: (time: number) => void): number {\n      let _now: number;\n      let next: number;\n      if (queue.length === 0) {\n        _now = $now();\n        next = Math.max(0, frameDuration - (_now - last));\n        last = next + _now;\n        setTimeout(\n          function (): void {\n            const cp = queue.slice(0);\n            // Clear queue here to prevent callbacks from appending listeners to the current frame's queue\n            queue.length = 0;\n            for (let i = 0; i < cp.length; ++i) {\n              if (!cp[i].cancelled) {\n                try {\n                  cp[i].callback(last);\n                } catch (e) {\n                  setTimeout(function (): void { throw e; }, 0);\n                }\n              }\n            }\n          },\n          Math.round(next)\n        );\n      }\n      queue.push({\n        handle: ++id,\n        callback: callback,\n        cancelled: false\n      });\n      return id;\n    };\n\n    caf = function(handle: number): void {\n      for (let i = 0; i < queue.length; ++i) {\n        if (queue[i].handle === handle) {\n          queue[i].cancelled = true;\n        }\n      }\n    };\n  }\n\n  const $$raf = function(callback: (time: number) => void): number {\n    return raf.call($global, callback);\n  };\n  $$raf.cancel = function (time: number): void {\n    caf.call($global, time);\n  };\n  $global.requestAnimationFrame = raf;\n  $global.cancelAnimationFrame = caf;\n  return { $raf: $$raf, $caf: caf };\n})();\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty as unknown as {\n  call<V, T = object, K extends PropertyKey = PropertyKey>(target: T, key: K): target is (\n    T & { [P in K]: V; }\n  );\n  call<T, K extends keyof T>(target: T, key: K): target is (\n    T & { [P in K]-?: T[P]; }\n  );\n};\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyObject = Object.freeze({}) as any;\n\nconst $PLATFORM = Object.freeze({\n  /**\n   * `true` if there is a `window` variable in the global scope with a `document` property.\n   *\n   * NOTE: this does not guarantee that the code is actually running in a browser, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `window` global is available and likely behaves similar to how it would in a browser.\n   */\n  isBrowserLike,\n\n  /**\n   * `true` if there is a `self` variable (of type `object`) in the global scope with constructor name `'DedicatedWorkerGlobalScope'`.\n   *\n   * NOTE: this does not guarantee that the code is actually running in a web worker, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `self` global is available and likely behaves similar to how it would in a web worker.\n   */\n  isWebWorkerLike,\n\n  /**\n   * `true` if there is a `process` variable in the global scope with a `versions` property which has a `node` property.\n   *\n   * NOTE: this is not a guarantee that the code is actually running in nodejs, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `process` global is available and likely behaves similar to how it would in nodejs.\n   */\n  isNodeLike,\n\n  global: $global,\n  emptyArray,\n  emptyObject,\n  noop: $noop,\n  now: $now,\n  mark: $mark,\n  measure: $measure,\n  getEntriesByName: $getEntriesByName,\n  getEntriesByType: $getEntriesByType,\n  clearMarks: $clearMarks,\n  clearMeasures: $clearMeasures,\n  hasOwnProperty,\n\n  requestAnimationFrame(callback: (time: number) => void): number {\n    return $raf(callback);\n  },\n\n  cancelAnimationFrame(handle: number): void {\n    return $caf(handle);\n  },\n\n  clearInterval(handle?: number): void {\n    $global.clearInterval(handle);\n  },\n\n  clearTimeout(handle?: number): void {\n    $global.clearTimeout(handle);\n  },\n\n  // tslint:disable-next-line:no-any\n  setInterval(handler: ITimerHandler, timeout?: number, ...args: any[]): number {\n    return $global.setInterval(handler, timeout, ...args);\n  },\n\n  // tslint:disable-next-line:no-any\n  setTimeout(handler: ITimerHandler, timeout?: number, ...args: any[]): number {\n    return $global.setTimeout(handler, timeout, ...args);\n  },\n\n  restore(): void {\n    Object.assign(PLATFORM, $PLATFORM);\n  },\n});\n\ninterface IPlatform extends IPerformance {\n  /**\n   * `true` if there is a `window` variable in the global scope with a `document` property.\n   *\n   * NOTE: this does not guarantee that the code is actually running in a browser, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `window` global is available and likely behaves similar to how it would in a browser.\n   */\n  isBrowserLike: boolean;\n\n  /**\n   * `true` if there is a `self` variable (of type `object`) in the global scope with constructor name `'DedicatedWorkerGlobalScope'`.\n   *\n   * NOTE: this does not guarantee that the code is actually running in a web worker, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `self` global is available and likely behaves similar to how it would in a web worker.\n   */\n  isWebWorkerLike: boolean;\n\n  /**\n   * `true` if there is a `process` variable in the global scope with a `versions` property which has a `node` property.\n   *\n   * NOTE: this is not a guarantee that the code is actually running in nodejs, as some libraries tamper with globals.\n   * The only conclusion that can be drawn is that the `process` global is available and likely behaves similar to how it would in nodejs.\n   */\n  isNodeLike: boolean;\n\n  global: IWindowOrWorkerGlobalScope;\n  emptyArray: any[];\n  emptyObject: any;\n\n  noop(): void;\n\n  hasOwnProperty: {\n    call<V, T = object, K extends PropertyKey = PropertyKey>(target: T, key: K): target is (\n      T & { [P in K]: V; }\n    );\n    call<T, K extends keyof T>(target: T, key: K): target is (\n      T & { [P in K]-?: T[P]; }\n    );\n  };\n\n  requestAnimationFrame(callback: (time: number) => void): number;\n  cancelAnimationFrame(handle: number): void;\n  clearInterval(handle?: number): void;\n  clearTimeout(handle?: number): void;\n  setInterval(handler: ITimerHandler, timeout?: number, ...args: any[]): number;\n  setTimeout(handler: ITimerHandler, timeout?: number, ...args: any[]): number;\n\n  /**\n   * Restore the global `PLATFORM` object to its original state as it was immediately after module initialization.\n   * Useful for when you need to stub out one or more of its methods in a unit test.\n   *\n   * Extraneous properties are NOT removed.\n   */\n  restore(): void;\n}\n\nexport const PLATFORM: IPlatform = { ...$PLATFORM };\n","\nexport interface ITraceInfo {\n  readonly objName: string;\n  readonly methodName: string;\n  readonly depth: number;\n  params: ReadonlyArray<unknown> | null;\n  next: ITraceInfo | null;\n  prev: ITraceInfo | null;\n}\nexport interface ITraceWriter {\n  write(info: ITraceInfo): void;\n}\nexport interface ILiveLoggingOptions {\n  rendering?: boolean;\n  binding?: boolean;\n  observation?: boolean;\n  attaching?: boolean;\n  mounting?: boolean;\n  di?: boolean;\n  lifecycle?: boolean;\n  jit?: boolean;\n}\nexport const enum LogLevel {\n  error,\n  warn,\n  info,\n  debug,\n}\nexport const Reporter = {\n  level: LogLevel.warn,\n  write(code: number, ...params: unknown[]): void { return; },\n  error(code: number, ...params: unknown[]): Error { return new Error(`Code ${code}`); }\n};\nexport const Tracer = {\n  /**\n   * A convenience property for the user to conditionally call the tracer.\n   * This saves unnecessary `noop` and `slice` calls in non-AOT scenarios even if debugging is disabled.\n   * In AOT these calls will simply be removed entirely.\n   *\n   * This property **only** turns on tracing if `@aurelia/debug` is included and configured as well.\n   */\n  enabled: false,\n  liveLoggingEnabled: false,\n  liveWriter: null! as ITraceWriter,\n  /**\n   * Call this at the start of a method/function.\n   * Each call to `enter` **must** have an accompanying call to `leave` for the tracer to work properly.\n   * @param objName Any human-friendly name to identify the traced object with.\n   * @param methodName Any human-friendly name to identify the traced method with.\n   * @param args Pass in `Array.prototype.slice.call(arguments)` to also trace the parameters, or `null` if this is not needed (to save memory/cpu)\n   */\n  enter(objName: string, methodName: string, args: unknown[] | null): void { return; },\n  /**\n   * Call this at the end of a method/function. Pops one trace item off the stack.\n   */\n  leave(): void { return; },\n  /**\n   * Writes only the trace info leading up to the current method call.\n   * @param writer An object to write the output to.\n   */\n  writeStack(writer: ITraceWriter): void { return; },\n  /**\n   * Writes all trace info captured since the previous flushAll operation.\n   * @param writer An object to write the output to. Can be null to simply reset the tracer state.\n   */\n  flushAll(writer: ITraceWriter | null): void { return; },\n  enableLiveLogging,\n  /**\n   * Stops writing out each trace info item as they are traced.\n   */\n  disableLiveLogging(): void { return; }\n};\n\n/**\n * Writes out each trace info item as they are traced.\n * @param writer An object to write the output to.\n */\nfunction enableLiveLogging(writer: ITraceWriter): void;\n/**\n * Writes out each trace info item as they are traced.\n * @param options Optional. Specify which logging categories to output. If omitted, all will be logged.\n */\nfunction enableLiveLogging(options?: ILiveLoggingOptions): void;\n// tslint:disable-next-line:no-redundant-jump\nfunction enableLiveLogging(optionsOrWriter?: ILiveLoggingOptions | ITraceWriter): void { return; }\n","/// <reference types=\"reflect-metadata\" />\nimport { Class, Constructable, IIndexable } from './interfaces';\nimport { PLATFORM } from './platform';\nimport { Reporter, Tracer } from './reporter';\nimport { IResourceType } from './resource';\n\n// tslint:disable: no-any\n\nconst slice = Array.prototype.slice;\n\nexport type ResolveCallback<T = any> = (handler?: IContainer, requestor?: IContainer, resolver?: IResolver) => T;\n\nexport type InterfaceSymbol<K = any> = (target: Injectable<K>, property: string, index: number) => void;\n\nexport interface IDefaultableInterfaceSymbol<K> extends InterfaceSymbol<K> {\n  withDefault(configure: (builder: IResolverBuilder<K>) => IResolver<K>): InterfaceSymbol<K>;\n  noDefault(): InterfaceSymbol<K>;\n}\n\n// This interface exists only to break a circular type referencing issue in the IServiceLocator interface.\n// Otherwise IServiceLocator references IResolver, which references IContainer, which extends IServiceLocator.\ninterface IResolverLike<C, K = any> {\n  resolve(handler: C, requestor: C): Resolved<K>;\n  getFactory?(container: C): (K extends Constructable ? IFactory<K> : never) | null;\n}\n\nexport interface IResolver<K = any> extends IResolverLike<IContainer, K> { }\n\nexport interface IRegistration<K = any> {\n  register(container: IContainer, key?: Key): IResolver<K>;\n}\n\nexport type Transformer<K> = (instance: Resolved<K>) => Resolved<K>;\n\nexport interface IFactory<T extends Constructable = any> {\n  readonly Type: T;\n  registerTransformer(transformer: Transformer<T>): boolean;\n  construct(container: IContainer, dynamicDependencies?: Key[]): Resolved<T>;\n}\n\nexport interface IServiceLocator {\n  has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;\n  get<K extends Key>(key: K | Key): Resolved<K>;\n  getAll<K extends Key>(key: K | Key): readonly Resolved<K>[];\n}\n\nexport interface IRegistry {\n  register(container: IContainer): void;\n}\n\nexport interface IContainer extends IServiceLocator {\n  register(...params: any[]): IContainer;\n  registerResolver<K extends Key>(key: K, resolver: IResolver<K>): IResolver<K>;\n  registerTransformer<K extends Key>(key: K, transformer: Transformer<K>): boolean;\n  getResolver<K extends Key>(key: K | Key, autoRegister?: boolean): IResolver<K> | null;\n  getFactory<T extends Constructable>(key: T): IFactory<T>;\n  createChild(): IContainer;\n}\n\nexport interface IResolverBuilder<K> {\n  instance(value: K): IResolver<K>;\n  singleton(value: Constructable): IResolver<K>;\n  transient(value: Constructable): IResolver<K>;\n  callback(value: ResolveCallback<K>): IResolver<K>;\n  aliasTo(destinationKey: Key): IResolver<K>;\n}\n\nexport type RegisterSelf<T extends Constructable> = {\n  register(container: IContainer): IResolver<InstanceType<T>>;\n};\n\nexport type Key = PropertyKey | object | InterfaceSymbol | Constructable | IResolver;\n\nexport type Resolved<K> = (\n  K extends InterfaceSymbol<infer T>\n    ? T\n    : K extends Constructable\n      ? InstanceType<K>\n      : K extends IResolverLike<infer T1, any>\n        ? T1 extends Constructable\n            ? InstanceType<T1>\n            : T1\n        : K\n);\n\nexport type Injectable<T = {}> = Constructable<T> & { inject?: Key[] };\n\n// Shims to augment the Reflect object with methods used from the Reflect Metadata API proposal:\n// https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\n// https://rbuckton.github.io/reflect-metadata/\n// As the official spec proposal uses \"any\", we use it here as well and suppress related typedef linting warnings.\n// tslint:disable:no-any ban-types\nif (!('getOwnMetadata' in Reflect)) {\n  Reflect.getOwnMetadata = function(metadataKey: any, target: Object): any {\n    return (target as IIndexable<Object>)[metadataKey];\n  };\n\n  Reflect.metadata = function(metadataKey: any, metadataValue: any): (target: Function) => void {\n    return function(target: Function): void {\n      (target as IIndexable<Function>)[metadataKey] = metadataValue;\n    };\n  } as (metadataKey: any, metadataValue: any) => {\n    (target: Function): void;\n    (target: Object, propertyKey: string | symbol): void;\n  };\n}\n\ntype InternalDefaultableInterfaceSymbol<K> = IDefaultableInterfaceSymbol<K> & Partial<IRegistration<K> & {friendlyName: string}>;\n\nconst hasOwnProperty = PLATFORM.hasOwnProperty;\n\nexport class DI {\n  private constructor() {}\n\n  public static createContainer(...params: any[]): IContainer {\n    if (params.length === 0) {\n      return new Container();\n    } else {\n      return new Container().register(...params);\n    }\n  }\n\n  public static getDesignParamTypes(target: Constructable): Key[] {\n    const paramTypes = Reflect.getOwnMetadata('design:paramtypes', target);\n    if (paramTypes == null) {\n      return PLATFORM.emptyArray as typeof PLATFORM.emptyArray & Key[];\n    }\n    return paramTypes;\n  }\n\n  public static getDependencies(Type: Constructable | Injectable): Key[] {\n    let dependencies: Key[];\n\n    if ((Type as Injectable).inject == null) {\n      dependencies = DI.getDesignParamTypes(Type);\n    } else {\n      dependencies = [];\n      let ctor = Type as Injectable;\n\n      while (typeof ctor === 'function') {\n        if (hasOwnProperty.call(ctor, 'inject')) {\n          dependencies.push(...ctor.inject!);\n        }\n\n        ctor = Object.getPrototypeOf(ctor);\n      }\n    }\n\n    return dependencies;\n  }\n\n  public static createInterface<K extends Key>(friendlyName?: string): IDefaultableInterfaceSymbol<K> {\n    const Interface: InternalDefaultableInterfaceSymbol<K> = function(target: Injectable<K>, property: string, index: number): any {\n      if (target == null) {\n        throw Reporter.error(16, Interface.friendlyName, Interface); // TODO: add error (trying to resolve an InterfaceSymbol that has no registrations)\n      }\n      if (target.inject == null) {\n        target.inject = [];\n      }\n      target.inject[index] = Interface;\n      return target;\n    };\n    Interface.friendlyName = friendlyName == null ? 'Interface' : friendlyName;\n\n    Interface.noDefault = function (): InterfaceSymbol<K> {\n      return Interface;\n    };\n\n    Interface.withDefault = function(configure: (builder: IResolverBuilder<K>) => IResolver<K>): InterfaceSymbol<K> {\n      Interface.withDefault = function (): InterfaceSymbol<K> {\n        throw Reporter.error(17, Interface);\n      };\n\n      Interface.register = function(container: IContainer, key?: Key): IResolver<K> {\n        const trueKey = key == null ? Interface : key;\n        return configure({\n          instance(value: K): IResolver<K> {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.instance, value));\n          },\n          singleton(value: Constructable): IResolver<K> {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.singleton, value));\n          },\n          transient(value: Constructable): IResolver<K> {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.transient, value));\n          },\n          callback(value: ResolveCallback<K>): IResolver<K> {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.callback, value));\n          },\n          aliasTo(destinationKey: Key): IResolver<K> {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.alias, destinationKey));\n          },\n        });\n      };\n\n      return Interface;\n    };\n\n    return Interface;\n  }\n\n  public static inject(...dependencies: Key[]): (target: Injectable, key?: string | number, descriptor?: PropertyDescriptor | number) => void {\n    return function(target: Injectable, key?: string | number, descriptor?: PropertyDescriptor | number): void {\n      if (typeof descriptor === 'number') { // It's a parameter decorator.\n        if (!hasOwnProperty.call(target, 'inject')) {\n          const types = DI.getDesignParamTypes(target);\n          target.inject = types.slice() as Constructable[];\n        }\n\n        if (dependencies.length === 1) {\n          // We know for sure that it's not void 0 due to the above check.\n          // tslint:disable-next-line: no-non-null-assertion\n          target.inject![descriptor] = dependencies[0] as Constructable;\n        }\n      } else if (key) { // It's a property decorator. Not supported by the container without plugins.\n        const actualTarget = target.constructor as Injectable;\n        if (actualTarget.inject == null) {\n          actualTarget.inject = [];\n        }\n        actualTarget.inject[key as number] = dependencies[0];\n      } else if (descriptor) { // It's a function decorator (not a Class constructor)\n        const fn = descriptor.value;\n        fn.inject = dependencies;\n      } else { // It's a class decorator.\n        if (dependencies.length === 0) {\n          const types = DI.getDesignParamTypes(target);\n          target.inject = types.slice() as Constructable[];\n        } else {\n          target.inject = dependencies as Constructable[];\n        }\n      }\n    };\n  }\n\n  // tslint:disable:jsdoc-format\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * Example usage:\n```ts\n// On an existing class\nclass Foo { }\nDI.transient(Foo);\n\n// Inline declaration\nconst Foo = DI.transient(class { });\n// Foo is now strongly typed with register\nFoo.register(container);\n```\n   */\n  // tslint:enable:jsdoc-format\n  public static transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.transient(target as T, target as T);\n      return registration.register(container, target);\n    };\n    return target as T & RegisterSelf<T>;\n  }\n\n  // tslint:disable:jsdoc-format\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * Example usage:\n```ts\n// On an existing class\nclass Foo { }\nDI.singleton(Foo);\n\n// Inline declaration\nconst Foo = DI.singleton(class { });\n// Foo is now strongly typed with register\nFoo.register(container);\n```\n   */\n  // tslint:enable:jsdoc-format\n  public static singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.singleton(target, target);\n      return registration.register(container, target);\n    };\n    return target as T & RegisterSelf<T>;\n  }\n}\n\nexport const IContainer = DI.createInterface<IContainer>('IContainer').noDefault();\nexport const IServiceLocator = IContainer as unknown as InterfaceSymbol<IServiceLocator>;\n\nfunction createResolver(getter: (key: any, handler: IContainer, requestor: IContainer) => any): (key: any) => any {\n  return function (key: any): ReturnType<typeof DI.inject> {\n    const resolver: ReturnType<typeof DI.inject> & Partial<Pick<IResolver, 'resolve'>> = function (target: Injectable, property?: string | number, descriptor?: PropertyDescriptor | number): void {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.resolve = function(handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n\nexport const inject = DI.inject;\n\nfunction transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n  return DI.transient(target);\n}\n// tslint:disable:jsdoc-format\n/**\n * Registers the decorated class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * Example usage:\n```ts\n@transient\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function transient<T extends Constructable>(): typeof transientDecorator;\n// tslint:disable:jsdoc-format\n/**\n * Registers the `target` class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @param target The class / constructor function to register as transient.\n *\n * Example usage:\n```ts\n@transient()\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function transient<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> | typeof transientDecorator {\n  return target == null ? transientDecorator : transientDecorator(target);\n}\n\nfunction singletonDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n  return DI.singleton(target);\n}\n// tslint:disable:jsdoc-format\n/**\n * Registers the decorated class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * Example usage:\n```ts\n@singleton\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function singleton<T extends Constructable>(): typeof singletonDecorator;\n// tslint:disable:jsdoc-format\n/**\n * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @param target The class / constructor function to register as a singleton.\n *\n * Example usage:\n```ts\n@singleton()\nclass Foo { }\n```\n */\n// tslint:enable:jsdoc-format\nexport function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function singleton<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> | typeof singletonDecorator {\n  return target == null ? singletonDecorator : singletonDecorator(target);\n}\n\nexport const all = createResolver((key: any, handler: IContainer, requestor: IContainer) => requestor.getAll(key));\n\nexport const lazy = createResolver((key: any, handler: IContainer, requestor: IContainer) =>  {\n  let instance: unknown = null; // cache locally so that lazy always returns the same instance once resolved\n  return () => {\n    if (instance == null) {\n      instance = requestor.get(key);\n    }\n\n    return instance;\n  };\n});\n\nexport const optional = createResolver((key: any, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return null;\n  }\n});\n\n/** @internal */\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5\n}\n\n/** @internal */\nexport class Resolver implements IResolver, IRegistration {\n  public key: Key;\n  public strategy: ResolverStrategy;\n  public state: any;\n  constructor(key: Key, strategy: ResolverStrategy, state: any) {\n    this.key = key;\n    this.strategy = strategy;\n    this.state = state;\n  }\n\n  public register(container: IContainer, key?: Key): IResolver {\n    return container.registerResolver(key || this.key, this);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): any {\n    switch (this.strategy) {\n      case ResolverStrategy.instance:\n        return this.state;\n      case ResolverStrategy.singleton: {\n        this.strategy = ResolverStrategy.instance;\n        const factory = handler.getFactory(this.state as Constructable);\n        return this.state = factory.construct(handler);\n      }\n      case ResolverStrategy.transient: {\n        // Always create transients from the requesting container\n        const factory = handler.getFactory(this.state as Constructable);\n        return factory.construct(requestor);\n      }\n      case ResolverStrategy.callback:\n        return (this.state as ResolveCallback)(handler, requestor, this);\n      case ResolverStrategy.array:\n        return (this.state as IResolver[])[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return handler.get(this.state);\n      default:\n        throw Reporter.error(6, this.strategy);\n    }\n  }\n\n  public getFactory(container: IContainer): IFactory | null {\n    switch (this.strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this.state as Constructable);\n      default:\n        return null;\n    }\n  }\n}\n\n/** @internal */\nexport interface IInvoker<T extends Constructable = any> {\n  invoke(container: IContainer, fn: T, dependencies: Key[]): Resolved<T>;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: T,\n    staticDependencies: Key[],\n    dynamicDependencies: Key[]\n  ): Resolved<T>;\n}\n\n/** @internal */\nexport class Factory<T extends Constructable = any> implements IFactory<T> {\n  public Type: T;\n  private readonly invoker: IInvoker;\n  private readonly dependencies: Key[];\n  private transformers: ((instance: any) => any)[] | null;\n\n  constructor(Type: T, invoker: IInvoker, dependencies: Key[]) {\n    this.Type = Type;\n    this.invoker = invoker;\n    this.dependencies = dependencies;\n    this.transformers = null;\n  }\n\n  public static create<T extends Constructable>(Type: T): IFactory<T> {\n    const dependencies = DI.getDependencies(Type);\n    const invoker = classInvokers.length > dependencies.length ? classInvokers[dependencies.length] : fallbackInvoker;\n    return new Factory<T>(Type, invoker, dependencies);\n  }\n\n  public construct(container: IContainer, dynamicDependencies?: Key[]): Resolved<T> {\n    if (Tracer.enabled) { Tracer.enter('Factory', 'construct', [this.Type, ...slice.call(arguments)]); }\n    const transformers = this.transformers;\n    let instance = dynamicDependencies !== void 0\n      ? this.invoker.invokeWithDynamicDependencies(container, this.Type, this.dependencies, dynamicDependencies)\n      : this.invoker.invoke(container, this.Type, this.dependencies);\n\n    if (transformers == null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return instance;\n    }\n\n    for (let i = 0, ii = transformers.length; i < ii; ++i) {\n      instance = transformers[i](instance);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return instance;\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): boolean {\n    if (this.transformers == null) {\n      this.transformers = [];\n    }\n\n    this.transformers.push(transformer);\n    return true;\n  }\n}\n\n/** @internal */\nexport interface IContainerConfiguration {\n  factories?: Map<Constructable, IFactory>;\n  resourceLookup?: Record<string, IResourceType<any, any>>;\n}\n\nconst containerResolver: IResolver = {\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nfunction isRegistry(obj: IRegistry | Record<string, IRegistry>): obj is IRegistry {\n  return typeof obj.register === 'function';\n}\n\nfunction isClass<T extends { prototype?: any }>(obj: T): obj is Class<any, T> {\n  return obj.prototype !== void 0;\n}\n\n/** @internal */\nexport class Container implements IContainer {\n  private parent: Container | null;\n  private registerDepth: number;\n  private readonly resolvers: Map<Key, IResolver>;\n  private readonly factories: Map<Key, IFactory>;\n  private readonly configuration: IContainerConfiguration;\n  private readonly resourceLookup: Record<string, IResolver>;\n\n  constructor(configuration: IContainerConfiguration = {}) {\n    this.parent = null;\n    this.registerDepth = 0;\n    this.resolvers = new Map<InterfaceSymbol<IContainer>, IResolver>();\n    this.configuration = configuration;\n    if (configuration.factories == null) {\n      configuration.factories = new Map();\n    }\n    this.factories = configuration.factories;\n    this.resourceLookup = configuration.resourceLookup || (configuration.resourceLookup = Object.create(null));\n    this.resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(...params: any[]): IContainer {\n    if (Tracer.enabled) { Tracer.enter('Container', 'register', slice.call(arguments)); }\n    if (++this.registerDepth === 100) {\n      throw new Error('Unable to autoregister dependency');\n      // TODO: change to reporter.error and add various possible causes in description.\n      // Most likely cause is trying to register a plain object that does not have a\n      // register method and is not a class constructor\n    }\n    let current: IRegistry | Record<string, IRegistry>;\n    let keys: string[];\n    let value: IRegistry;\n    let j: number;\n    let jj: number;\n    for (let i = 0, ii = params.length; i < ii; ++i) {\n      current = params[i];\n      if (isRegistry(current)) {\n        current.register(this);\n      } else if (isClass(current)) {\n        Registration.singleton(current, current as Constructable).register(this);\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n    --this.registerDepth;\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this;\n  }\n\n  public registerResolver<K extends Key>(key: K, resolver: IResolver<K>): IResolver<K> {\n    validateKey(key);\n\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n      if (typeof key === 'string') {\n        this.resourceLookup[key] = resolver;\n      }\n    } else if (result instanceof Resolver && result.strategy === ResolverStrategy.array) {\n      (result.state as IResolver[]).push(resolver);\n    } else {\n      resolvers.set(key, new Resolver(key, ResolverStrategy.array, [result, resolver]));\n    }\n\n    return resolver;\n  }\n\n  public registerTransformer<K extends Key>(key: K, transformer: Transformer<K>): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      }\n\n      // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n      return factory.registerTransformer(transformer as unknown as Transformer<Constructable>);\n    }\n\n    return false;\n  }\n\n  public getResolver<K extends Key>(key: K | Key, autoRegister: boolean = true): IResolver<K> | null {\n    validateKey(key);\n\n    if ((key as unknown as IResolver).resolve !== void 0) {\n      return key as unknown as IResolver;\n    }\n\n    let current: Container = this;\n    let resolver: IResolver | undefined;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          return autoRegister ? this.jitRegister(key, current) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  public has<K extends Key>(key: K, searchAncestors: boolean = false): boolean {\n    return this.resolvers.has(key)\n      ? true\n      : searchAncestors && this.parent != null\n      ? this.parent.has(key, true)\n      : false;\n  }\n\n  public get<K extends Key>(key: K): Resolved<K> {\n    if (Tracer.enabled) { Tracer.enter('Container', 'get', slice.call(arguments)); }\n    validateKey(key);\n\n    if ((key as IResolver).resolve !== void 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return (key as IResolver).resolve(this, this);\n    }\n\n    let current: Container = this;\n    let resolver: IResolver | undefined;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          resolver = this.jitRegister(key, current);\n          if (Tracer.enabled) { Tracer.leave(); }\n          return resolver.resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return resolver.resolve(current, this);\n      }\n    }\n\n    throw new Error(`Unable to resolve key: ${key}`);\n  }\n\n  public getAll<K extends Key>(key: K): readonly Resolved<K>[] {\n    if (Tracer.enabled) { Tracer.enter('Container', 'getAll', slice.call(arguments)); }\n    validateKey(key);\n\n    let current: Container | null = this;\n    let resolver: IResolver | undefined;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (this.parent == null) {\n          if (Tracer.enabled) { Tracer.leave(); }\n          return PLATFORM.emptyArray;\n        }\n\n        current = current.parent;\n      } else {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return buildAllResponse(resolver, current, this);\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return PLATFORM.emptyArray;\n  }\n\n  public getFactory<K extends Constructable>(key: K): IFactory<K> {\n    let factory = this.factories.get(key);\n\n    if (factory == null) {\n      factory = Factory.create(key);\n      this.factories.set(key, factory);\n    }\n\n    return factory;\n  }\n\n  public createChild(): IContainer {\n    if (Tracer.enabled) { Tracer.enter('Container', 'createChild', slice.call(arguments)); }\n    const config = this.configuration;\n    const childConfig = { factories: config.factories, resourceLookup: Object.assign(Object.create(null), config.resourceLookup) };\n    const child = new Container(childConfig);\n    child.parent = this;\n    if (Tracer.enabled) { Tracer.leave(); }\n    return child;\n  }\n\n  private jitRegister(keyAsValue: any, handler: Container): IResolver {\n    if (keyAsValue.register !== void 0) {\n      const registrationResolver = keyAsValue.register(handler, keyAsValue);\n      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {\n        const newResolver = handler.resolvers.get(keyAsValue);\n        if (newResolver != void 0) {\n          return newResolver;\n        }\n        throw Reporter.error(40); // did not return a valid resolver from the static register method\n      }\n      return registrationResolver;\n    }\n\n    const resolver = new Resolver(keyAsValue, ResolverStrategy.singleton, keyAsValue);\n    handler.resolvers.set(keyAsValue, resolver);\n    return resolver;\n  }\n}\n\nexport class Registration {\n  private constructor() {}\n\n  public static instance<T>(key: Key, value: T): IRegistration<T> {\n    return new Resolver(key, ResolverStrategy.instance, value);\n  }\n\n  public static singleton<T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> {\n    return new Resolver(key, ResolverStrategy.singleton, value);\n  }\n\n  public static transient<T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> {\n    return new Resolver(key, ResolverStrategy.transient, value);\n  }\n\n  public static callback<T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> {\n    return new Resolver(key, ResolverStrategy.callback, callback);\n  }\n\n  public static alias<T>(originalKey: T, aliasKey: Key): IRegistration<Resolved<T>> {\n    return new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n  }\n}\n\nexport class InstanceProvider<K extends Key> implements IResolver<K | null> {\n  private instance: Resolved<K> | null;\n\n  constructor() {\n    this.instance = null;\n  }\n\n  public prepare(instance: Resolved<K>): void {\n    this.instance = instance;\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): Resolved<K> | null {\n    if (this.instance === undefined) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    return this.instance;\n  }\n\n  public dispose(): void {\n    this.instance = null;\n  }\n}\n\n/** @internal */\nexport function validateKey(key: any): void {\n  // note: design:paramTypes which will default to Object if the param types cannot be statically analyzed by tsc\n  // this check is intended to properly report on that problem - under no circumstance should Object be a valid key anyway\n  if (key == null || key === Object) {\n    throw Reporter.error(5);\n  }\n}\n\nfunction buildAllResponse(resolver: IResolver, handler: IContainer, requestor: IContainer): any[] {\n  if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n    const state = resolver.state as IResolver[];\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\n/** @internal */\nexport const classInvokers: IInvoker[] = [\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>): T {\n      return new Type();\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>, deps: Key[]): T {\n      return new Type(container.get(deps[0]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>, deps: Key[]): T {\n      return new Type(container.get(deps[0]), container.get(deps[1]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>, deps: Key[]): T {\n      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>, deps: Key[]): T {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3])\n      );\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T>(container: IContainer, Type: Constructable<T>, deps: Key[]): T {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3]),\n        container.get(deps[4])\n      );\n    },\n    invokeWithDynamicDependencies\n  }\n];\n\n/** @internal */\nexport const fallbackInvoker: IInvoker = {\n  invoke: invokeWithDynamicDependencies as (container: IContainer, fn: Constructable, dependencies: Key[]) => Constructable,\n  invokeWithDynamicDependencies\n};\n\n/** @internal */\nexport function invokeWithDynamicDependencies<T>(\n  container: IContainer,\n  Type: Constructable<T>,\n  staticDependencies: Key[],\n  dynamicDependencies: Key[]\n): T {\n  let i = staticDependencies.length;\n  let args: Key[] = new Array(i);\n  let lookup: Key;\n\n  while (i--) {\n    lookup = staticDependencies[i];\n\n    if (lookup == null) {\n      throw Reporter.error(7, `Index ${i}.`);\n    } else {\n      args[i] = container.get(lookup);\n    }\n  }\n\n  if (dynamicDependencies !== void 0) {\n    args = args.concat(dynamicDependencies);\n  }\n\n  return Reflect.construct(Type, args);\n}\n","function trimDots(ary: string[]): void {\n  const len = ary.length;\n  let i = 0;\n  let part: string;\n  for (; i < len; ++i) {\n    part = ary[i];\n    if (part === '.') {\n      ary.splice(i, 1);\n      i -= 1;\n    } else if (part === '..') {\n      // If at the start, or previous value is still ..,\n      // keep them so that when converted to a path it may\n      // still work when converted to a path, even though\n      // as an ID it is less than ideal. In larger point\n      // releases, may be better to just kick out an error.\n      if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {\n        continue;\n      }\n      if (i > 0) {\n        ary.splice(i - 1, 2);\n        i -= 2;\n      }\n    }\n  }\n}\n\n/**\n * Calculates a path relative to a file.\n *\n * @param name The relative path.\n * @param file The file path.\n * @return The calculated path.\n */\nexport function relativeToFile(name: string, file: string): string {\n  const fileParts = !file ? file : file.split('/');\n  const nameParts = name.trim().split('/');\n\n  if (nameParts[0].charAt(0) === '.' && fileParts) {\n    //Convert file to array, and lop off the last part,\n    //so that . matches that 'directory' and not name of the file's\n    //module. For instance, file of 'one/two/three', maps to\n    //'one/two/three.js', but we want the directory, 'one/two' for\n    //this normalization.\n    const normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);\n    nameParts.unshift(...normalizedBaseParts);\n  }\n\n  trimDots(nameParts);\n\n  return nameParts.join('/');\n}\n\n/**\n * Joins two paths.\n *\n * @param path1 The first path.\n * @param path2 The second path.\n * @return The joined path.\n */\nexport function join(path1: string, path2: string): string {\n  if (!path1) {\n    return path2;\n  }\n  if (!path2) {\n    return path1;\n  }\n  const schemeMatch = path1.match(/^([^/]*?:)\\//);\n  const scheme = (schemeMatch && schemeMatch.length > 0) ? schemeMatch[1] : '';\n  path1 = path1.slice(scheme.length);\n\n  let urlPrefix: string;\n  if (path1.indexOf('///') === 0 && scheme === 'file:') {\n    urlPrefix = '///';\n  } else if (path1.indexOf('//') === 0) {\n    urlPrefix = '//';\n  } else if (path1.indexOf('/') === 0) {\n    urlPrefix = '/';\n  } else {\n    urlPrefix = '';\n  }\n\n  const trailingSlash = path2.slice(-1) === '/' ? '/' : '';\n\n  const url1 = path1.split('/');\n  const url2 = path2.split('/');\n  const url3 = [];\n\n  for (let i = 0, ii = url1.length; i < ii; ++i) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] !== '.' && url1[i] !== '') {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, ii = url2.length; i < ii; ++i) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] !== '.' && url2[i] !== '') {\n      url3.push(url2[i]);\n    }\n  }\n\n  return scheme + urlPrefix + url3.join('/') + trailingSlash;\n}\n\nconst encode = encodeURIComponent;\nconst encodeKey = (k: string) => encode(k).replace('%24', '$');\n\n// these types are reverse-engineered from aurelia-path.. don't shoot the messenger..\ntype Scalar = null | undefined | boolean | number | string;\nexport interface IQueryParams {\n  [key: string]: Scalar | this | (string | string[] | this)[];\n}\ntype ComplexQueryParams = Scalar | IQueryParams | (string | string[] | IQueryParams)[];\ntype SimpleQueryParams = string | IQueryParams | (string | IQueryParams)[];\n\n/**\n * Recursively builds part of query string for parameter.\n *\n * @param key Parameter name for query string.\n * @param value Parameter value to deserialize.\n * @param traditional Boolean Use the old URI template standard (RFC6570)\n * @return Array with serialized parameter(s)\n */\nfunction buildParam(key: string, value: ComplexQueryParams, traditional?: boolean): string[] {\n  let result: string[] = [];\n  if (value == null) {\n    return result;\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0, l = value.length; i < l; i++) {\n      if (traditional) {\n        result.push(`${encodeKey(key)}=${encode(value[i] as string)}`);\n      } else {\n        const arrayKey = `${key}[${(typeof value[i] === 'object' && value[i] != null ? i : '')}]`;\n        result = result.concat(buildParam(arrayKey, value[i]));\n      }\n    }\n  } else if (typeof value === 'object' && !traditional) {\n    for (const propertyName in value) {\n      result = result.concat(buildParam(`${key}[${propertyName}]`, value[propertyName]));\n    }\n  } else {\n    result.push(`${encodeKey(key)}=${encode(value as string)}`);\n  }\n  return result;\n}\n\n/**\n * Generate a query string from an object.\n *\n * @param params Object containing the keys and values to be used.\n * @param traditional Boolean Use the old URI template standard (RFC6570)\n * @returns The generated query string, excluding leading '?'.\n */\nexport function buildQueryString(params?: IQueryParams, traditional?: boolean): string {\n  if (params == null) {\n    return '';\n  }\n  const pairs: string[] = [];\n  const keys = Object.keys(params).sort();\n  let key: string;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    pairs.push(...buildParam(key, params[key], traditional));\n  }\n\n  if (pairs.length === 0) {\n    return '';\n  }\n\n  return pairs.join('&');\n}\n\n/**\n * Process parameter that was recognized as scalar param (primitive value or shallow array).\n *\n * @param existedParam Object with previously parsed values for specified key.\n * @param value Parameter value to append.\n * @returns Initial primitive value or transformed existedParam if parameter was recognized as an array.\n */\nfunction processScalarParam(existedParam: SimpleQueryParams, value: string | IQueryParams): SimpleQueryParams {\n  if (Array.isArray(existedParam)) {\n    // value is already an array, so push on the next value.\n    existedParam.push(value);\n    return existedParam;\n  }\n  if (existedParam !== undefined) {\n    // value isn't an array, but since a second value has been specified,\n    // convert value into an array.\n    return [existedParam, value];\n  }\n  // value is a scalar.\n  return value;\n}\n/**\n * Sequentially process parameter that was recognized as complex value (object or array).\n * For each keys part, if the current level is undefined create an\n *   object or array based on the type of the next keys part.\n *\n * @param queryParams root-level result object.\n * @param keys Collection of keys related to this parameter.\n * @param value Parameter value to append.\n */\nfunction parseComplexParam(queryParams: IQueryParams, keys: (string | number)[], value: string): void {\n  let currentParams = queryParams as IQueryParams & (string | IQueryParams)[];\n  const keysLastIndex = keys.length - 1;\n  let key: number;\n  let prevValue: SimpleQueryParams;\n  for (let j = 0; j <= keysLastIndex; ++j) {\n    key = (keys[j] === '' ? currentParams.length : keys[j]) as number;\n    if (j < keysLastIndex) {\n      // The value has to be an array or a false value\n      // It can happen that the value is no array if the key was repeated with traditional style like `list=1&list[]=2`\n      if (!currentParams[key] || typeof currentParams[key] === 'object') {\n        prevValue = currentParams[key];\n      } else {\n        prevValue = [currentParams[key]];\n      }\n      if (prevValue) {\n        currentParams = currentParams[key] = prevValue as typeof currentParams;\n      } else if (isNaN(keys[j + 1] as number)) {\n        // Kinda have no choice here\n        // tslint:disable-next-line: no-object-literal-type-assertion\n        currentParams = currentParams[key] = {} as typeof currentParams;\n      } else {\n        currentParams = currentParams[key] = [] as [] & typeof currentParams;\n      }\n    } else {\n      currentParams = currentParams[key] = value as string & typeof currentParams;\n    }\n  }\n}\n\n/**\n * Parse a query string into a queryParams object.\n *\n * @param queryString The query string to parse.\n * @returns Object with keys and values mapped from the query string.\n */\nexport function parseQueryString(queryString: string): IQueryParams {\n  const queryParams: IQueryParams = {};\n  if (!queryString || typeof queryString !== 'string') {\n    return queryParams;\n  }\n\n  let query = queryString;\n  if (query.charAt(0) === '?') {\n    query = query.slice(1);\n  }\n\n  const pairs = query.replace(/\\+/g, ' ').split('&');\n  for (let i = 0; i < pairs.length; i++) {\n    const pair = pairs[i].split('=');\n    const key = decodeURIComponent(pair[0]);\n    if (!key) {\n      continue;\n    }\n    //split object key into its parts\n    let keys = key.split('][');\n    let keysLastIndex = keys.length - 1;\n\n    // If the first keys part contains [ and the last ends with ], then []\n    // are correctly balanced, split key to parts\n    //Else it's basic key\n    if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keysLastIndex])) {\n      keys[keysLastIndex] = keys[keysLastIndex].replace(/\\]$/, '');\n      // tslint:disable-next-line: no-non-null-assertion // outer condition already ensures not-null\n      keys = keys.shift()!.split('[').concat(keys);\n      keysLastIndex = keys.length - 1;\n    } else {\n      keysLastIndex = 0;\n    }\n\n    if (pair.length >= 2) {\n      const value = pair[1] ? decodeURIComponent(pair[1]) : '';\n      if (keysLastIndex) {\n        parseComplexParam(queryParams, keys, value);\n      } else {\n        queryParams[key] = processScalarParam(queryParams[key] as SimpleQueryParams, value);\n      }\n    } else {\n      queryParams[key] = true;\n    }\n  }\n  return queryParams;\n}\n","import { PLATFORM } from './platform';\n\nexport interface ITimer {\n  enter(): void;\n  leave(): void;\n}\n\nexport interface IProfile {\n  name: string;\n  duration: number;\n  topLevelCount: number;\n  totalCount: number;\n}\n\nexport const Profiler = (function (): {\n  createTimer: typeof createTimer;\n  enable: typeof enable;\n  disable: typeof disable;\n  report: typeof report;\n  readonly enabled: boolean;\n} {\n  const now = PLATFORM.now;\n  const timers: string[] = [];\n  let profileMap: Record<string, IProfile>;\n\n  const profiler = {\n    createTimer,\n    enable,\n    disable,\n    report,\n    enabled: false\n  };\n  return profiler;\n\n  function createTimer(name: string): ITimer {\n    timers.push(name);\n    let depth = 0;\n    let mark = 0;\n\n    return {\n      enter,\n      leave\n    };\n\n    function enter(): void {\n      if (++depth === 1) {\n        mark = now();\n        ++profileMap[name].topLevelCount;\n      }\n      ++profileMap[name].totalCount;\n    }\n    function leave(): void {\n      if (--depth === 0) {\n        profileMap[name].duration += (now() - mark);\n      }\n    }\n  }\n\n  function enable(): void {\n    profileMap = {};\n    for (const timer of timers) {\n      profileMap[timer] = {\n        name: timer,\n        duration: 0,\n        topLevelCount: 0,\n        totalCount: 0\n      };\n    }\n    profiler.enabled = true;\n  }\n\n  function disable(): void {\n    profiler.enabled = false;\n  }\n\n  function report(cb: (name: string, duration: number, topLevelCount: number, totalCount: number) => void): void {\n    Object.keys(profileMap).map(key => profileMap[key]).sort((a, b) => b.duration - a.duration).forEach(p => {\n      cb(p.name, p.duration, p.topLevelCount, p.totalCount);\n    });\n  }\n})();\n","import { IContainer, IRegistry, IResolver } from './di';\nimport { Constructable, ConstructableClass } from './interfaces';\n\nexport interface IResourceDefinition extends Object {\n  name: string;\n}\n\nexport interface IResourceKind<TDef, TProto, TClass extends ConstructableClass<TProto, unknown> = ConstructableClass<TProto>> {\n  readonly name: string;\n  keyFrom(name: string): string;\n  isType<T>(Type: T & Partial<IResourceType<TDef, TProto>>): Type is T & TClass & IResourceType<TDef, TProto>;\n\n  define<T extends Constructable>(name: string, ctor?: T): T & TClass & IResourceType<TDef, TProto>;\n  define<T extends Constructable>(definition: TDef, ctor?: T): T & TClass & IResourceType<TDef, TProto>;\n  define<T extends Constructable>(nameOrDefinition: string | TDef, ctor?: T): T & TClass & IResourceType<TDef, TProto>;\n}\n\nexport type ResourceDescription<TDef> = Required<TDef>;\n\nexport type ResourcePartDescription<TDef> = TDef;\n\nexport interface IResourceType<TDef, TProto, TClass extends ConstructableClass<TProto, unknown> = ConstructableClass<TProto>> extends ConstructableClass<TProto, unknown>, IRegistry {\n  readonly kind: IResourceKind<TDef, TProto, TClass>;\n  readonly description: ResourceDescription<TDef>;\n}\n\nexport interface IResourceDescriptions {\n  find<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): ResourceDescription<TDef> | null;\n  create<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): TProto | null;\n}\n\nexport class RuntimeCompilationResources implements IResourceDescriptions {\n  private readonly context: IContainer;\n\n  constructor(context: IContainer) {\n    this.context = context;\n  }\n\n  public find<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): ResourceDescription<TDef> | null {\n    const key = kind.keyFrom(name);\n    const resourceLookup = (this.context as unknown as { resourceLookup: Record<string, IResolver | undefined | null> }).resourceLookup;\n    let resolver = resourceLookup[key];\n    if (resolver === void 0) {\n      resolver = resourceLookup[key] = this.context.getResolver(key, false);\n    }\n\n    if (resolver != null && resolver.getFactory) {\n      const factory = resolver.getFactory(this.context);\n\n      if (factory != null) {\n        const description = (factory.Type as IResourceType<TDef, TProto>).description;\n        return description === undefined ? null : description;\n      }\n    }\n\n    return null;\n  }\n\n  public create<TDef, TProto>(kind: IResourceKind<TDef, TProto>, name: string): TProto | null {\n    const key = kind.keyFrom(name);\n    const resourceLookup = (this.context as unknown as { resourceLookup: Record<string, IResolver | undefined | null> }).resourceLookup;\n    let resolver = resourceLookup[key];\n    if (resolver === undefined) {\n      resolver = resourceLookup[key] = this.context.getResolver(key, false);\n    }\n    if (resolver != null) {\n      const instance = resolver.resolve(this.context, this.context);\n      return instance === undefined ? null : instance;\n    }\n    return null;\n  }\n}\n","import { IContainer, IResolver, Registration, DI } from './di';\nimport { Constructable, IDisposable } from './interfaces';\nimport { Reporter } from './reporter';\n\n/**\n * Represents a handler for an EventAggregator event.\n */\nclass Handler {\n  /** @internal */\n  public readonly messageType: Constructable;\n  /** @internal */\n  public readonly callback: EventAggregatorCallback;\n\n  constructor(messageType: Constructable, callback: EventAggregatorCallback) {\n    this.messageType = messageType;\n    this.callback = callback;\n  }\n\n  public handle(message: InstanceType<Constructable>): void {\n    if (message instanceof this.messageType) {\n      this.callback.call(null, message);\n    }\n  }\n}\n\nfunction invokeCallback(callback: EventAggregatorCallback, data: unknown, event: string): void {\n  try {\n    callback(data, event);\n  } catch (e) {\n    Reporter.error(0, e); // TODO: create error code\n  }\n}\n\nfunction invokeHandler(handler: Handler, data: InstanceType<Constructable>): void {\n  try {\n    handler.handle(data);\n  } catch (e) {\n    Reporter.error(0, e); // TODO: create error code\n  }\n}\n\n// TODO: move this to a v1-compat package\nexport interface Subscription extends IDisposable {}\n\n/**\n * Enables loosely coupled publish/subscribe messaging.\n * @param data The optional data published on the channel.\n * @param event The event that triggered the callback. Only available on channel based messaging.\n */\nexport type EventAggregatorCallback<T = any> = (data?: T, event?: string) => any;\n\nexport const IEventAggregator = DI.createInterface<IEventAggregator>('IEventAggregator').withDefault(x => x.singleton(EventAggregator));\nexport interface IEventAggregator {\n  publish(channel: string, data?: unknown): void;\n  subscribe<T>(channel: string, callback: EventAggregatorCallback<T>): IDisposable;\n}\n\n/**\n * Enables loosely coupled publish/subscribe messaging.\n */\nexport class EventAggregator {\n  /** @internal */\n  public readonly eventLookup: Record<string, EventAggregatorCallback[]>;\n  /** @internal */\n  public readonly messageHandlers: Handler[];\n\n  /**\n   * Creates an instance of the EventAggregator class.\n   */\n  constructor() {\n    this.eventLookup = {};\n    this.messageHandlers = [];\n  }\n\n  /**\n   * Publishes a message.\n   * @param channel The channel to publish to.\n   * @param data The data to publish on the channel.\n   */\n  public publish(channel: string, data?: unknown): void;\n  /**\n   * Publishes a message.\n   * @param instance The instance to publish to.\n   */\n  public publish(instance: InstanceType<Constructable>): void;\n  public publish(channelOrInstance: string | InstanceType<Constructable>, data?: unknown): void {\n    let subscribers: (EventAggregatorCallback | Handler)[];\n    let i: number;\n\n    if (!channelOrInstance) {\n      throw Reporter.error(0); // TODO: create error code for 'Event was invalid.'\n    }\n\n    if (typeof channelOrInstance === 'string') {\n      const channel: string = channelOrInstance;\n      subscribers = this.eventLookup[channel];\n      if (subscribers != null) {\n        subscribers = subscribers.slice();\n        i = subscribers.length;\n\n        while (i--) {\n          invokeCallback(subscribers[i] as EventAggregatorCallback, data, channel);\n        }\n      }\n    } else {\n      const instance: InstanceType<Constructable> = channelOrInstance;\n      subscribers = this.messageHandlers.slice();\n      i = subscribers.length;\n\n      while (i--) {\n        invokeHandler(subscribers[i] as Handler, instance);\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a message channel.\n   * @param channel The event channel.\n   * @param callback The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T>(channel: string, callback: EventAggregatorCallback<T>): IDisposable;\n  /**\n   * Subscribes to a message type.\n   * @param type The event data type.\n   * @param callback The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T extends Constructable>(type: T, callback: EventAggregatorCallback<InstanceType<T>>): IDisposable;\n  public subscribe<T extends Constructable | string>(channelOrType: T, callback: EventAggregatorCallback<T extends Constructable ? InstanceType<T> : T>): IDisposable;\n  public subscribe<T extends Constructable | string>(channelOrType: T, callback: EventAggregatorCallback<T extends Constructable ? InstanceType<T> : T>): IDisposable {\n    let handler: (typeof callback) | Handler;\n    let subscribers: ((typeof callback) | Handler)[];\n\n    if (!channelOrType) {\n      throw Reporter.error(0); // TODO: create error code for 'Event channel/type was invalid.'\n    }\n\n    if (typeof channelOrType === 'string') {\n      const channel: string = channelOrType;\n      handler = callback;\n      if (this.eventLookup[channel] === void 0) {\n        this.eventLookup[channel] = [];\n      }\n      subscribers = this.eventLookup[channel];\n    } else {\n      handler = new Handler(channelOrType as Constructable, callback);\n      subscribers = this.messageHandlers;\n    }\n\n    subscribers.push(handler);\n\n    return {\n      dispose(): void {\n        const idx = subscribers.indexOf(handler);\n        if (idx !== -1) {\n          subscribers.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a message channel, then disposes the subscription automatically after the first message is received.\n   * @param channel The event channel.\n   * @param callback The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T>(channel: string, callback: EventAggregatorCallback<T>): IDisposable;\n  /**\n   * Subscribes to a message type, then disposes the subscription automatically after the first message is received.\n   * @param type The event data type.\n   * @param callback The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T extends Constructable>(type: T, callback: EventAggregatorCallback<InstanceType<T>>): IDisposable;\n  public subscribeOnce<T extends Constructable | string>(channelOrType: T, callback: EventAggregatorCallback<T>): IDisposable;\n  public subscribeOnce<T extends Constructable | string>(channelOrType: T, callback: EventAggregatorCallback<T>): IDisposable {\n    const sub = this.subscribe(channelOrType, (data?: T, event?: string) => {\n      sub.dispose();\n      return callback(data, event);\n    });\n\n    return sub;\n  }\n}\n","const camelCaseLookup: Record<string, string> = {};\nconst kebabCaseLookup: Record<string, string> = {};\nconst isNumericLookup: Record<string, boolean> = {};\n\n/**\n * Efficiently determine whether the provided property key is numeric\n * (and thus could be an array indexer) or not.\n *\n * Always returns true for values of type `'number'`.\n *\n * Otherwise, only returns true for strings that consist only of positive integers.\n *\n * Results are cached.\n */\nexport function isNumeric(value: unknown): value is number | string {\n  switch (typeof value) {\n    case 'number':\n      return true;\n    case 'string': {\n      const result = isNumericLookup[value];\n      if (result !== void 0) {\n        return result;\n      }\n      const { length } = value;\n      if (length === 0) {\n        return isNumericLookup[value] = false;\n      }\n      let ch = 0;\n      for (let i = 0; i < length; ++i) {\n        ch = value.charCodeAt(i);\n        if (ch < 0x30 /*0*/ || ch > 0x39/*9*/) {\n          return isNumericLookup[value] = false;\n        }\n      }\n      return isNumericLookup[value] = true;\n    }\n    default:\n      return false;\n  }\n}\n\n/**\n * Efficiently convert a kebab-cased string to camelCase.\n *\n * Separators that signal the next character to be capitalized, are: `-`, `.`, `_`.\n *\n * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.\n *\n * Results are cached.\n */\nexport function camelCase(input: string): string {\n  // benchmark: http://jsben.ch/qIz4Z\n  let value = camelCaseLookup[input];\n  if (value !== void 0) return value;\n  value = '';\n  let first = true;\n  let sep = false;\n  let char: string;\n  for (let i = 0, ii = input.length; i < ii; ++i) {\n    char = input.charAt(i);\n    if (char === '-' || char === '.' || char === '_') {\n      sep = true; // skip separators\n    } else {\n      value = value + (first ? char.toLowerCase() : (sep ? char.toUpperCase() : char));\n      sep = false;\n    }\n    first = false;\n  }\n  return camelCaseLookup[input] = value;\n}\n\n/**\n * Efficiently convert a camelCased string to kebab-case.\n *\n * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.\n *\n * Results are cached.\n */\nexport function kebabCase(input: string): string {\n  // benchmark: http://jsben.ch/v7K9T\n  let value = kebabCaseLookup[input];\n  if (value !== void 0) return value;\n  value = '';\n  let first = true;\n  let char: string, lower: string;\n  for (let i = 0, ii = input.length; i < ii; ++i) {\n    char = input.charAt(i);\n    lower = char.toLowerCase();\n    value = value + (first ? lower : (char !== lower ? `-${lower}` : lower));\n    first = false;\n  }\n  return kebabCaseLookup[input] = value;\n}\n\n/**\n * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.\n *\n * Primarily used by Aurelia to convert DOM node lists to arrays.\n */\nexport function toArray<T = unknown>(input: ArrayLike<T>): T[] {\n  // benchmark: http://jsben.ch/xjsyF\n  const { length } = input;\n  const arr = Array(length);\n  for (let i = 0; i < length; ++i) {\n      arr[i] = input[i];\n  }\n  return arr;\n}\n\nconst ids: Record<string, number> = {};\n\n/**\n * Retrieve the next ID in a sequence for a given string, starting with `1`.\n *\n * Used by Aurelia to assign unique ID's to controllers and resources.\n *\n * Aurelia will always prepend the context name with `au$`, so as long as you avoid\n * using that convention you should be safe from collisions.\n */\nexport function nextId(context: string): number {\n  if (ids[context] === void 0) {\n    ids[context] = 0;\n  }\n  return ++ids[context];\n}\n\n/**\n * Reset the ID for the given string, so that `nextId` will return `1` again for the next call.\n *\n * Used by Aurelia to reset ID's in between unit tests.\n */\nexport function resetId(context: string): void {\n  ids[context] = 0;\n}\n\n/**\n * A compare function to pass to `Array.prototype.sort` for sorting numbers.\n * This is needed for numeric sort, since the default sorts them as strings.\n */\nexport function compareNumber(a: number, b: number): number {\n  return a - b;\n}\n"],"names":["hasOwnProperty"],"mappings":"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"}