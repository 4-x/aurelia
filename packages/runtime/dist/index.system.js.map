{"version":3,"file":"index.system.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/observation/subscriber-collection.ts","../src/observation/proxy-observer.ts","../src/observation/setter-observer.ts","../src/observation/binding-context.ts","../src/observation/signaler.ts","../src/resources/binding-behavior.ts","../src/resources/value-converter.ts","../src/binding/ast.ts","../src/flags.ts","../src/lifecycle.ts","../src/binding/connectable.ts","../src/binding/binding.ts","../src/binding/call.ts","../src/binding/expression-parser.ts","../src/binding/interpolation-binding.ts","../src/binding/let-binding.ts","../src/binding/ref.ts","../src/observation.ts","../src/observation/collection-length-observer.ts","../src/observation/array-observer.ts","../src/observation/collection-size-observer.ts","../src/observation/map-observer.ts","../src/observation/set-observer.ts","../src/observation/computed-observer.ts","../src/observation/dirty-checker.ts","../src/observation/primitive-observer.ts","../src/observation/property-accessor.ts","../src/observation/observer-locator.ts","../src/observation/self-observer.ts","../src/resources/binding-behaviors/binding-mode.ts","../src/resources/binding-behaviors/debounce.ts","../src/resources/binding-behaviors/priority.ts","../src/resources/binding-behaviors/signals.ts","../src/resources/binding-behaviors/throttle.ts","../src/templating/bindable.ts","../src/definitions.ts","../src/resources/custom-attribute.ts","../src/dom.ts","../src/lifecycle-task.ts","../src/resources/custom-attributes/if.ts","../src/resources/custom-attributes/repeat.ts","../src/resources/custom-attributes/replaceable.ts","../src/resources/custom-attributes/with.ts","../src/resources/custom-element.ts","../src/resources/value-converters/sanitize.ts","../src/templating/view.ts","../src/rendering-engine.ts","../src/templating/controller.ts","../src/activator.ts","../src/aurelia.ts","../src/renderer.ts","../src/configuration.ts","../src/instructions.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { LifecycleFlags as LF } from '../flags';\nimport {\n  ICollectionSubscriber,\n  ICollectionSubscriberCollection,\n  IndexMap,\n  IProxySubscriber,\n  IProxySubscriberCollection,\n  ISubscriber,\n  ISubscriberCollection,\n  SubscriberFlags as SF\n} from '../observation';\n\n// TODO: see if we can de-duplicate these 3 decorators and their functions without killing performance or readability\n\nexport function subscriberCollection(): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    const proto = target.prototype as ISubscriberCollection;\n\n    proto._subscriberFlags = SF.None;\n\n    proto.addSubscriber = addSubscriber;\n    proto.removeSubscriber = removeSubscriber;\n    proto.hasSubscriber = hasSubscriber;\n    proto.hasSubscribers = hasSubscribers;\n    proto.callSubscribers = callSubscribers;\n\n    if (proto.subscribe === void 0) proto.subscribe = addSubscriber;\n    if (proto.unsubscribe === void 0) proto.unsubscribe = removeSubscriber;\n  };\n}\n\nexport function proxySubscriberCollection(): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    const proto = target.prototype as IProxySubscriberCollection;\n\n    proto._proxySubscriberFlags = SF.None;\n\n    proto.addProxySubscriber = addProxySubscriber;\n    proto.removeProxySubscriber = removeProxySubscriber;\n    proto.hasProxySubscriber = hasProxySubscriber;\n    proto.hasProxySubscribers = hasProxySubscribers;\n    proto.callProxySubscribers = callProxySubscribers;\n\n    if (proto.subscribeToProxy === void 0) proto.subscribeToProxy = addProxySubscriber;\n    if (proto.unsubscribeFromProxy === void 0) proto.unsubscribeFromProxy = removeProxySubscriber;\n  };\n}\n\nexport function collectionSubscriberCollection(): ClassDecorator {\n  // tslint:disable-next-line:ban-types // ClassDecorator expects it to be derived from Function\n  return function(target: Function): void {\n    const proto = target.prototype as ICollectionSubscriberCollection;\n\n    proto._collectionSubscriberFlags = SF.None;\n\n    proto.addCollectionSubscriber = addCollectionSubscriber;\n    proto.removeCollectionSubscriber = removeCollectionSubscriber;\n    proto.hasCollectionSubscriber = hasCollectionSubscriber;\n    proto.hasCollectionSubscribers = hasCollectionSubscribers;\n    proto.callCollectionSubscribers = callCollectionSubscribers;\n\n    if (proto.subscribeToCollection === void 0) proto.subscribeToCollection = addCollectionSubscriber;\n    if (proto.unsubscribeFromCollection === void 0) proto.unsubscribeFromCollection = removeCollectionSubscriber;\n  };\n}\n\nfunction addSubscriber(this: ISubscriberCollection, subscriber: ISubscriber): boolean {\n  if (this.hasSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) === 0) {\n    this._subscriber0 = subscriber;\n    this._subscriberFlags |= SF.Subscriber0;\n  } else if ((subscriberFlags & SF.Subscriber1) === 0) {\n    this._subscriber1 = subscriber;\n    this._subscriberFlags |= SF.Subscriber1;\n  } else if ((subscriberFlags & SF.Subscriber2) === 0) {\n    this._subscriber2 = subscriber;\n    this._subscriberFlags |= SF.Subscriber2;\n  } else if ((subscriberFlags & SF.SubscribersRest) === 0) {\n    this._subscribersRest = [subscriber];\n    this._subscriberFlags |= SF.SubscribersRest;\n  } else {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0\n    this._subscribersRest!.push(subscriber);\n  }\n  return true;\n}\n\nfunction addProxySubscriber(this: IProxySubscriberCollection, subscriber: IProxySubscriber): boolean {\n  if (this.hasProxySubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._proxySubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) === 0) {\n    this._proxySubscriber0 = subscriber;\n    this._proxySubscriberFlags |= SF.Subscriber0;\n  } else if ((subscriberFlags & SF.Subscriber1) === 0) {\n    this._proxySubscriber1 = subscriber;\n    this._proxySubscriberFlags |= SF.Subscriber1;\n  } else if ((subscriberFlags & SF.Subscriber2) === 0) {\n    this._proxySubscriber2 = subscriber;\n    this._proxySubscriberFlags |= SF.Subscriber2;\n  } else if ((subscriberFlags & SF.SubscribersRest) === 0) {\n    this._proxySubscribersRest = [subscriber];\n    this._proxySubscriberFlags |= SF.SubscribersRest;\n  } else {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0\n    this._proxySubscribersRest!.push(subscriber);\n  }\n  return true;\n}\n\nfunction addCollectionSubscriber(this: ICollectionSubscriberCollection, subscriber: ICollectionSubscriber): boolean {\n  if (this.hasCollectionSubscriber(subscriber)) {\n    return false;\n  }\n  const subscriberFlags = this._collectionSubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) === 0) {\n    this._collectionSubscriber0 = subscriber;\n    this._collectionSubscriberFlags |= SF.Subscriber0;\n  } else if ((subscriberFlags & SF.Subscriber1) === 0) {\n    this._collectionSubscriber1 = subscriber;\n    this._collectionSubscriberFlags |= SF.Subscriber1;\n  } else if ((subscriberFlags & SF.Subscriber2) === 0) {\n    this._collectionSubscriber2 = subscriber;\n    this._collectionSubscriberFlags |= SF.Subscriber2;\n  } else if ((subscriberFlags & SF.SubscribersRest) === 0) {\n    this._collectionSubscribersRest = [subscriber];\n    this._collectionSubscriberFlags |= SF.SubscribersRest;\n  } else {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0\n    this._collectionSubscribersRest!.push(subscriber);\n  }\n  return true;\n}\n\nfunction removeSubscriber(this: ISubscriberCollection, subscriber: ISubscriber): boolean {\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._subscriber0 === subscriber) {\n    this._subscriber0 = void 0;\n    this._subscriberFlags = (this._subscriberFlags | SF.Subscriber0) ^ SF.Subscriber0;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber1) > 0 && this._subscriber1 === subscriber) {\n    this._subscriber1 = void 0;\n    this._subscriberFlags = (this._subscriberFlags | SF.Subscriber1) ^ SF.Subscriber1;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber2) > 0 && this._subscriber2 === subscriber) {\n    this._subscriber2 = void 0;\n    this._subscriberFlags = (this._subscriberFlags | SF.Subscriber2) ^ SF.Subscriber2;\n    return true;\n  } else if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._subscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._subscriberFlags = (this._subscriberFlags | SF.SubscribersRest) ^ SF.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction removeProxySubscriber(this: IProxySubscriberCollection, subscriber: IProxySubscriber): boolean {\n  const subscriberFlags = this._proxySubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._proxySubscriber0 === subscriber) {\n    this._proxySubscriber0 = void 0;\n    this._proxySubscriberFlags = (this._proxySubscriberFlags | SF.Subscriber0) ^ SF.Subscriber0;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber1) > 0 && this._proxySubscriber1 === subscriber) {\n    this._proxySubscriber1 = void 0;\n    this._proxySubscriberFlags = (this._proxySubscriberFlags | SF.Subscriber1) ^ SF.Subscriber1;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber2) > 0 && this._proxySubscriber2 === subscriber) {\n    this._proxySubscriber2 = void 0;\n    this._proxySubscriberFlags = (this._proxySubscriberFlags | SF.Subscriber2) ^ SF.Subscriber2;\n    return true;\n  } else if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._proxySubscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._proxySubscriberFlags = (this._proxySubscriberFlags | SF.SubscribersRest) ^ SF.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction removeCollectionSubscriber(this: ICollectionSubscriberCollection, subscriber: ICollectionSubscriber): boolean {\n  const subscriberFlags = this._collectionSubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._collectionSubscriber0 === subscriber) {\n    this._collectionSubscriber0 = void 0;\n    this._collectionSubscriberFlags = (this._collectionSubscriberFlags | SF.Subscriber0) ^ SF.Subscriber0;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber1) > 0 && this._collectionSubscriber1 === subscriber) {\n    this._collectionSubscriber1 = void 0;\n    this._collectionSubscriberFlags = (this._collectionSubscriberFlags | SF.Subscriber1) ^ SF.Subscriber1;\n    return true;\n  } else if ((subscriberFlags & SF.Subscriber2) > 0 && this._collectionSubscriber2 === subscriber) {\n    this._collectionSubscriber2 = void 0;\n    this._collectionSubscriberFlags = (this._collectionSubscriberFlags | SF.Subscriber2) ^ SF.Subscriber2;\n    return true;\n  } else if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._collectionSubscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        subscribers.splice(i, 1);\n        if (ii === 1) {\n          this._collectionSubscriberFlags = (this._collectionSubscriberFlags | SF.SubscribersRest) ^ SF.SubscribersRest;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction hasSubscribers(this: ISubscriberCollection): boolean {\n  return this._subscriberFlags !== SF.None;\n}\n\nfunction hasProxySubscribers(this: IProxySubscriberCollection): boolean {\n  return this._proxySubscriberFlags !== SF.None;\n}\n\nfunction hasCollectionSubscribers(this: ICollectionSubscriberCollection): boolean {\n  return this._collectionSubscriberFlags !== SF.None;\n}\n\nfunction hasSubscriber(this: ISubscriberCollection, subscriber: ISubscriber): boolean {\n  // Flags here is just a perf tweak\n  // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n  // and minor slow-down when it does, and the former is more common than the latter.\n  const subscriberFlags = this._subscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._subscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber1) > 0 && this._subscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber2) > 0 && this._subscriber2 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._subscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction hasProxySubscriber(this: IProxySubscriberCollection, subscriber: IProxySubscriber): boolean {\n  const subscriberFlags = this._proxySubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._proxySubscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber1) > 0 && this._proxySubscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber2) > 0 && this._proxySubscriber2 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._proxySubscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction hasCollectionSubscriber(this: ICollectionSubscriberCollection, subscriber: ICollectionSubscriber): boolean {\n  const subscriberFlags = this._collectionSubscriberFlags;\n  if ((subscriberFlags & SF.Subscriber0) > 0 && this._collectionSubscriber0 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber1) > 0 && this._collectionSubscriber1 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.Subscriber2) > 0 && this._collectionSubscriber2 === subscriber) {\n    return true;\n  }\n  if ((subscriberFlags & SF.SubscribersRest) > 0) {\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n    const subscribers = this._collectionSubscribersRest!;\n    for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n      if (subscribers[i] === subscriber) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction callSubscribers(this: ISubscriberCollection, newValue: unknown, previousValue: unknown, flags: LF): void {\n  /**\n   * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n   * callSubscribers invocation, so we're caching them all before invoking any.\n   * Subscribers added during this invocation are not invoked (and they shouldn't be).\n   * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n   * however this is accounted for via $isBound and similar flags on the subscriber objects)\n   */\n  const subscriber0 = this._subscriber0;\n  const subscriber1 = this._subscriber1;\n  const subscriber2 = this._subscriber2;\n  let subscribers = this._subscribersRest;\n  if (subscribers !== void 0) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== void 0) {\n    callSubscriber(subscriber0, newValue, previousValue, flags, subscriber0.id === void 0 ? 0 : this[subscriber0.id]);\n  }\n  if (subscriber1 !== void 0) {\n    callSubscriber(subscriber1, newValue, previousValue, flags, subscriber1.id === void 0 ? 0 : this[subscriber1.id]);\n  }\n  if (subscriber2 !== void 0) {\n    callSubscriber(subscriber2, newValue, previousValue, flags, subscriber2.id === void 0 ? 0 : this[subscriber2.id]);\n  }\n  if (subscribers !== void 0) {\n    const { length } = subscribers;\n    let subscriber: ISubscriber | undefined;\n    for (let i = 0; i < length; ++i) {\n      subscriber = subscribers[i];\n      if (subscriber !== void 0) {\n        callSubscriber(subscriber, newValue, previousValue, flags, subscriber.id === void 0 ? 0 : this[subscriber.id]);\n      }\n    }\n  }\n}\n\nfunction callSubscriber(\n  subscriber: ISubscriber,\n  newValue: unknown,\n  previousValue: unknown,\n  flags: LF,\n  ownFlags: LF,\n): void {\n  subscriber.handleChange(newValue, previousValue, ((flags | LF.update) ^ LF.update) | ownFlags);\n}\n\nfunction callProxySubscribers(this: IProxySubscriberCollection, key: PropertyKey, newValue: unknown, previousValue: unknown, flags: LF): void {\n  const subscriber0 = this._proxySubscriber0;\n  const subscriber1 = this._proxySubscriber1;\n  const subscriber2 = this._proxySubscriber2;\n  let subscribers = this._proxySubscribersRest;\n  if (subscribers !== void 0) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== void 0) {\n    subscriber0.handleProxyChange(key, newValue, previousValue, flags);\n  }\n  if (subscriber1 !== void 0) {\n    subscriber1.handleProxyChange(key, newValue, previousValue, flags);\n  }\n  if (subscriber2 !== void 0) {\n    subscriber2.handleProxyChange(key, newValue, previousValue, flags);\n  }\n  if (subscribers !== void 0) {\n    const { length } = subscribers;\n    let subscriber: IProxySubscriber | undefined;\n    for (let i = 0; i < length; ++i) {\n      subscriber = subscribers[i];\n      if (subscriber !== void 0) {\n        subscriber.handleProxyChange(key, newValue, previousValue, flags);\n      }\n    }\n  }\n}\n\nfunction callCollectionSubscribers(this: ICollectionSubscriberCollection, indexMap: IndexMap, flags: LF): void {\n  const subscriber0 = this._collectionSubscriber0;\n  const subscriber1 = this._collectionSubscriber1;\n  const subscriber2 = this._collectionSubscriber2;\n  let subscribers = this._collectionSubscribersRest;\n  if (subscribers !== void 0) {\n    subscribers = subscribers.slice();\n  }\n  if (subscriber0 !== void 0) {\n    subscriber0.handleCollectionChange(indexMap, flags);\n  }\n  if (subscriber1 !== void 0) {\n    subscriber1.handleCollectionChange(indexMap, flags);\n  }\n  if (subscriber2 !== void 0) {\n    subscriber2.handleCollectionChange(indexMap, flags);\n  }\n  if (subscribers !== void 0) {\n    const { length } = subscribers;\n    let subscriber: ICollectionSubscriber | undefined;\n    for (let i = 0; i < length; ++i) {\n      subscriber = subscribers[i];\n      if (subscriber !== void 0) {\n        subscriber.handleCollectionChange(indexMap, flags);\n      }\n    }\n  }\n}\n","import { PLATFORM, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport {\n  IPropertyObserver,\n  IProxy,\n  IProxyObserver,\n  IProxySubscriber,\n  ISubscriber,\n  PropertyObserver\n} from '../observation';\nimport { proxySubscriberCollection, subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\ntype Indexable = Record<string | number, unknown>;\n\nconst lookup: WeakMap<object, IProxy> = new WeakMap();\nexport interface ProxySubscriberCollection extends IPropertyObserver<Indexable, string> {}\n\n@subscriberCollection()\nexport class ProxySubscriberCollection<TObj extends object = object> implements ProxySubscriberCollection<TObj> {\n  public inBatch: boolean;\n\n  public readonly proxy: IProxy<TObj>;\n  public readonly raw: TObj;\n  public readonly key: string | number;\n  constructor(proxy: IProxy<TObj>, raw: TObj, key: string | number) {\n    if (Tracer.enabled) { Tracer.enter('ProxySubscriberCollection', 'constructor', slice.call(arguments)); }\n\n    this.inBatch = false;\n\n    this.raw = raw;\n    this.key = key;\n    this.proxy = proxy;\n    this.subscribe = this.addSubscriber;\n    this.unsubscribe = this.removeSubscriber;\n    if (raw[key as keyof TObj] instanceof Object) { // Ensure we observe array indices and newly created object properties\n      raw[key as keyof TObj] = ProxyObserver.getOrCreate(raw[key as keyof TObj] as unknown as object).proxy as unknown as TObj[keyof TObj];\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public setValue(value: unknown, flags?: LifecycleFlags): void {\n    const oldValue = this.raw[this.key as keyof TObj];\n    if (oldValue !== value) {\n      this.raw[this.key as keyof TObj] = value as TObj[keyof TObj];\n      this.callSubscribers(value, oldValue, flags! | LifecycleFlags.proxyStrategy | LifecycleFlags.updateTargetInstance);\n    }\n  }\n  public getValue(): unknown {\n    return this.raw[this.key as keyof TObj];\n  }\n\n  public flushBatch(flags: LifecycleFlags): void {\n\n  }\n}\n\nexport interface ProxyObserver<TObj extends object = object> extends IProxyObserver<TObj> {}\n\n@proxySubscriberCollection()\nexport class ProxyObserver<TObj extends object = object> implements ProxyObserver<TObj> {\n  public readonly proxy: IProxy<TObj>;\n  public readonly raw: TObj;\n  private readonly subscribers: Record<string | number, ProxySubscriberCollection<TObj>>;\n\n  constructor(obj: TObj) {\n    if (Tracer.enabled) { Tracer.enter('ProxyObserver', 'constructor', slice.call(arguments)); }\n    this.raw = obj;\n    this.proxy = new Proxy<TObj>(obj, this) as IProxy<TObj>;\n    lookup.set(obj, this.proxy);\n    this.subscribers = {};\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public static getProxyOrSelf<T extends object = object>(obj: T): T {\n    if ((obj as { $raw?: T }).$raw === void 0) {\n      const proxy = lookup.get(obj) as T;\n      if (proxy === void 0) {\n        return obj;\n      }\n      return proxy;\n    }\n    return obj;\n  }\n  public static getRawIfProxy<T extends object = object>(obj: T): T {\n    const raw = (obj as { $raw?: T }).$raw;\n    if (raw === void 0) {\n      return obj;\n    }\n    return raw;\n  }\n\n  public static getOrCreate<T extends object>(obj: T): IProxyObserver<T>;\n  public static getOrCreate<T extends object>(obj: T, key: string | number): PropertyObserver;\n  public static getOrCreate<T extends object>(obj: T, key?: string | number): IProxyObserver<T> | PropertyObserver {\n    let proxyObserver: ProxyObserver<T>;\n    if ((obj as T & { $raw?: T }).$raw === void 0) {\n      const proxy = lookup.get(obj);\n      if (proxy === void 0) {\n        proxyObserver = new ProxyObserver(obj);\n      } else {\n        proxyObserver = (proxy as T & { $observer: ProxyObserver<T> }).$observer;\n      }\n    } else {\n      proxyObserver = (obj as T & { $observer: ProxyObserver<T> }).$observer;\n    }\n    if (key === void 0) {\n      return proxyObserver;\n    }\n    let subscribers = proxyObserver.subscribers[key];\n    if (subscribers === void 0) {\n      const raw = this.getRawIfProxy(obj);\n      const proxy = proxyObserver.proxy;\n      subscribers = proxyObserver.subscribers[key] = new ProxySubscriberCollection(proxy, raw, key);\n    }\n    return subscribers;\n  }\n\n  public static isProxy<T extends object>(obj: T & { $raw?: T }): obj is T & { $raw: T; $observer: ProxyObserver<T> } {\n    return obj.$raw !== void 0;\n  }\n\n  public get(target: TObj, p: string | number, receiver?: unknown): unknown {\n    if (p === '$observer') {\n      return this;\n    }\n    if (p === '$raw') {\n      return target;\n    }\n    return target[p as keyof TObj];\n  }\n\n  public set(target: TObj, p: string | number, value: unknown, receiver?: unknown): boolean {\n    const oldValue = target[p as keyof TObj];\n    if (oldValue !== value) {\n      target[p as keyof TObj] = value as TObj[keyof TObj];\n      this.callPropertySubscribers(value, oldValue, p);\n      this.callProxySubscribers(p, value, oldValue, LifecycleFlags.proxyStrategy | LifecycleFlags.updateTargetInstance);\n    }\n    return true;\n  }\n\n  public deleteProperty(target: TObj, p: string | number): boolean {\n    const oldValue = target[p as keyof TObj];\n    if (Reflect.deleteProperty(target, p)) {\n      if (oldValue !== void 0) {\n        this.callPropertySubscribers(undefined, oldValue, p);\n        this.callProxySubscribers(p, undefined, oldValue, LifecycleFlags.proxyStrategy | LifecycleFlags.updateTargetInstance);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public defineProperty(target: TObj, p: string | number, attributes: PropertyDescriptor): boolean {\n    const oldValue = target[p as keyof TObj];\n    if (Reflect.defineProperty(target, p, attributes)) {\n      if (attributes.value !== oldValue) {\n        this.callPropertySubscribers(attributes.value, oldValue, p);\n        this.callProxySubscribers(p, attributes.value, oldValue, LifecycleFlags.proxyStrategy | LifecycleFlags.updateTargetInstance);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public apply(target: TObj, thisArg: unknown, argArray: ArrayLike<unknown> = PLATFORM.emptyArray): unknown {\n    // tslint:disable-next-line:ban-types // Reflect API dictates this\n    return Reflect.apply(target as Function, target, argArray);\n  }\n\n  public subscribe(subscriber: IProxySubscriber): void;\n  public subscribe(subscriber: ISubscriber, key: string | number): void;\n  public subscribe(subscriber: ISubscriber | IProxySubscriber, key?: string | number): void {\n    if (key === void 0) {\n      this.addProxySubscriber(subscriber as IProxySubscriber);\n    } else {\n      let subscribers = this.subscribers[key];\n      if (subscribers === void 0) {\n        subscribers = this.subscribers[key] = new ProxySubscriberCollection(this.proxy, this.raw, key);\n      }\n      subscribers.addSubscriber(subscriber as ISubscriber);\n    }\n  }\n\n  public unsubscribe(subscriber: IProxySubscriber): void;\n  public unsubscribe(subscriber: ISubscriber, key: string | number): void;\n  public unsubscribe(subscriber: ISubscriber | IProxySubscriber, key?: string | number): void {\n    if (key === void 0) {\n      this.removeProxySubscriber(subscriber as IProxySubscriber);\n    } else {\n      const subscribers = this.subscribers[key];\n      if (subscribers !== undefined) {\n        subscribers.removeSubscriber(subscriber as ISubscriber);\n      }\n    }\n  }\n\n  private callPropertySubscribers(newValue: unknown, oldValue: unknown, key: string | number): void {\n    const subscribers = this.subscribers[key];\n    if (subscribers !== void 0) {\n      subscribers.callSubscribers(newValue, oldValue, LifecycleFlags.proxyStrategy | LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n","import { IIndexable, Reporter, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { IPropertyObserver, ISubscriber } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface SetterObserver extends IPropertyObserver<IIndexable, string> {}\n\n@subscriberCollection()\nexport class SetterObserver {\n  public readonly lifecycle: ILifecycle;\n\n  public readonly obj: IIndexable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  public readonly persistentFlags: LifecycleFlags;\n  public inBatch: boolean;\n  public observing: boolean;\n\n  constructor(\n    lifecycle: ILifecycle,\n    flags: LifecycleFlags,\n    obj: IIndexable,\n    propertyKey: string,\n  ) {\n    this.lifecycle = lifecycle;\n\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    this.currentValue = void 0;\n    this.oldValue = void 0;\n\n    this.inBatch = false;\n\n    this.observing = false;\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    if (this.observing) {\n      const currentValue = this.currentValue;\n      this.currentValue = newValue;\n      if (this.lifecycle.batch.depth === 0) {\n        if ((flags & LifecycleFlags.fromBind) === 0) {\n          this.callSubscribers(newValue, currentValue, this.persistentFlags | flags);\n        }\n      } else if (!this.inBatch) {\n        this.inBatch = true;\n        this.oldValue = currentValue;\n        this.lifecycle.batch.add(this);\n      }\n    } else {\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.currentValue.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n      this.obj[this.propertyKey] = newValue;\n    }\n  }\n\n  public flushBatch(flags: LifecycleFlags): void {\n    this.inBatch = false;\n    const currentValue = this.currentValue;\n    const oldValue = this.oldValue;\n    this.oldValue = currentValue;\n    this.callSubscribers(currentValue, oldValue, this.persistentFlags | flags);\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.observing === false) {\n      this.observing = true;\n      this.currentValue = this.obj[this.propertyKey];\n      if (\n        !Reflect.defineProperty(\n          this.obj,\n          this.propertyKey,\n          {\n            enumerable: true,\n            configurable: true,\n            get: () => {\n              return this.getValue();\n            },\n            set: value => {\n              this.setValue(value, LifecycleFlags.none);\n            },\n          }\n        )\n      ) {\n        Reporter.write(1, this.propertyKey, this.obj);\n      }\n    }\n\n    this.addSubscriber(subscriber);\n  }\n}\n","import { IIndexable, Reporter, StrictPrimitive, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding, ILifecycle } from '../lifecycle';\nimport {\n  IBindingContext,\n  IOverrideContext,\n  IScope,\n  ObservedCollection,\n  ObserversLookup,\n  PropertyObserver\n} from '../observation';\nimport { ProxyObserver } from './proxy-observer';\nimport { SetterObserver } from './setter-observer';\n\nconst slice = Array.prototype.slice;\n\nconst enum RuntimeError {\n  NilScope = 250,\n  NilOverrideContext = 252,\n  NilParentScope = 253\n}\n\n/** @internal */\nexport class InternalObserversLookup {\n  public getOrCreate(\n    this: { [key: string]: PropertyObserver },\n    lifecycle: ILifecycle,\n    flags: LifecycleFlags,\n    obj: IBindingContext | IOverrideContext,\n    key: string,\n  ): PropertyObserver {\n    if (Tracer.enabled) { Tracer.enter('InternalObserversLookup', 'getOrCreate', slice.call(arguments)); }\n    if (this[key] === void 0) {\n      this[key] = new SetterObserver(lifecycle, flags, obj, key);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this[key];\n  }\n}\n\nexport type BindingContextValue = ObservedCollection | StrictPrimitive | IIndexable;\n\nexport class BindingContext implements IBindingContext {\n  public static partName: string | null = null;\n\n  [key: string]: unknown;\n\n  public readonly $synthetic: true;\n\n  public $observers?: ObserversLookup<IOverrideContext>;\n\n  private constructor(keyOrObj?: string | IIndexable, value?: unknown) {\n    this.$synthetic = true;\n\n    if (keyOrObj !== void 0) {\n      if (value !== void 0) {\n        // if value is defined then it's just a property and a value to initialize with\n        this[keyOrObj as string] = value;\n      } else {\n        // can either be some random object or another bindingContext to clone from\n        for (const prop in keyOrObj as IIndexable) {\n          if (keyOrObj.hasOwnProperty(prop)) {\n            this[prop] = (keyOrObj as IIndexable)[prop];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   * @param obj Optional. An existing object or `BindingContext` to (shallow) clone (own) properties from.\n   */\n  public static create(flags: LifecycleFlags, obj?: IIndexable): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   * @param key The name of the only property to initialize this `BindingContext` with.\n   * @param value The value of the only property to initialize this `BindingContext` with.\n   */\n  public static create(flags: LifecycleFlags, key: string, value: unknown): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   *\n   * This overload signature is simply the combined signatures of the other two, and can be used\n   * to keep strong typing in situations where the arguments are dynamic.\n   */\n  public static create(flags: LifecycleFlags, keyOrObj?: string | IIndexable, value?: unknown): BindingContext;\n  public static create(flags: LifecycleFlags, keyOrObj?: string | IIndexable, value?: unknown): BindingContext {\n    const bc = new BindingContext(keyOrObj, value);\n    if (flags & LifecycleFlags.proxyStrategy) {\n      return ProxyObserver.getOrCreate(bc).proxy;\n    }\n    return bc;\n  }\n\n  public static get(scope: IScope, name: string, ancestor: number, flags: LifecycleFlags): IBindingContext | IOverrideContext | IBinding | undefined | null {\n    if (Tracer.enabled) { Tracer.enter('BindingContext', 'get', slice.call(arguments)); }\n    if (scope == null) {\n      throw Reporter.error(RuntimeError.NilScope);\n    }\n    let overrideContext = scope.overrideContext;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        if (overrideContext.parentOverrideContext == null) {\n          if (Tracer.enabled) { Tracer.leave(); }\n          return void 0;\n        }\n        ancestor--;\n        overrideContext = overrideContext.parentOverrideContext;\n      }\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // traverse the context and it's ancestors, searching for a context that has the name.\n    while (overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {\n      overrideContext = overrideContext.parentOverrideContext!;\n    }\n\n    if (overrideContext) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      // we located a context with the property.  return it.\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // the name wasn't found. see if parent scope traversal is allowed and if so, try that\n    if ((flags & LifecycleFlags.allowParentScopeTraversal) > 0) {\n      const partScope = scope.partScopes![BindingContext.partName!]!;\n      const result = this.get(partScope, name, ancestor, flags\n        // unset the flag; only allow one level of scope boundary traversal\n        & ~LifecycleFlags.allowParentScopeTraversal\n        // tell the scope to return null if the name could not be found\n        | LifecycleFlags.isTraversingParentScope);\n      if (result !== null) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return result;\n      }\n    }\n\n    // still nothing found. return the root binding context (or null\n    // if this is a parent scope traversal, to ensure we fall back to the\n    // correct level)\n    if (flags & LifecycleFlags.isTraversingParentScope) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return scope.bindingContext || scope.overrideContext;\n  }\n\n  public getObservers(flags: LifecycleFlags): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('BindingContext', 'getObservers', slice.call(arguments)); }\n    if (this.$observers == null) {\n      this.$observers = new InternalObserversLookup() as ObserversLookup<IOverrideContext>;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.$observers;\n  }\n}\n\nexport class Scope implements IScope {\n  public bindingContext: object;\n  public overrideContext: IOverrideContext;\n\n  public partScopes?: Record<string, IScope | undefined>;\n\n  private constructor(bindingContext: object, overrideContext: IOverrideContext) {\n    this.bindingContext = bindingContext;\n    this.overrideContext = overrideContext;\n    this.partScopes = void 0;\n  }\n\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and a new standalone `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   * @param bc The `BindingContext` to back the `Scope` with.\n   */\n  public static create(flags: LifecycleFlags, bc: object): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * @param bc The `BindingContext` to back the `Scope` with.\n   * @param oc The `OverrideContext` to back the `Scope` with.\n   * If a binding expression attempts to access a property that does not exist on the `BindingContext`\n   * during binding, it will traverse up via the `parentOverrideContext` of the `OverrideContext` until\n   * it finds the property.\n   */\n  public static create(flags: LifecycleFlags, bc: object, oc: IOverrideContext): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc The `BindingContext` to back the `Scope` with.\n   * @param oc null. This overload is functionally equivalent to not passing this argument at all.\n   */\n  public static create(flags: LifecycleFlags, bc: object, oc: null): Scope;\n  public static create(flags: LifecycleFlags, bc: object, oc?: IOverrideContext | null): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope', 'create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, oc == null ? OverrideContext.create(flags, bc, oc!) : oc);\n  }\n\n  public static fromOverride(flags: LifecycleFlags, oc: IOverrideContext): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope', 'fromOverride', slice.call(arguments)); }\n    if (oc == null) {\n      throw Reporter.error(RuntimeError.NilOverrideContext);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(oc.bindingContext, oc);\n  }\n\n  public static fromParent(flags: LifecycleFlags, ps: IScope | null, bc: object): Scope {\n    if (Tracer.enabled) { Tracer.enter('Scope', 'fromParent', slice.call(arguments)); }\n    if (ps == null) {\n      throw Reporter.error(RuntimeError.NilParentScope);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new Scope(bc, OverrideContext.create(flags, bc, ps.overrideContext));\n  }\n}\n\nexport class OverrideContext implements IOverrideContext {\n  [key: string]: ObservedCollection | StrictPrimitive | IIndexable;\n\n  public readonly $synthetic: true;\n  public bindingContext: object;\n  public parentOverrideContext: IOverrideContext | null;\n\n  private constructor(bindingContext: object, parentOverrideContext: IOverrideContext | null) {\n    this.$synthetic = true;\n    this.bindingContext = bindingContext;\n    this.parentOverrideContext = parentOverrideContext;\n  }\n\n  public static create(flags: LifecycleFlags, bc: object, poc: IOverrideContext | null): OverrideContext {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext', 'create', slice.call(arguments)); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return new OverrideContext(bc, poc === void 0 ? null : poc);\n  }\n\n  public getObservers(): ObserversLookup<IOverrideContext> {\n    if (Tracer.enabled) { Tracer.enter('OverrideContext', 'getObservers', slice.call(arguments)); }\n    if (this.$observers === void 0) {\n      this.$observers = new InternalObserversLookup();\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.$observers as ObserversLookup<IOverrideContext>;\n  }\n}\n","import { DI } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ISubscriber } from '../observation';\n\ntype Signal = string;\n\nexport interface ISignaler {\n  signals: Record<string, Set<ISubscriber>>;\n  dispatchSignal(name: Signal, flags?: LifecycleFlags): void;\n  addSignalListener(name: Signal, listener: ISubscriber): void;\n  removeSignalListener(name: Signal, listener: ISubscriber): void;\n}\n\nexport const ISignaler = DI.createInterface<ISignaler>('ISignaler').withDefault(x => x.singleton(Signaler));\n\n/** @internal */\nexport class Signaler implements ISignaler {\n  public signals: Record<string, Set<ISubscriber>>;\n\n  constructor() {\n    this.signals = Object.create(null);\n  }\n\n  public dispatchSignal(name: Signal, flags?: LifecycleFlags): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    for (const listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined, flags! | LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public addSignalListener(name: Signal, listener: ISubscriber): void {\n    const signals = this.signals;\n    const listeners = signals[name];\n    if (listeners === undefined) {\n      signals[name] = new Set([listener]);\n    } else {\n      listeners.add(listener);\n    }\n  }\n\n  public removeSignalListener(name: Signal, listener: ISubscriber): void {\n    const listeners = this.signals[name];\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport { IScope } from '../observation';\n\nexport interface IBindingBehavior {\n  bind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n  unbind(flags: LifecycleFlags, scope: IScope, binding: IBinding): void;\n}\n\nexport interface IBindingBehaviorDefinition extends IResourceDefinition { }\n\nexport interface IBindingBehaviorType<C extends Constructable = Constructable> extends IResourceType<IBindingBehaviorDefinition, InstanceType<C> & IBindingBehavior> { }\n\nexport interface IBindingBehaviorResource extends\n  IResourceKind<IBindingBehaviorDefinition, IBindingBehavior, Class<IBindingBehavior>> {\n}\n\nfunction register(this: IBindingBehaviorType, container: IContainer): void {\n  const resourceKey = BindingBehaviorResource.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n  container.register(Registration.singleton(this, this));\n}\n\nexport function bindingBehavior(definition: IBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDefinition: string | IBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDefinition: string | IBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return target => BindingBehaviorResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IBindingBehaviorResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IBindingBehaviorResource, Type: T & Partial<IBindingBehaviorType>): Type is T & IBindingBehaviorType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable = Constructable>(this: IBindingBehaviorResource, definition: IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType<T>;\nfunction define<T extends Constructable = Constructable>(this: IBindingBehaviorResource, name: string, ctor: T): T & IBindingBehaviorType<T>;\nfunction define<T extends Constructable = Constructable>(this: IBindingBehaviorResource, nameOrDefinition: string | IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType<T>;\nfunction define<T extends Constructable = Constructable>(this: IBindingBehaviorResource, nameOrDefinition: string | IBindingBehaviorDefinition, ctor: T): T & IBindingBehaviorType<T> {\n  const Type = ctor as T & IBindingBehaviorType<T>;\n  const WritableType = Type as T & Writable<IBindingBehaviorType<T>>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  WritableType.kind = BindingBehaviorResource as IBindingBehaviorResource;\n  WritableType.description = description;\n  Type.register = register;\n\n  return Type;\n}\n\nexport const BindingBehaviorResource = {\n  name: 'binding-behavior',\n  keyFrom,\n  isType,\n  define\n};\n\nexport type BindingBehaviorDecorator = <T extends Constructable>(target: T) => T & IBindingBehaviorType<T>;\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceDefinition,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Writable\n} from '@aurelia/kernel';\n\nexport interface IValueConverter {\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n}\n\nexport interface IValueConverterDefinition extends IResourceDefinition { }\n\nexport interface IValueConverterType<C extends Constructable = Constructable> extends IResourceType<IValueConverterDefinition, InstanceType<C> & IValueConverter> { }\n\nexport interface IValueConverterResource extends\n  IResourceKind<IValueConverterDefinition, IValueConverter, Class<IValueConverter>> { }\n\nfunction register(this: IValueConverterType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.singleton(resourceKey, this));\n  container.register(Registration.singleton(this, this));\n}\n\nexport function valueConverter(definition: IValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(nameOrDefinition: string | IValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDefinition: string | IValueConverterDefinition): ValueConverterDecorator {\n  return target => ValueConverterResource.define(nameOrDefinition, target);\n}\n\nfunction keyFrom(this: IValueConverterResource, name: string): string {\n  return `${this.name}:${name}`;\n}\n\nfunction isType<T>(this: IValueConverterResource, Type: T & Partial<IValueConverterType>): Type is T & IValueConverterType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable = Constructable>(this: IValueConverterResource, definition: IValueConverterDefinition, ctor: T): T & IValueConverterType<T>;\nfunction define<T extends Constructable = Constructable>(this: IValueConverterResource, name: string, ctor: T): T & IValueConverterType<T>;\nfunction define<T extends Constructable = Constructable>(this: IValueConverterResource, nameOrDefinition: string | IValueConverterDefinition, ctor: T): T & IValueConverterType<T>;\nfunction define<T extends Constructable = Constructable>(this: IValueConverterResource, nameOrDefinition: string | IValueConverterDefinition, ctor: T): T & IValueConverterType<T> {\n  const Type = ctor as T & Writable<IValueConverterType>;\n  const description = typeof nameOrDefinition === 'string'\n    ? { name: nameOrDefinition }\n    : nameOrDefinition;\n\n  Type.kind = ValueConverterResource;\n  Type.description = description;\n  Type.register = register;\n\n  return Type as T & IValueConverterType<T>;\n}\n\nexport const ValueConverterResource = {\n  name: 'value-converter',\n  keyFrom,\n  isType,\n  define\n};\n\nexport type ValueConverterDecorator = <T extends Constructable>(target: T) => T & IValueConverterType<T>;\n","import {\n  IIndexable,\n  IServiceLocator,\n  PLATFORM,\n  Reporter,\n  StrictPrimitive,\n  isNumeric,\n} from '@aurelia/kernel';\n\nimport {\n  BinaryOperator,\n  BindingIdentifierOrPattern,\n  CallsFunction,\n  Connects,\n  HasAncestor,\n  HasBind,\n  HasUnbind,\n  IAccessKeyedExpression,\n  IAccessMemberExpression,\n  IAccessScopeExpression,\n  IAccessThisExpression,\n  IArrayBindingPattern,\n  IArrayLiteralExpression,\n  IAssignExpression,\n  IBinaryExpression,\n  IBindingBehaviorExpression,\n  IBindingIdentifier,\n  ICallFunctionExpression,\n  ICallMemberExpression,\n  ICallScopeExpression,\n  IConditionalExpression,\n  IExpression,\n  IForOfStatement,\n  IHtmlLiteralExpression,\n  IInterpolationExpression,\n  IObjectBindingPattern,\n  IObjectLiteralExpression,\n  IPrimitiveLiteralExpression,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsLiteral,\n  IsPrimary,\n  IsResource,\n  IsValueConverter,\n  ITaggedTemplateExpression,\n  ITemplateExpression,\n  IUnaryExpression,\n  IValueConverterExpression,\n  IVisitor,\n  Observes,\n  UnaryOperator,\n} from '../ast';\nimport {\n  ExpressionKind,\n  LifecycleFlags,\n} from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  Collection,\n  IBindingContext,\n  IOverrideContext,\n  IScope,\n  ObservedCollection,\n} from '../observation';\nimport { BindingContext } from '../observation/binding-context';\nimport { ProxyObserver } from '../observation/proxy-observer';\nimport { ISignaler } from '../observation/signaler';\nimport {\n  BindingBehaviorResource,\n  IBindingBehavior,\n} from '../resources/binding-behavior';\nimport {\n  IValueConverter,\n  ValueConverterResource,\n} from '../resources/value-converter';\nimport { IConnectableBinding } from './connectable';\n\nexport function connects(expr: IsExpressionOrStatement): expr is Connects {\n  return (expr.$kind & ExpressionKind.Connects) === ExpressionKind.Connects;\n}\nexport function observes(expr: IsExpressionOrStatement): expr is Observes {\n  return (expr.$kind & ExpressionKind.Observes) === ExpressionKind.Observes;\n}\nexport function callsFunction(expr: IsExpressionOrStatement): expr is CallsFunction {\n  return (expr.$kind & ExpressionKind.CallsFunction) === ExpressionKind.CallsFunction;\n}\nexport function hasAncestor(expr: IsExpressionOrStatement): expr is HasAncestor {\n  return (expr.$kind & ExpressionKind.HasAncestor) === ExpressionKind.HasAncestor;\n}\nexport function isAssignable(expr: IsExpressionOrStatement): expr is IsAssignable {\n  return (expr.$kind & ExpressionKind.IsAssignable) === ExpressionKind.IsAssignable;\n}\nexport function isLeftHandSide(expr: IsExpressionOrStatement): expr is IsLeftHandSide {\n  return (expr.$kind & ExpressionKind.IsLeftHandSide) === ExpressionKind.IsLeftHandSide;\n}\nexport function isPrimary(expr: IsExpressionOrStatement): expr is IsPrimary {\n  return (expr.$kind & ExpressionKind.IsPrimary) === ExpressionKind.IsPrimary;\n}\nexport function isResource(expr: IsExpressionOrStatement): expr is IsResource {\n  return (expr.$kind & ExpressionKind.IsResource) === ExpressionKind.IsResource;\n}\nexport function hasBind(expr: IsExpressionOrStatement): expr is HasBind {\n  return (expr.$kind & ExpressionKind.HasBind) === ExpressionKind.HasBind;\n}\nexport function hasUnbind(expr: IsExpressionOrStatement): expr is HasUnbind {\n  return (expr.$kind & ExpressionKind.HasUnbind) === ExpressionKind.HasUnbind;\n}\nexport function isLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  return (expr.$kind & ExpressionKind.IsLiteral) === ExpressionKind.IsLiteral;\n}\nexport function arePureLiterals(expressions: ReadonlyArray<IsExpressionOrStatement> | undefined): expressions is IsLiteral[] {\n  if (expressions === void 0 || expressions.length === 0) {\n    return true;\n  }\n  for (let i = 0; i < expressions.length; ++i) {\n    if (!isPureLiteral(expressions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function isPureLiteral(expr: IsExpressionOrStatement): expr is IsLiteral {\n  if (isLiteral(expr)) {\n    switch (expr.$kind) {\n      case ExpressionKind.ArrayLiteral:\n        return arePureLiterals(expr.elements);\n      case ExpressionKind.ObjectLiteral:\n        return arePureLiterals(expr.values);\n      case ExpressionKind.Template:\n        return arePureLiterals(expr.expressions);\n      case ExpressionKind.PrimitiveLiteral:\n        return true;\n    }\n  }\n  return false;\n}\n\nconst enum RuntimeError {\n  NoLocator = 202,\n  NoBehaviorFound = 203,\n  BehaviorAlreadyApplied = 204,\n  NoConverterFound = 205,\n  NoBinding = 206,\n  NotAFunction = 207,\n  UnknownOperator = 208,\n  NilScope = 250,\n}\n\nexport class BindingBehavior implements IBindingBehaviorExpression {\n  public readonly $kind: ExpressionKind.BindingBehavior;\n  public readonly expression: IsBindingBehavior;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly behaviorKey: string;\n\n  constructor(expression: IsBindingBehavior, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.BindingBehavior;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.behaviorKey = BindingBehaviorResource.keyFrom(this.name);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    return this.expression.assign!(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding & { [key: string]: IBindingBehavior | undefined }): void {\n    if (scope == null) {\n      throw Reporter.error(RuntimeError.NilScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    if (hasBind(this.expression)) {\n      this.expression.bind(flags, scope, binding);\n    }\n    const behaviorKey = this.behaviorKey;\n    const behavior = locator.get<IBindingBehavior>(behaviorKey);\n    if (!behavior) {\n      throw Reporter.error(RuntimeError.NoBehaviorFound, this);\n    }\n    if (binding[behaviorKey] === void 0) {\n      binding[behaviorKey] = behavior;\n      (behavior.bind.call as (...args: unknown[]) => void)(behavior, flags, scope, binding, ...evalList(flags, scope, locator, this.args));\n    } else {\n      Reporter.write(RuntimeError.BehaviorAlreadyApplied, this);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding & { [key: string]: IBindingBehavior | undefined }): void {\n    const behaviorKey = this.behaviorKey;\n    if (binding[behaviorKey] !== void 0) {\n      binding[behaviorKey]!.unbind(flags, scope, binding);\n      binding[behaviorKey] = void 0;\n    } else {\n      // TODO: this is a temporary hack to make testing repeater keyed mode easier,\n      // we should remove this idempotency again when track-by attribute is implemented\n      Reporter.write(RuntimeError.BehaviorAlreadyApplied, this);\n    }\n    if (hasUnbind(this.expression)) {\n      this.expression.unbind(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingBehavior(this);\n  }\n}\n\nexport class ValueConverter implements IValueConverterExpression {\n  public readonly $kind: ExpressionKind.ValueConverter;\n  public readonly expression: IsValueConverter;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly converterKey: string;\n\n  constructor(expression: IsValueConverter, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ValueConverter;\n    this.expression = expression;\n    this.name = name;\n    this.args = args;\n    this.converterKey = ValueConverterResource.keyFrom(this.name);\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('toView' in converter) {\n      const args = this.args;\n      const len = args.length;\n      const result = Array(len + 1);\n      result[0] = this.expression.evaluate(flags, scope, locator);\n      for (let i = 0; i < len; ++i) {\n        result[i + 1] = args[i].evaluate(flags, scope, locator);\n      }\n      return (converter.toView.call as (...args: unknown[]) => void)(converter, ...result);\n    }\n    return this.expression.evaluate(flags, scope, locator);\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    const converter = locator.get<ValueConverter & IValueConverter>(this.converterKey);\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    if ('fromView' in converter) {\n      value = (converter.fromView!.call as (...args: unknown[]) => void)(converter, value, ...(evalList(flags, scope, locator, this.args)));\n    }\n    return this.expression.assign!(flags, scope, locator, value);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (scope == null) {\n      throw Reporter.error(RuntimeError.NilScope, this);\n    }\n    if (!binding) {\n      throw Reporter.error(RuntimeError.NoBinding, this);\n    }\n    const locator = binding.locator;\n    if (!locator) {\n      throw Reporter.error(RuntimeError.NoLocator, this);\n    }\n    this.expression.connect(flags, scope, binding);\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    if (!converter) {\n      throw Reporter.error(RuntimeError.NoConverterFound, this);\n    }\n    const signals = converter.signals;\n    if (signals === void 0) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.addSignalListener(signals[i], binding);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const locator = binding.locator;\n    const converter = locator.get(this.converterKey) as { signals?: string[] };\n    const signals = converter.signals;\n    if (signals === void 0) {\n      return;\n    }\n    const signaler = locator.get(ISignaler);\n    for (let i = 0, ii = signals.length; i < ii; ++i) {\n      signaler.removeSignalListener(signals[i], binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitValueConverter(this);\n  }\n}\n\nexport class Assign implements IAssignExpression {\n  public readonly $kind: ExpressionKind.Assign;\n  public readonly target: IsAssignable;\n  public readonly value: IsAssign;\n\n  constructor(target: IsAssignable, value: IsAssign) {\n    this.$kind = ExpressionKind.Assign;\n    this.target = target;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.target.assign(flags, scope, locator, this.value.evaluate(flags, scope, locator));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    this.value.assign!(flags, scope, locator, value);\n    return this.target.assign(flags, scope, locator, value);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAssign(this);\n  }\n}\n\nexport class Conditional implements IConditionalExpression {\n  public readonly $kind: ExpressionKind.Conditional;\n  public assign: IExpression['assign'];\n  public readonly condition: IsBinary;\n  public readonly yes: IsAssign;\n  public readonly no: IsAssign;\n\n  constructor(condition: IsBinary, yes: IsAssign, no: IsAssign) {\n    this.$kind = ExpressionKind.Conditional;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.condition = condition;\n    this.yes = yes;\n    this.no = no;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return (!!this.condition.evaluate(flags, scope, locator))\n      ? this.yes.evaluate(flags, scope, locator)\n      : this.no.evaluate(flags, scope, locator);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const condition = this.condition;\n    if (condition.evaluate(flags, scope, null)) {\n      this.condition.connect(flags, scope, binding);\n      this.yes.connect(flags, scope, binding);\n    } else {\n      this.condition.connect(flags, scope, binding);\n      this.no.connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitConditional(this);\n  }\n}\n\nexport class AccessThis implements IAccessThisExpression {\n  public static readonly $this: AccessThis = new AccessThis(0);\n  public static readonly $parent: AccessThis = new AccessThis(1);\n  public readonly $kind: ExpressionKind.AccessThis;\n  public assign: IExpression['assign'];\n  public connect: IExpression['connect'];\n  public readonly ancestor: number;\n\n  constructor(ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessThis;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | undefined {\n    if (scope == null) {\n      throw Reporter.error(RuntimeError.NilScope, this);\n    }\n    let oc: IOverrideContext | null = scope.overrideContext;\n    let i = this.ancestor;\n    while (i-- && oc) {\n      oc = oc.parentOverrideContext;\n    }\n    return i < 1 && oc ? oc.bindingContext : void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessThis(this);\n  }\n}\n\nexport class AccessScope implements IAccessScopeExpression {\n  public readonly $kind: ExpressionKind.AccessScope;\n  public readonly name: string;\n  public readonly ancestor: number;\n\n  constructor(name: string, ancestor: number = 0) {\n    this.$kind = ExpressionKind.AccessScope;\n    this.name = name;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): IBindingContext | IBinding | IOverrideContext {\n    return (BindingContext.get(scope, this.name, this.ancestor, flags) as IBindingContext)[this.name] as IBindingContext | IBinding | IOverrideContext;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const obj = BindingContext.get(scope, this.name, this.ancestor, flags) as IBindingContext;\n    if (obj instanceof Object) {\n      if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {\n        obj.$observers[this.name].setValue(value, flags);\n        return value;\n      } else {\n        return obj[this.name] = value;\n      }\n    }\n    return void 0;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const context = BindingContext.get(scope, this.name, this.ancestor, flags)!;\n    binding.observeProperty(flags, context, this.name);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessScope(this);\n  }\n}\n\nexport class AccessMember implements IAccessMemberExpression {\n  public readonly $kind: ExpressionKind.AccessMember;\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n\n  constructor(object: IsLeftHandSide, name: string) {\n    this.$kind = ExpressionKind.AccessMember;\n    this.object = object;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    return instance == null ? instance : instance[this.name];\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const obj = this.object.evaluate(flags, scope, locator) as IBindingContext;\n    if (obj instanceof Object) {\n      if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {\n        obj.$observers[this.name].setValue(value, flags);\n      } else {\n        obj[this.name] = value;\n      }\n    } else {\n      this.object.assign!(flags, scope, locator, { [this.name]: value });\n    }\n    return value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (obj instanceof Object) {\n      binding.observeProperty(flags, obj, this.name);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessMember(this);\n  }\n}\n\nexport class AccessKeyed implements IAccessKeyedExpression {\n  public readonly $kind: ExpressionKind.AccessKeyed;\n  public readonly object: IsLeftHandSide;\n  public readonly key: IsAssign;\n\n  constructor(object: IsLeftHandSide, key: IsAssign) {\n    this.$kind = ExpressionKind.AccessKeyed;\n    this.object = object;\n    this.key = key;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    if (instance instanceof Object) {\n      const key = this.key.evaluate(flags, scope, locator) as string;\n      return (instance as IIndexable)[key];\n    }\n    return void 0;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, value: unknown): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const key = this.key.evaluate(flags, scope, locator) as string;\n    return instance[key] = value;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null);\n    this.object.connect(flags, scope, binding);\n    if (obj instanceof Object) {\n      this.key.connect(flags, scope, binding);\n      const key = this.key.evaluate(flags, scope, null);\n\n      if (Array.isArray(obj) && isNumeric(key)) {\n        // Only observe array indexers in proxy mode\n        if (flags & LifecycleFlags.proxyStrategy) {\n          binding.observeProperty(flags, obj, key as unknown as string);\n        }\n      } else {\n        // observe the property represented by the key as long as it's not an array indexer\n        // (note: string indexers behave the same way as numeric indexers as long as they represent numbers)\n        binding.observeProperty(flags, obj, key as string);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessKeyed(this);\n  }\n}\n\nexport class CallScope implements ICallScopeExpression {\n  public readonly $kind: ExpressionKind.CallScope;\n  public assign: IExpression['assign'];\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n  public readonly ancestor: number;\n\n  constructor(name: string, args: ReadonlyArray<IsAssign>, ancestor: number = 0) {\n    this.$kind = ExpressionKind.CallScope;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.name = name;\n    this.args = args;\n    this.ancestor = ancestor;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): unknown {\n    const args = evalList(flags, scope, locator, this.args);\n    const context = BindingContext.get(scope, this.name, this.ancestor, flags)!;\n    const func = getFunction(flags, context, this.name);\n    if (func) {\n      return func.apply(context, args as unknown[]);\n    }\n    return void 0;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const args = this.args;\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      args[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallScope(this);\n  }\n}\n\nexport class CallMember implements ICallMemberExpression {\n  public readonly $kind: ExpressionKind.CallMember;\n  public assign: IExpression['assign'];\n  public readonly object: IsLeftHandSide;\n  public readonly name: string;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(object: IsLeftHandSide, name: string, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallMember;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.object = object;\n    this.name = name;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const instance = this.object.evaluate(flags, scope, locator) as IIndexable;\n    const args = evalList(flags, scope, locator, this.args);\n    const func = getFunction(flags, instance, this.name);\n    if (func) {\n      return func.apply(instance, args as unknown[]);\n    }\n    return void 0;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const obj = this.object.evaluate(flags, scope, null) as IIndexable;\n    this.object.connect(flags, scope, binding);\n    if (getFunction(flags & ~LifecycleFlags.mustEvaluate, obj, this.name)) {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallMember(this);\n  }\n}\n\nexport class CallFunction implements ICallFunctionExpression {\n  public readonly $kind: ExpressionKind.CallFunction;\n  public assign: IExpression['assign'];\n  public readonly func: IsLeftHandSide;\n  public readonly args: ReadonlyArray<IsAssign>;\n\n  constructor(func: IsLeftHandSide, args: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.CallFunction;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.func = func;\n    this.args = args;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func === 'function') {\n      return func.apply(null, evalList(flags, scope, locator, this.args));\n    }\n    if (!(flags & LifecycleFlags.mustEvaluate) && (func == null)) {\n      return void 0;\n    }\n    throw Reporter.error(RuntimeError.NotAFunction, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const func = this.func.evaluate(flags, scope, null);\n    this.func.connect(flags, scope, binding);\n    if (typeof func === 'function') {\n      const args = this.args;\n      for (let i = 0, ii = args.length; i < ii; ++i) {\n        args[i].connect(flags, scope, binding);\n      }\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallFunction(this);\n  }\n}\n\nexport class Binary implements IBinaryExpression {\n  public readonly $kind: ExpressionKind.Binary;\n  public assign: IExpression['assign'];\n  public readonly operation: BinaryOperator;\n  public readonly left: IsBinary;\n  public readonly right: IsBinary;\n\n  constructor(operation: BinaryOperator, left: IsBinary, right: IsBinary) {\n    this.$kind = ExpressionKind.Binary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n\n    // what we're doing here is effectively moving the large switch statement from evaluate to the constructor\n    // so that the check only needs to be done once, and evaluate (which is called many times) will have a lot less\n    // work to do; we can do this because the operation can't change after it's parsed\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const left = this.left.evaluate(flags, scope, null);\n    this.left.connect(flags, scope, binding);\n    if (this.operation === '&&' && !left || this.operation === '||' && left) {\n      return;\n    }\n    this.right.connect(flags, scope, binding);\n  }\n\n  private ['&&'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) && this.right.evaluate(f, s, l);\n  }\n  private ['||'](f: LifecycleFlags, s: IScope, l: IServiceLocator): unknown {\n    return this.left.evaluate(f, s, l) || this.right.evaluate(f, s, l);\n  }\n  private ['=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) == this.right.evaluate(f, s, l);\n  }\n  private ['==='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) === this.right.evaluate(f, s, l);\n  }\n  private ['!='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    // tslint:disable-next-line:triple-equals\n    return this.left.evaluate(f, s, l) != this.right.evaluate(f, s, l);\n  }\n  private ['!=='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return this.left.evaluate(f, s, l) !== this.right.evaluate(f, s, l);\n  }\n  private ['instanceof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (typeof right === 'function') {\n      return this.left.evaluate(f, s, l) instanceof right;\n    }\n    return false;\n  }\n  private ['in'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    const right = this.right.evaluate(f, s, l);\n    if (right instanceof Object) {\n      return this.left.evaluate(f, s, l) as string in right;\n    }\n    return false;\n  }\n  // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n  // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n  // this makes bugs in user code easier to track down for end users\n  // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n  private ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) + (this.right.evaluate(f, s, l) as number);\n  }\n  private ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) - (this.right.evaluate(f, s, l) as number);\n  }\n  private ['*'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) * (this.right.evaluate(f, s, l) as number);\n  }\n  private ['/'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) / (this.right.evaluate(f, s, l) as number);\n  }\n  private ['%'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return (this.left.evaluate(f, s, l) as number) % (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) < (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) > (this.right.evaluate(f, s, l) as number);\n  }\n  private ['<='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) <= (this.right.evaluate(f, s, l) as number);\n  }\n  private ['>='](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return (this.left.evaluate(f, s, l) as number) >= (this.right.evaluate(f, s, l) as number);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBinary(this);\n  }\n}\n\nexport class Unary implements IUnaryExpression {\n  public readonly $kind: ExpressionKind.Unary;\n  public assign: IExpression['assign'];\n  public readonly operation: UnaryOperator;\n  public readonly expression: IsLeftHandSide;\n\n  constructor(operation: UnaryOperator, expression: IsLeftHandSide) {\n    this.$kind = ExpressionKind.Unary;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.operation = operation;\n    this.expression = expression;\n\n    // see Binary (we're doing the same thing here)\n    this.evaluate = this[operation] as IExpression['evaluate'];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    throw Reporter.error(RuntimeError.UnknownOperator, this);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.expression.connect(flags, scope, binding);\n  }\n\n  public ['void'](f: LifecycleFlags, s: IScope, l: IServiceLocator): undefined {\n    return void this.expression.evaluate(f, s, l);\n  }\n  public ['typeof'](f: LifecycleFlags, s: IScope, l: IServiceLocator): string {\n    return typeof this.expression.evaluate(f, s, l);\n  }\n  public ['!'](f: LifecycleFlags, s: IScope, l: IServiceLocator): boolean {\n    return !this.expression.evaluate(f, s, l);\n  }\n  public ['-'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return -(this.expression.evaluate(f, s, l) as number);\n  }\n  public ['+'](f: LifecycleFlags, s: IScope, l: IServiceLocator): number {\n    return +(this.expression.evaluate(f, s, l) as number);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitUnary(this);\n  }\n}\nexport class PrimitiveLiteral<TValue extends StrictPrimitive = StrictPrimitive> implements IPrimitiveLiteralExpression {\n  public static readonly $undefined: PrimitiveLiteral<undefined> = new PrimitiveLiteral<undefined>(void 0);\n  public static readonly $null: PrimitiveLiteral<null> = new PrimitiveLiteral<null>(null);\n  public static readonly $true: PrimitiveLiteral<true> = new PrimitiveLiteral<true>(true);\n  public static readonly $false: PrimitiveLiteral<false> = new PrimitiveLiteral<false>(false);\n  public static readonly $empty: PrimitiveLiteral<string> = new PrimitiveLiteral<''>('');\n  public readonly $kind: ExpressionKind.PrimitiveLiteral;\n  public connect: IExpression['connect'];\n  public assign: IExpression['assign'];\n  public readonly value: TValue;\n\n  constructor(value: TValue) {\n    this.$kind = ExpressionKind.PrimitiveLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.connect = PLATFORM.noop;\n    this.value = value;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): TValue {\n    return this.value;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitPrimitiveLiteral(this);\n  }\n}\n\nexport class HtmlLiteral implements IHtmlLiteralExpression {\n  public readonly $kind: ExpressionKind.HtmlLiteral;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<HtmlLiteral>;\n\n  constructor(parts: ReadonlyArray<HtmlLiteral>) {\n    this.$kind = ExpressionKind.HtmlLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const elements = this.parts;\n    let result = '';\n    let value;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      value = elements[i].evaluate(flags, scope, locator);\n      if (value == null) {\n        continue;\n      }\n      result += value;\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    for (let i = 0, ii = this.parts.length; i < ii; ++i) {\n      this.parts[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitHtmlLiteral(this);\n  }\n}\n\nexport class ArrayLiteral implements IArrayLiteralExpression {\n  public static readonly $empty: ArrayLiteral = new ArrayLiteral(PLATFORM.emptyArray);\n  public readonly $kind: ExpressionKind.ArrayLiteral;\n  public assign: IExpression['assign'];\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): ReadonlyArray<unknown> {\n    const elements = this.elements;\n    const length = elements.length;\n    const result = Array(length);\n    for (let i = 0; i < length; ++i) {\n      result[i] = elements[i].evaluate(flags, scope, locator);\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const elements = this.elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      elements[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayLiteral(this);\n  }\n}\n\nexport class ObjectLiteral implements IObjectLiteralExpression {\n  public static readonly $empty: ObjectLiteral = new ObjectLiteral(PLATFORM.emptyArray, PLATFORM.emptyArray);\n  public readonly $kind: ExpressionKind.ObjectLiteral;\n  public assign: IExpression['assign'];\n  public readonly keys: ReadonlyArray<number | string>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  constructor(keys: ReadonlyArray<number | string>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectLiteral;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): Record<string, unknown> {\n    const instance: Record<string, unknown> = {};\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      instance[keys[i]] = values[i].evaluate(flags, scope, locator);\n    }\n    return instance;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const keys = this.keys;\n    const values = this.values;\n    for (let i = 0, ii = keys.length; i < ii; ++i) {\n      values[i].connect(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectLiteral(this);\n  }\n}\n\nexport class Template implements ITemplateExpression {\n  public static readonly $empty: Template = new Template(['']);\n  public readonly $kind: ExpressionKind.Template;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string>, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.Template;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.expressions = expressions === void 0 ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const cooked = this.cooked;\n    let result = cooked[0];\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      result += expressions[i].evaluate(flags, scope, locator);\n      result += cooked[i + 1];\n    }\n    return result;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n      i++;\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class TaggedTemplate implements ITaggedTemplateExpression {\n  public readonly $kind: ExpressionKind.TaggedTemplate;\n  public assign: IExpression['assign'];\n  public readonly cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> };\n  public readonly func: IsLeftHandSide;\n  public readonly expressions: ReadonlyArray<IsAssign>;\n\n  constructor(cooked: ReadonlyArray<string> & { raw?: ReadonlyArray<string> }, raw: ReadonlyArray<string>, func: IsLeftHandSide, expressions?: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.TaggedTemplate;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.cooked = cooked;\n    this.cooked.raw = raw;\n    this.func = func;\n    this.expressions = expressions === void 0 ? PLATFORM.emptyArray : expressions;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    const expressions = this.expressions;\n    const len = expressions.length;\n    const results = Array(len);\n    for (let i = 0, ii = len; i < ii; ++i) {\n      results[i] = expressions[i].evaluate(flags, scope, locator);\n    }\n    const func = this.func.evaluate(flags, scope, locator);\n    if (typeof func !== 'function') {\n      throw Reporter.error(RuntimeError.NotAFunction, this);\n    }\n    return func.apply(null, [this.cooked].concat(results));\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    const expressions = this.expressions;\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      expressions[i].connect(flags, scope, binding);\n    }\n    this.func.connect(flags, scope, binding);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTaggedTemplate(this);\n  }\n}\n\nexport class ArrayBindingPattern implements IArrayBindingPattern {\n  public readonly $kind: ExpressionKind.ArrayBindingPattern;\n  public readonly elements: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(elements: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ArrayBindingPattern;\n    this.elements = elements;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayBindingPattern(this);\n  }\n}\n\nexport class ObjectBindingPattern implements IObjectBindingPattern {\n  public readonly $kind: ExpressionKind.ObjectBindingPattern;\n  public readonly keys: ReadonlyArray<string | number>;\n  public readonly values: ReadonlyArray<IsAssign>;\n\n  // We'll either have elements, or keys+values, but never all 3\n  constructor(keys: ReadonlyArray<string | number>, values: ReadonlyArray<IsAssign>) {\n    this.$kind = ExpressionKind.ObjectBindingPattern;\n    this.keys = keys;\n    this.values = values;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public assign(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator, obj: IIndexable): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectBindingPattern(this);\n  }\n}\n\nexport class BindingIdentifier implements IBindingIdentifier {\n  public readonly $kind: ExpressionKind.BindingIdentifier;\n  public readonly name: string;\n\n  constructor(name: string) {\n    this.$kind = ExpressionKind.BindingIdentifier;\n    this.name = name;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null): string {\n    return this.name;\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingIdentifier(this);\n  }\n}\n\nconst toStringTag = Object.prototype.toString as {\n  call(obj: unknown): keyof typeof CountForOfStatement;\n};\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement implements IForOfStatement {\n  public readonly $kind: ExpressionKind.ForOfStatement;\n  public assign: IExpression['assign'];\n  public readonly declaration: BindingIdentifierOrPattern;\n  public readonly iterable: IsBindingBehavior;\n\n  constructor(declaration: BindingIdentifierOrPattern, iterable: IsBindingBehavior) {\n    this.$kind = ExpressionKind.ForOfStatement;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.declaration = declaration;\n    this.iterable = iterable;\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): unknown {\n    return this.iterable.evaluate(flags, scope, locator);\n  }\n\n  public count(flags: LifecycleFlags, result: ObservedCollection | number | null | undefined): number {\n    return CountForOfStatement[toStringTag.call(result)](result as any);\n  }\n\n  public iterate(flags: LifecycleFlags, result: ObservedCollection | number | null | undefined, func: (arr: Collection, index: number, item: unknown) => void): void {\n    IterateForOfStatement[toStringTag.call(result)](flags | LifecycleFlags.isOriginalArray, result as any, func);\n  }\n\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    this.declaration.connect(flags, scope, binding);\n    this.iterable.connect(flags, scope, binding);\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (hasBind(this.iterable)) {\n      this.iterable.bind(flags, scope, binding);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    if (hasUnbind(this.iterable)) {\n      this.iterable.unbind(flags, scope, binding);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitForOfStatement(this);\n  }\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation implements IInterpolationExpression {\n  public readonly $kind: ExpressionKind.Interpolation;\n  public assign: IExpression['assign'];\n  public readonly parts: ReadonlyArray<string>;\n  public readonly expressions: ReadonlyArray<IsBindingBehavior>;\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  constructor(parts: ReadonlyArray<string>, expressions?: ReadonlyArray<IsBindingBehavior>) {\n    this.$kind = ExpressionKind.Interpolation;\n    this.assign = PLATFORM.noop as () => unknown;\n    this.parts = parts;\n    this.expressions = expressions === void 0 ? PLATFORM.emptyArray : expressions;\n    this.isMulti = this.expressions.length > 1;\n    this.firstExpression = this.expressions[0];\n  }\n\n  public evaluate(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator): string {\n    if (this.isMulti) {\n      const expressions = this.expressions;\n      const parts = this.parts;\n      let result = parts[0];\n      for (let i = 0, ii = expressions.length; i < ii; ++i) {\n        result += expressions[i].evaluate(flags, scope, locator);\n        result += parts[i + 1];\n      }\n      return result;\n    } else {\n      const parts = this.parts;\n      return parts[0] + this.firstExpression.evaluate(flags, scope, locator) + parts[1];\n    }\n  }\n  public connect(flags: LifecycleFlags, scope: IScope, binding: IConnectableBinding): void {\n    return;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitInterpolation(this);\n  }\n}\n\n/// Evaluate the [list] in context of the [scope].\nfunction evalList(flags: LifecycleFlags, scope: IScope, locator: IServiceLocator | null, list: ReadonlyArray<IExpression>): ReadonlyArray<IExpression> {\n  const len = list.length;\n  const result = Array(len);\n  for (let i = 0; i < len; ++i) {\n    result[i] = list[i].evaluate(flags, scope, locator);\n  }\n  return result;\n}\n\nfunction getFunction(flags: LifecycleFlags, obj: IIndexable, name: string): ((...args: unknown[]) => unknown) | null {\n  const func = obj == null ? null : obj[name];\n  if (typeof func === 'function') {\n    return func as (...args: unknown[]) => unknown;\n  }\n  if (!(flags & LifecycleFlags.mustEvaluate) && func == null) {\n    return null;\n  }\n  throw Reporter.error(RuntimeError.NotAFunction, obj, name, func);\n}\n\nconst proxyAndOriginalArray = LifecycleFlags.proxyStrategy | LifecycleFlags.isOriginalArray;\n\n/** @internal */\nexport const IterateForOfStatement = {\n  ['[object Array]'](flags: LifecycleFlags, result: unknown[], func: (arr: Collection, index: number, item: unknown) => void): void {\n    if ((flags & proxyAndOriginalArray) === proxyAndOriginalArray) {\n      // If we're in proxy mode, and the array is the original \"items\" (and not an array we created here to iterate over e.g. a set)\n      // then replace all items (which are Objects) with proxies so their properties are observed in the source view model even if no\n      // observers are explicitly created\n      const rawArray = ProxyObserver.getRawIfProxy(result);\n      const len = rawArray.length;\n      let item: unknown;\n      let i = 0;\n      for (; i < len; ++i) {\n        item = rawArray[i];\n        if (item instanceof Object) {\n          item = rawArray[i] = ProxyObserver.getOrCreate(item).proxy;\n        }\n        func(rawArray, i, item);\n      }\n    } else {\n      for (let i = 0, ii = result.length; i < ii; ++i) {\n        func(result, i, result[i]);\n      }\n    }\n  },\n  ['[object Map]'](flags: LifecycleFlags, result: Map<unknown, unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const entry of result.entries()) {\n      arr[++i] = entry;\n    }\n    IterateForOfStatement['[object Array]'](flags & ~LifecycleFlags.isOriginalArray, arr, func);\n  },\n  ['[object Set]'](flags: LifecycleFlags, result: Set<unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result.size);\n    let i = -1;\n    for (const key of result.keys()) {\n      arr[++i] = key;\n    }\n    IterateForOfStatement['[object Array]'](flags & ~LifecycleFlags.isOriginalArray, arr, func);\n  },\n  ['[object Number]'](flags: LifecycleFlags, result: number, func: (arr: Collection, index: number, item: unknown) => void): void {\n    const arr = Array(result);\n    for (let i = 0; i < result; ++i) {\n      arr[i] = i;\n    }\n    IterateForOfStatement['[object Array]'](flags & ~LifecycleFlags.isOriginalArray, arr, func);\n  },\n  ['[object Null]'](flags: LifecycleFlags, result: null, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  },\n  ['[object Undefined]'](flags: LifecycleFlags, result: undefined, func: (arr: Collection, index: number, item: unknown) => void): void {\n    return;\n  }\n};\n\n/** @internal */\nexport const CountForOfStatement = {\n  ['[object Array]'](result: unknown[]): number { return result.length; },\n  ['[object Map]'](result: Map<unknown, unknown>): number { return result.size; },\n  ['[object Set]'](result: Set<unknown>): number { return result.size; },\n  ['[object Number]'](result: number): number { return result; },\n  ['[object Null]'](result: null): number { return 0; },\n  ['[object Undefined]'](result: undefined): number { return 0; }\n};\n","/*\n* Note: the oneTime binding now has a non-zero value for 2 reasons:\n*  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n*\n* Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n*/\nexport enum BindingMode {\n  oneTime  = 0b0001,\n  toView   = 0b0010,\n  fromView = 0b0100,\n  twoWay   = 0b0110,\n  default  = 0b1000\n}\n\nexport const enum BindingStrategy {\n  /**\n   * Configures all components \"below\" this one to operate in getterSetter binding mode.\n   * This is the default; if no strategy is specified, this one is implied.\n   *\n   * This strategy is the most compatible, convenient and has the best performance on frequently updated bindings on components that are infrequently replaced.\n   * However, it also consumes the most resources on initialization.\n   */\n  getterSetter = 0b01,\n  /**\n   * Configures all components \"below\" this one to operate in proxy binding mode.\n   * No getters/setters are created.\n   *\n   * This strategy consumes significantly fewer resources than `getterSetter` on initialization and has the best performance on infrequently updated bindings on\n   * components that are frequently replaced.\n   * However, it consumes more resources on updates.\n   */\n  proxies      = 0b10,\n}\n\nconst mandatoryStrategy = BindingStrategy.getterSetter | BindingStrategy.proxies;\n\nexport function ensureValidStrategy(strategy: BindingStrategy | null | undefined): BindingStrategy {\n  if ((strategy! & mandatoryStrategy) === 0) {\n    // TODO: probably want to validate that user isn't trying to mix getterSetter/proxy\n    // TODO: also need to make sure that strategy can be changed away from proxies inside the component tree (not here though, but just making a note)\n    return strategy! | BindingStrategy.getterSetter;\n  }\n  return strategy!;\n}\n\nexport const enum State {\n  none                  = 0b000000_00_000000_00000000,\n  isBinding             = 0b000000_00_000000_00000001,\n  isUnbinding           = 0b000000_00_000000_00000010,\n  isBound               = 0b000000_00_000000_00000100,\n  isBoundOrBinding      = 0b000000_00_000000_00000101,\n  isBoundOrUnbinding    = 0b000000_00_000000_00000110,\n  isAttaching           = 0b000000_00_000000_00001000,\n  isDetaching           = 0b000000_00_000000_00010000,\n  isAttached            = 0b000000_00_000000_00100000,\n  isAttachedOrAttaching = 0b000000_00_000000_00101000,\n  isAttachedOrDetaching = 0b000000_00_000000_00110000,\n  isMounted             = 0b000000_00_000000_01000000,\n  isCached              = 0b000000_00_000000_10000000,\n  needsBind             = 0b000000_00_000001_00000000,\n  needsUnbind           = 0b000000_00_000010_00000000,\n  needsAttach           = 0b000000_00_000100_00000000,\n  needsDetach           = 0b000000_00_001000_00000000,\n  needsMount            = 0b000000_00_010000_00000000,\n  needsUnmount          = 0b000000_00_100000_00000000,\n  hasLockedScope        = 0b000000_01_000000_00000000,\n  canBeCached           = 0b000000_10_000000_00000000,\n  inBoundQueue          = 0b000001_00_000000_00000000,\n  inUnboundQueue        = 0b000010_00_000000_00000000,\n  inAttachedQueue       = 0b000100_00_000000_00000000,\n  inDetachedQueue       = 0b001000_00_000000_00000000,\n  inMountQueue          = 0b010000_00_000000_00000000,\n  inUnmountQueue        = 0b100000_00_000000_00000000,\n}\n\nexport const enum Hooks {\n  none                   = 0b000000000001,\n  hasCreated             = 0b000000000010,\n  hasBinding             = 0b000000000100,\n  hasBound               = 0b000000001000,\n  hasAttaching           = 0b000000010000,\n  hasAttached            = 0b000000100000,\n  hasDetaching           = 0b000001000000,\n  hasDetached            = 0b000010000000,\n  hasUnbinding           = 0b000100000000,\n  hasUnbound             = 0b001000000000,\n  hasRender              = 0b010000000000,\n  hasCaching             = 0b100000000000\n}\n\nexport const enum LifecycleFlags {\n  none                      = 0b0_0000000000_0000000000000_00_0000,\n  // Bitmask for flags that need to be stored on a binding during $bind for mutation\n  // callbacks outside of $bind\n  persistentBindingFlags    = 0b1_0000000000_0000000000000_00_1111,\n  allowParentScopeTraversal = 0b1_0000000000_0000000000000_00_0000,\n  bindingStrategy           = 0b0_0000000000_0000000000000_00_1111,\n  getterSetterStrategy      = 0b0_0000000000_0000000000000_00_0001,\n  proxyStrategy             = 0b0_0000000000_0000000000000_00_0010,\n  update                    = 0b0_0000000000_0000000000000_11_0000,\n  updateTargetInstance      = 0b0_0000000000_0000000000000_01_0000,\n  updateSourceExpression    = 0b0_0000000000_0000000000000_10_0000,\n  from                      = 0b0_0000000000_1111111111111_00_0000,\n  fromFlush                 = 0b0_0000000000_0000000001111_00_0000,\n  fromAsyncFlush            = 0b0_0000000000_0000000000001_00_0000,\n  fromSyncFlush             = 0b0_0000000000_0000000000010_00_0000,\n  fromTick                  = 0b0_0000000000_0000000000100_00_0000,\n  fromBatch                 = 0b0_0000000000_0000000001000_00_0000,\n  fromStartTask             = 0b0_0000000000_0000000010000_00_0000,\n  fromStopTask              = 0b0_0000000000_0000000100000_00_0000,\n  fromBind                  = 0b0_0000000000_0000001000000_00_0000,\n  fromUnbind                = 0b0_0000000000_0000010000000_00_0000,\n  fromAttach                = 0b0_0000000000_0000100000000_00_0000,\n  fromDetach                = 0b0_0000000000_0001000000000_00_0000,\n  fromCache                 = 0b0_0000000000_0010000000000_00_0000,\n  fromDOMEvent              = 0b0_0000000000_0100000000000_00_0000,\n  fromLifecycleTask         = 0b0_0000000000_1000000000000_00_0000,\n  allowPublishRoundtrip     = 0b0_0000000001_0000000000000_00_0000,\n  isPublishing              = 0b0_0000000010_0000000000000_00_0000,\n  mustEvaluate              = 0b0_0000000100_0000000000000_00_0000,\n  parentUnmountQueued       = 0b0_0000001000_0000000000000_00_0000,\n  // this flag is for the synchronous flush before detach (no point in updating the\n  // DOM if it's about to be detached)\n  doNotUpdateDOM            = 0b0_0000010000_0000000000000_00_0000,\n  isTraversingParentScope   = 0b0_0000100000_0000000000000_00_0000,\n  isOriginalArray           = 0b0_0001000000_0000000000000_00_0000,\n  isCollectionMutation      = 0b0_0010000000_0000000000000_00_0000,\n  updateOneTimeBindings     = 0b0_0100000000_0000000000000_00_0000,\n  reorderNodes              = 0b0_1000000000_0000000000000_00_0000,\n}\n\nexport const enum ExpressionKind {\n  Connects             = 0b000000000001_00000, // The expression's connect() function calls observeProperty and/or calls connect() on another expression that it wraps (all expressions except for AccessThis, PrimitiveLiteral, CallMember/Function and Assign)\n  Observes             = 0b000000000010_00000, // The expression's connect() function calls observeProperty (only AccessScope, AccessMember and AccessKeyed do this)\n  CallsFunction        = 0b000000000100_00000, // Calls a function (CallFunction, CallScope, CallMember, TaggedTemplate) -> needs a valid function object returning from its lefthandside's evaluate()\n  HasAncestor          = 0b000000001000_00000, // Has an \"ancestor\" property, meaning the expression could climb up the context (only AccessThis, AccessScope and CallScope)\n  IsPrimary            = 0b000000010000_00000, // Is a primary expression according to ES parsing rules\n  IsLeftHandSide       = 0b000000100000_00000, // Is a left-hand side expression according to ES parsing rules, includes IsPrimary\n  HasBind              = 0b000001000000_00000, // Has a bind() method (currently only BindingBehavior)\n  HasUnbind            = 0b000010000000_00000, // Has an unbind() method (currentl only BindingBehavior and ValueConverter)\n  IsAssignable         = 0b000100000000_00000, // Is an assignable expression according to ES parsing rules (only AccessScope, AccessMember, AccessKeyed ans Assign)\n  IsLiteral            = 0b001000000000_00000, // Is an Aurelia resource (ValueConverter or BindingBehavior)\n  IsResource           = 0b010000000000_00000, // Is literal expression (Primitive, Array, Object or Template)\n  IsForDeclaration     = 0b100000000000_00000, // Is a For declaration (for..of, for..in -> currently only ForOfStatement)\n  Type                 = 0b000000000000_11111, // Type mask to uniquely identify each AST class (concrete types start below)\n  // ---------------------------------------------------------------------------------------------------------------------------\n  AccessThis           = 0b000000111000_00001, //               HasAncestor\n  AccessScope          = 0b000100111011_00010, // IsAssignable  HasAncestor       Observes  Connects\n  ArrayLiteral         = 0b001000110001_00011, //                                           Connects\n  ObjectLiteral        = 0b001000110001_00100, //                                           Connects\n  PrimitiveLiteral     = 0b001000110000_00101, //\n  Template             = 0b001000110001_00110, //                                           Connects\n  Unary                = 0b000000000001_00111, //                                           Connects\n  CallScope            = 0b000000101101_01000, //               HasAncestor  CallsFunction  Connects\n  CallMember           = 0b000000100100_01001, //                            CallsFunction\n  CallFunction         = 0b000000100100_01010, //                            CallsFunction\n  AccessMember         = 0b000100100011_01011, // IsAssignable                    Observes  Connects\n  AccessKeyed          = 0b000100100011_01100, // IsAssignable                    Observes  Connects\n  TaggedTemplate       = 0b000000100101_01101, //                            CallsFunction  Connects\n  Binary               = 0b000000000001_01110, //                                           Connects\n  Conditional          = 0b000000000001_11111, //                                           Connects\n  Assign               = 0b000100000000_10000, // IsAssignable\n  ValueConverter       = 0b010010000001_10001, //                                           Connects\n  BindingBehavior      = 0b010011000001_10010, //                                           Connects\n  HtmlLiteral          = 0b000000000001_10011, //                                           Connects\n  ArrayBindingPattern  = 0b100000000000_10100, //\n  ObjectBindingPattern = 0b100000000000_10101, //\n  BindingIdentifier    = 0b100000000000_10110, //\n  ForOfStatement       = 0b000011000001_10111, //                                           Connects\n  Interpolation        = 0b000000000000_11000  //\n}\n","import {\n  DI,\n  IContainer,\n  IDisposable,\n  IIndexable,\n  IResolver,\n  IServiceLocator,\n  PLATFORM,\n  Registration,\n  Tracer,\n} from '@aurelia/kernel';\n\nimport {\n  HooksDefinition,\n  ITargetedInstruction,\n  TemplateDefinition,\n  TemplatePartDefinitions,\n} from './definitions';\nimport {\n  INode,\n  INodeSequence,\n  IRenderLocation,\n} from './dom';\nimport {\n  LifecycleFlags,\n  State\n} from './flags';\nimport {\n  ILifecycleTask,\n  MaybePromiseOrTask,\n} from './lifecycle-task';\nimport {\n  IBatchable,\n  IBindingTargetAccessor,\n  IScope,\n} from './observation';\nimport {\n  IElementProjector,\n} from './resources/custom-element';\n\nconst slice = Array.prototype.slice;\n\nexport interface IBinding {\n  readonly locator: IServiceLocator;\n  readonly $scope?: IScope;\n  readonly $state: State;\n  $bind(flags: LifecycleFlags, scope: IScope): void;\n  $unbind(flags: LifecycleFlags): void;\n}\n\nexport const enum ViewModelKind {\n  customElement,\n  customAttribute,\n  synthetic\n}\n\n// TODO: extract 3 specialized interfaces for custom element / custom attribute / synthetic view\n//  to keep the public API intuitive\nexport interface IController<\n  T extends INode = INode,\n  C extends IViewModel<T> = IViewModel<T>,\n> {\n  readonly id: number;\n\n  nextBound?: IController<T>;\n  nextUnbound?: IController<T>;\n  prevBound?: IController<T>;\n  prevUnbound?: IController<T>;\n\n  nextAttached?: IController<T>;\n  nextDetached?: IController<T>;\n  prevAttached?: IController<T>;\n  prevDetached?: IController<T>;\n\n  nextMount?: IController<T>;\n  nextUnmount?: IController<T>;\n  prevMount?: IController<T>;\n  prevUnmount?: IController<T>;\n\n  readonly flags: LifecycleFlags;\n  readonly viewCache?: IViewCache<T>;\n\n  bindings?: IBinding[];\n  controllers?: IController<T>[];\n\n  state: State;\n\n  readonly lifecycle: ILifecycle;\n\n  readonly hooks: HooksDefinition;\n  readonly viewModel?: C;\n  readonly bindingContext?: C & IIndexable;\n\n  readonly host?: T;\n\n  readonly vmKind: ViewModelKind;\n\n  scope?: IScope;\n  projector?: IElementProjector;\n\n  nodes?: INodeSequence<T>;\n  context?: IContainer | IRenderContext<T>;\n  location?: IRenderLocation<T>;\n\n  readonly scopeParts: readonly string[];\n\n  lockScope(scope: IScope): void;\n  hold(location: IRenderLocation<T>): void;\n  release(flags: LifecycleFlags): boolean;\n  bind(flags: LifecycleFlags, scope?: IScope): ILifecycleTask;\n  unbind(flags: LifecycleFlags): ILifecycleTask;\n  bound(flags: LifecycleFlags): void;\n  unbound(flags: LifecycleFlags): void;\n  attach(flags: LifecycleFlags): void;\n  detach(flags: LifecycleFlags): void;\n  attached(flags: LifecycleFlags): void;\n  detached(flags: LifecycleFlags): void;\n  mount(flags: LifecycleFlags): void;\n  unmount(flags: LifecycleFlags): void;\n  cache(flags: LifecycleFlags): void;\n  getTargetAccessor(propertyName: string): IBindingTargetAccessor | undefined;\n}\n\nexport const IController = DI.createInterface<IController>('IController').noDefault();\n\nexport interface IRenderContext<T extends INode = INode> extends IServiceLocator {\n  createChild(): IRenderContext<T>;\n  render(flags: LifecycleFlags, renderable: IController<T>, targets: ArrayLike<object>, templateDefinition: TemplateDefinition, host?: T, parts?: TemplatePartDefinitions): void;\n  beginComponentOperation(renderable: IController<T>, target: object, instruction: ITargetedInstruction, factory?: IViewFactory<T>, parts?: TemplatePartDefinitions, location?: IRenderLocation<T>, locationIsContainer?: boolean): IDisposable;\n}\n\nexport interface IViewCache<T extends INode = INode> {\n  readonly isCaching: boolean;\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n  canReturnToCache(view: IController<T>): boolean;\n  tryReturnToCache(view: IController<T>): boolean;\n}\n\nexport interface IViewFactory<T extends INode = INode> extends IViewCache<T> {\n  readonly name: string;\n  readonly parts: TemplatePartDefinitions;\n  create(flags?: LifecycleFlags): IController<T>;\n  addParts(parts: TemplatePartDefinitions): void;\n}\n\nexport const IViewFactory = DI.createInterface<IViewFactory>('IViewFactory').noDefault();\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface IViewModel<T extends INode = INode> {\n  readonly $controller?: IController<T, this>;\n  created?(flags: LifecycleFlags): void;\n  binding?(flags: LifecycleFlags): MaybePromiseOrTask;\n  bound?(flags: LifecycleFlags): void;\n  unbinding?(flags: LifecycleFlags): MaybePromiseOrTask;\n  unbound?(flags: LifecycleFlags): void;\n  attaching?(flags: LifecycleFlags): void;\n  attached?(flags: LifecycleFlags): void;\n  detaching?(flags: LifecycleFlags): void;\n  detached?(flags: LifecycleFlags): void;\n  caching?(flags: LifecycleFlags): void;\n}\n\nexport interface IHydratedViewModel<T extends INode = INode> extends IViewModel<T> {\n  readonly $controller: IController<T, this>;\n}\n\nexport interface ILifecycle {\n  readonly FPS: number;\n  readonly nextFrame: Promise<number>;\n  minFPS: number;\n  maxFPS: number;\n\n  readonly isFlushingRAF: boolean;\n\n  readonly batch: IAutoProcessingQueue<IBatchable>;\n\n  readonly mount: IProcessingQueue<IController>;\n  readonly unmount: IProcessingQueue<IController>;\n\n  readonly bound: IAutoProcessingQueue<IController>;\n  readonly unbound: IAutoProcessingQueue<IController>;\n\n  readonly attached: IAutoProcessingQueue<IController>;\n  readonly detached: IAutoProcessingQueue<IController>;\n\n  enqueueRAF(cb: (flags: LifecycleFlags) => void, context?: unknown, priority?: Priority, once?: boolean): void;\n  enqueueRAF(cb: () => void, context?: unknown, priority?: Priority, once?: boolean): void;\n  dequeueRAF(cb: (flags: LifecycleFlags) => void, context?: unknown): void;\n  dequeueRAF(cb: () => void, context?: unknown): void;\n\n  processRAFQueue(flags: LifecycleFlags, timestamp?: number): void;\n\n  startTicking(): void;\n  stopTicking(): void;\n\n  enableTimeslicing(adaptive?: boolean): void;\n  disableTimeslicing(): void;\n}\n\nclass LinkedCallback {\n  public cb?: (flags: LifecycleFlags) => void;\n  public context?: unknown;\n  public priority: Priority;\n  public once: boolean;\n\n  public next?: LinkedCallback;\n  public prev?: LinkedCallback;\n\n  public unlinked: boolean;\n\n  public get first(): LinkedCallback {\n    let cur: LinkedCallback = this;\n    while (cur.prev !== void 0 && cur.prev.priority === this.priority) {\n      cur = cur.prev;\n    }\n    return cur;\n  }\n\n  public get last(): LinkedCallback {\n    let cur: LinkedCallback = this;\n    while (cur.next !== void 0 && cur.next.priority === this.priority) {\n      cur = cur.next;\n    }\n    return cur;\n  }\n\n  constructor(\n    cb?: (() => void) | ((flags: LifecycleFlags) => void),\n    context: unknown = void 0,\n    priority: Priority = Priority.normal,\n    once: boolean = false,\n  ) {\n    this.cb = cb;\n    this.context = context;\n    this.priority = priority;\n    this.once = once;\n\n    this.next = void 0;\n    this.prev = void 0;\n\n    this.unlinked = false;\n  }\n\n  public equals(fn: (() => void) | ((flags: LifecycleFlags) => void), context?: unknown): boolean {\n    return this.cb === fn && this.context === context;\n  }\n\n  public call(flags: LifecycleFlags): LinkedCallback | undefined {\n    if (this.cb !== void 0) {\n      if (this.context !== void 0) {\n        this.cb.call(this.context, flags);\n      } else {\n        this.cb(flags);\n      }\n    }\n\n    if (this.once) {\n      return this.unlink(true);\n    } else if (this.unlinked) {\n      const next = this.next;\n      this.next = void 0;\n\n      return next;\n    } else {\n      return this.next;\n    }\n  }\n\n  public rotate(): void {\n    if (this.prev === void 0 || this.prev.priority > this.priority) {\n      return;\n    }\n\n    const { first, last } = this;\n\n    const firstPrev = first.prev;\n    const lastNext = last.next;\n    const thisPrev = this.prev;\n\n    this.prev = firstPrev;\n    if (firstPrev !== void 0) {\n      firstPrev.next = this;\n    }\n\n    last.next = first;\n    first.prev = last;\n\n    thisPrev.next = lastNext;\n    if (lastNext !== void 0) {\n      lastNext.prev = thisPrev;\n    }\n  }\n\n  public link(prev: LinkedCallback): void {\n    this.prev = prev;\n\n    if (prev.next !== void 0) {\n      prev.next.prev = this;\n    }\n\n    this.next = prev.next;\n    prev.next = this;\n  }\n\n  public unlink(removeNext: boolean = false): LinkedCallback | undefined {\n    this.unlinked = true;\n    this.cb = void 0;\n    this.context = void 0;\n\n    if (this.prev !== void 0) {\n      this.prev.next = this.next;\n    }\n\n    if (this.next !== void 0) {\n      this.next.prev = this.prev;\n    }\n\n    this.prev = void 0;\n\n    if (removeNext) {\n      const { next } = this;\n      this.next = void 0;\n      return next;\n    }\n\n    return this.next;\n  }\n}\n\nexport const enum Priority {\n  preempt   = 0x8000,\n  high      = 0x7000,\n  bind      = 0x6000,\n  attach    = 0x5000,\n  normal    = 0x4000,\n  propagate = 0x3000,\n  connect   = 0x2000,\n  low       = 0x1000,\n}\n\nexport const ILifecycle = DI.createInterface<ILifecycle>('ILifecycle').withDefault(x => x.singleton(Lifecycle));\n\nconst { min, max } = Math;\n\nexport interface IProcessingQueue<T> {\n  add(requestor: T): void;\n  remove(requestor: T): void;\n  process(flags: LifecycleFlags): void;\n}\n\nexport interface IAutoProcessingQueue<T> extends IProcessingQueue<T> {\n  readonly depth: number;\n  begin(): void;\n  end(flags?: LifecycleFlags): void;\n  inline(fn: () => void, flags?: LifecycleFlags): void;\n}\n\nexport class BoundQueue implements IAutoProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public depth: number;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.depth = 0;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public begin(): void {\n    ++this.depth;\n  }\n\n  public end(flags?: LifecycleFlags): void {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (--this.depth === 0) {\n      this.process(flags);\n    }\n  }\n\n  public inline(fn: () => void, flags?: LifecycleFlags): void {\n    this.begin();\n    fn();\n    this.end(flags);\n  }\n\n  public add(controller: IController): void {\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevBound = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by boundHead not being undefined\n      this.tail!.nextBound = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inBoundQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevBound !== void 0) {\n      controller.prevBound.nextBound = controller.nextBound;\n    }\n    if (controller.nextBound !== void 0) {\n      controller.nextBound.prevBound = controller.prevBound;\n    }\n    controller.prevBound = void 0;\n    controller.nextBound = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevBound;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextBound;\n    }\n    controller.state = (controller.state | State.inBoundQueue) ^ State.inBoundQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inBoundQueue) ^ State.inBoundQueue;\n        cur.bound(flags);\n        next = cur.nextBound;\n        cur.nextBound = void 0;\n        cur.prevBound = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class UnboundQueue implements IAutoProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public depth: number;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.depth = 0;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public begin(): void {\n    ++this.depth;\n  }\n\n  public end(flags?: LifecycleFlags): void {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (--this.depth === 0) {\n      this.process(flags);\n    }\n  }\n\n  public inline(fn: () => void, flags?: LifecycleFlags): void {\n    this.begin();\n    fn();\n    this.end(flags);\n  }\n\n  public add(controller: IController): void {\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevUnbound = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by unboundHead not being undefined\n      this.tail!.nextUnbound = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inUnboundQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevUnbound !== void 0) {\n      controller.prevUnbound.nextUnbound = controller.nextUnbound;\n    }\n    if (controller.nextUnbound !== void 0) {\n      controller.nextUnbound.prevUnbound = controller.prevUnbound;\n    }\n    controller.prevUnbound = void 0;\n    controller.nextUnbound = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevUnbound;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextUnbound;\n    }\n    controller.state = (controller.state | State.inUnboundQueue) ^ State.inUnboundQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inUnboundQueue) ^ State.inUnboundQueue;\n        cur.unbound(flags);\n        next = cur.nextUnbound;\n        cur.nextUnbound = void 0;\n        cur.prevUnbound = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class AttachedQueue implements IAutoProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public depth: number;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.depth = 0;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public begin(): void {\n    ++this.depth;\n  }\n\n  public end(flags?: LifecycleFlags): void {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (--this.depth === 0) {\n      // temporary, until everything else works and we're ready for integrating mount/unmount in the RAF queue\n      this.lifecycle.mount.process(flags);\n      this.process(flags);\n    }\n  }\n\n  public inline(fn: () => void, flags?: LifecycleFlags): void {\n    this.begin();\n    fn();\n    this.end(flags);\n  }\n\n  public add(controller: IController): void {\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevAttached = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by attachedHead not being undefined\n      this.tail!.nextAttached = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inAttachedQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevAttached !== void 0) {\n      controller.prevAttached.nextAttached = controller.nextAttached;\n    }\n    if (controller.nextAttached !== void 0) {\n      controller.nextAttached.prevAttached = controller.prevAttached;\n    }\n    controller.prevAttached = void 0;\n    controller.nextAttached = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevAttached;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextAttached;\n    }\n    controller.state = (controller.state | State.inAttachedQueue) ^ State.inAttachedQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inAttachedQueue) ^ State.inAttachedQueue;\n        cur.attached(flags);\n        next = cur.nextAttached;\n        cur.nextAttached = void 0;\n        cur.prevAttached = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class DetachedQueue implements IAutoProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public depth: number;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.depth = 0;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public begin(): void {\n    ++this.depth;\n  }\n\n  public end(flags?: LifecycleFlags): void {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (--this.depth === 0) {\n      // temporary, until everything else works and we're ready for integrating mount/unmount in the RAF queue\n      this.lifecycle.unmount.process(flags);\n      this.process(flags);\n    }\n  }\n\n  public inline(fn: () => void, flags?: LifecycleFlags): void {\n    this.begin();\n    fn();\n    this.end(flags);\n  }\n\n  public add(controller: IController): void {\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevDetached = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by detachedHead not being undefined\n      this.tail!.nextDetached = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inDetachedQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevDetached !== void 0) {\n      controller.prevDetached.nextDetached = controller.nextDetached;\n    }\n    if (controller.nextDetached !== void 0) {\n      controller.nextDetached.prevDetached = controller.prevDetached;\n    }\n    controller.prevDetached = void 0;\n    controller.nextDetached = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevDetached;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextDetached;\n    }\n    controller.state = (controller.state | State.inDetachedQueue) ^ State.inDetachedQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inDetachedQueue) ^ State.inDetachedQueue;\n        cur.detached(flags);\n        next = cur.nextDetached;\n        cur.nextDetached = void 0;\n        cur.prevDetached = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class MountQueue implements IProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public add(controller: IController): void {\n    if ((controller.state & State.inUnmountQueue) > 0) {\n      this.lifecycle.unmount.remove(controller);\n      console.log(`in unmount queue during mountQueue.add, so removing`, this);\n      return;\n    }\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevMount = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by mountHead not being undefined\n      this.tail!.nextMount = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inMountQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevMount !== void 0) {\n      controller.prevMount.nextMount = controller.nextMount;\n    }\n    if (controller.nextMount !== void 0) {\n      controller.nextMount.prevMount = controller.prevMount;\n    }\n    controller.prevMount = void 0;\n    controller.nextMount = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevMount;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextMount;\n    }\n    controller.state = (controller.state | State.inMountQueue) ^ State.inMountQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    let i = 0;\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inMountQueue) ^ State.inMountQueue;\n        ++i;\n        cur.mount(flags);\n        next = cur.nextMount;\n        cur.nextMount = void 0;\n        cur.prevMount = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class UnmountQueue implements IProcessingQueue<IController> {\n  public readonly lifecycle: ILifecycle;\n\n  public head?: IController;\n  public tail?: IController;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.head = void 0;\n    this.tail = void 0;\n  }\n\n  public add(controller: IController): void {\n    if ((controller.state & State.inMountQueue) > 0) {\n      this.lifecycle.mount.remove(controller);\n      return;\n    }\n    if (this.head === void 0) {\n      this.head = controller;\n    } else {\n      controller.prevUnmount = this.tail;\n      // tslint:disable-next-line: no-non-null-assertion // implied by unmountHead not being undefined\n      this.tail!.nextUnmount = controller;\n    }\n    this.tail = controller;\n    controller.state |= State.inUnmountQueue;\n  }\n\n  public remove(controller: IController): void {\n    if (controller.prevUnmount !== void 0) {\n      controller.prevUnmount.nextUnmount = controller.nextUnmount;\n    }\n    if (controller.nextUnmount !== void 0) {\n      controller.nextUnmount.prevUnmount = controller.prevUnmount;\n    }\n    controller.prevUnmount = void 0;\n    controller.nextUnmount = void 0;\n    if (this.tail === controller) {\n      this.tail = controller.prevUnmount;\n    }\n    if (this.head === controller) {\n      this.head = controller.nextUnmount;\n    }\n    controller.state = (controller.state | State.inUnmountQueue) ^ State.inUnmountQueue;\n  }\n\n  public process(flags: LifecycleFlags): void {\n    let i = 0;\n    while (this.head !== void 0) {\n      let cur = this.head;\n      this.head = this.tail = void 0;\n      let next: IController | undefined;\n      do {\n        cur.state = (cur.state | State.inUnmountQueue) ^ State.inUnmountQueue;\n        ++i;\n        cur.unmount(flags);\n        next = cur.nextUnmount;\n        cur.nextUnmount = void 0;\n        cur.prevUnmount = void 0;\n        // tslint:disable-next-line: no-non-null-assertion // we're checking it for undefined the next line\n        cur = next!;\n      } while (cur !== void 0);\n    }\n  }\n}\n\nexport class BatchQueue implements IAutoProcessingQueue<IBatchable> {\n  public readonly lifecycle: ILifecycle;\n\n  public queue: IBatchable[];\n  public depth: number;\n\n  constructor(lifecycle: ILifecycle) {\n    this.lifecycle = lifecycle;\n\n    this.queue = [];\n    this.depth = 0;\n  }\n\n  public begin(): void {\n    ++this.depth;\n  }\n\n  public end(flags?: LifecycleFlags): void {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (--this.depth === 0) {\n      this.process(flags);\n    }\n  }\n\n  public inline(fn: () => void, flags?: LifecycleFlags): void {\n    this.begin();\n    fn();\n    this.end(flags);\n  }\n\n  public add(requestor: IBatchable): void {\n    this.queue.push(requestor);\n  }\n\n  public remove(requestor: IBatchable): void {\n    const index = this.queue.indexOf(requestor);\n    if (index > -1) {\n      this.queue.splice(index, 1);\n    }\n  }\n\n  public process(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromBatch;\n    while (this.queue.length > 0) {\n      const batch = this.queue.slice();\n      this.queue = [];\n      const { length } = batch;\n      for (let i = 0; i < length; ++i) {\n        batch[i].flushBatch(flags);\n      }\n    }\n  }\n}\n\nexport class Lifecycle {\n  public rafHead: LinkedCallback;\n  public rafTail: LinkedCallback;\n\n  public isFlushingRAF: boolean;\n  public rafRequestId: number;\n  public rafStartTime: number;\n  public isTicking: boolean;\n\n  public readonly batch: IAutoProcessingQueue<IBatchable>;\n\n  public readonly mount: IProcessingQueue<IController>;\n  public readonly unmount: IProcessingQueue<IController>;\n\n  public readonly bound: IAutoProcessingQueue<IController>;\n  public readonly unbound: IAutoProcessingQueue<IController>;\n\n  public readonly attached: IAutoProcessingQueue<IController>;\n  public readonly detached: IAutoProcessingQueue<IController>;\n\n  public minFrameDuration: number;\n  public maxFrameDuration: number;\n  public prevFrameDuration: number;\n\n  public get FPS(): number {\n    return 1000 / this.prevFrameDuration;\n  }\n\n  public get minFPS(): number {\n    return 1000 / this.maxFrameDuration;\n  }\n\n  public set minFPS(fps: number) {\n    this.maxFrameDuration = 1000 / min(max(0, min(this.maxFPS, fps)), 60);\n  }\n\n  public get maxFPS(): number {\n    if (this.minFrameDuration > 0) {\n      return 1000 / this.minFrameDuration;\n    }\n    return 60;\n  }\n\n  public set maxFPS(fps: number) {\n    if (fps >= 60) {\n      this.minFrameDuration = 0;\n    } else {\n      this.minFrameDuration = 1000 / min(max(1, max(this.minFPS, fps)), 60);\n    }\n  }\n\n  public currentTick: number;\n  public nextFrame: Promise<number>;\n  public resolveNextFrame!: (timestamp: number) => void;\n\n  public timeslicingEnabled: boolean;\n  public adaptiveTimeslicing: boolean;\n  public frameDurationFactor: number;\n  public pendingChanges: number;\n\n  private readonly tick: (timestamp: number) => void;\n\n  constructor() {\n    this.rafHead = new LinkedCallback(void 0, void 0, Infinity);\n    this.rafTail = (void 0)!;\n\n    this.currentTick = 0;\n\n    this.isFlushingRAF = false;\n    this.rafRequestId = -1;\n    this.rafStartTime = -1;\n    this.isTicking = false;\n\n    this.batch = new BatchQueue(this);\n\n    this.mount = new MountQueue(this);\n    this.unmount = new UnmountQueue(this);\n\n    this.bound = new BoundQueue(this);\n    this.unbound = new UnboundQueue(this);\n\n    this.attached = new AttachedQueue(this);\n    this.detached = new DetachedQueue(this);\n\n    this.minFrameDuration = 0;\n    this.maxFrameDuration = 1000 / 30;\n    this.prevFrameDuration = 0;\n\n    // tslint:disable-next-line: promise-must-complete\n    this.nextFrame = new Promise(resolve => {\n      this.resolveNextFrame = resolve;\n    });\n\n    this.tick = (timestamp: number) => {\n      this.rafRequestId = -1;\n      if (this.isTicking) {\n        this.processRAFQueue(LifecycleFlags.fromFlush, timestamp);\n        if (this.isTicking && this.rafRequestId === -1 && this.rafHead.next !== void 0) {\n          this.rafRequestId = PLATFORM.requestAnimationFrame(this.tick);\n        }\n        if (++this.currentTick > 1) {\n          this.resolveNextFrame(timestamp);\n          // tslint:disable-next-line: promise-must-complete\n          this.nextFrame = new Promise(resolve => {\n            this.resolveNextFrame = resolve;\n          });\n        }\n      }\n    };\n\n    this.pendingChanges = 0;\n    this.timeslicingEnabled = false;\n    this.adaptiveTimeslicing = false;\n    this.frameDurationFactor = 1;\n  }\n\n  public static register(container: IContainer): IResolver<ILifecycle> {\n    return Registration.singleton(ILifecycle, this).register(container);\n  }\n\n  public startTicking(): void {\n    if (!this.isTicking) {\n      this.isTicking = true;\n      if (this.rafRequestId === -1 && this.rafHead.next !== void 0) {\n        this.rafStartTime = PLATFORM.now();\n        this.rafRequestId = PLATFORM.requestAnimationFrame(this.tick);\n      }\n    } else if (this.rafRequestId === -1 && this.rafHead.next !== void 0) {\n      this.rafStartTime = PLATFORM.now();\n      this.rafRequestId = PLATFORM.requestAnimationFrame(this.tick);\n    }\n  }\n\n  public stopTicking(): void {\n    if (this.isTicking) {\n      this.isTicking = false;\n      if (this.rafRequestId !== -1) {\n        PLATFORM.cancelAnimationFrame(this.rafRequestId);\n        this.rafRequestId = -1;\n      }\n    } else if (this.rafRequestId !== -1) {\n      PLATFORM.cancelAnimationFrame(this.rafRequestId);\n      this.rafRequestId = -1;\n    }\n  }\n\n  public enqueueRAF(cb: (flags: LifecycleFlags) => void, context?: unknown, priority?: Priority, once?: boolean): void;\n  public enqueueRAF(cb: () => void, context?: unknown, priority?: Priority, once?: boolean): void;\n  public enqueueRAF(\n    cb: (() => void) | ((flags: LifecycleFlags) => void),\n    context: unknown = void 0,\n    priority: Priority = Priority.normal,\n    once: boolean = false,\n  ): void {\n    const node = new LinkedCallback(cb, context, priority, once);\n\n    let prev = this.rafHead;\n    let current = prev.next;\n    if (current === void 0) {\n      node.link(prev);\n    } else {\n      do {\n        if (priority > current.priority || (priority === current.priority && once && !current.once)) {\n          node.link(prev);\n          break;\n        }\n\n        prev = current;\n        current = current.next;\n      } while (current !== void 0);\n\n      if (node.prev === void 0) {\n        node.link(prev);\n      }\n    }\n\n    if (node.next === void 0) {\n      this.rafTail = node;\n    }\n\n    this.startTicking();\n  }\n\n  public dequeueRAF(cb: (flags: LifecycleFlags) => void, context?: unknown): void;\n  public dequeueRAF(cb: () => void, context?: unknown): void;\n  public dequeueRAF(\n    cb: (() => void) | ((flags: LifecycleFlags) => void),\n    context: unknown = void 0,\n  ): void {\n    let current = this.rafHead.next;\n    while (current !== void 0) {\n      if (current.equals(cb, context)) {\n        current = current.unlink();\n      } else {\n        current = current.next;\n      }\n    }\n  }\n\n  public processRAFQueue(flags: LifecycleFlags, timestamp: number = PLATFORM.now()): void {\n    if (this.isFlushingRAF) {\n      return;\n    }\n\n    this.isFlushingRAF = true;\n\n    if (timestamp > this.rafStartTime) {\n      const prevFrameDuration = this.prevFrameDuration = timestamp - this.rafStartTime;\n      if (prevFrameDuration + 1 < this.minFrameDuration) {\n        return;\n      }\n\n      let i = 0;\n      if (this.adaptiveTimeslicing && this.maxFrameDuration > 0) {\n        // Clamp the factor between 10 and 0.1 to prevent hanging or unjustified skipping during sudden shifts in workload\n        this.frameDurationFactor = min(max(this.frameDurationFactor * (this.maxFrameDuration / prevFrameDuration), 0.1), 10);\n      } else {\n        this.frameDurationFactor = 1;\n      }\n\n      const deadlineLow = timestamp + max(this.maxFrameDuration * this.frameDurationFactor, 1);\n      const deadlineNormal = timestamp + max(this.maxFrameDuration * this.frameDurationFactor * 5, 5);\n      const deadlineHigh = timestamp + max(this.maxFrameDuration * this.frameDurationFactor * 15, 15);\n      flags |= LifecycleFlags.fromTick;\n      do {\n        this.pendingChanges = 0;\n\n        let current = this.rafHead.next;\n        while (current !== void 0) {\n          // only call performance.now() every 10 calls to reduce the overhead (is this low enough though?)\n          if (++i === 10) {\n            i = 0;\n            if (this.timeslicingEnabled) {\n              const { priority } = current;\n              const now = PLATFORM.now();\n              if (priority <= Priority.low) {\n                if (now >= deadlineLow) {\n                  current.rotate();\n                  if (current.last != void 0 && current.last.next != void 0) {\n                    current = current.last.next;\n                  } else {\n                    break;\n                  }\n                }\n              } else if (priority < Priority.high) {\n                if (now >= deadlineNormal) {\n                  current.rotate();\n                  if (current.last != void 0 && current.last.next != void 0) {\n                    current = current.last.next;\n                  } else {\n                    break;\n                  }\n                }\n              } else {\n                if (now >= deadlineHigh) {\n                  current.rotate();\n                  if (current.last != void 0 && current.last.next != void 0) {\n                    current = current.last.next;\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          current = current.call(flags);\n        }\n      } while (this.pendingChanges > 0);\n\n      if (this.rafHead.next === void 0) {\n        this.stopTicking();\n      }\n    }\n\n    this.rafStartTime = timestamp;\n    this.isFlushingRAF = false;\n  }\n\n  public enableTimeslicing(adaptive: boolean = true): void {\n    this.timeslicingEnabled = true;\n    this.adaptiveTimeslicing = adaptive === true;\n  }\n\n  public disableTimeslicing(): void {\n    this.timeslicingEnabled = false;\n  }\n}\n","import {\n  Class,\n  IIndexable,\n  Tracer\n} from '@aurelia/kernel';\n\nimport { IConnectable } from '../ast';\nimport { LifecycleFlags } from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  IBindingTargetObserver,\n  IProxySubscribable,\n  ISubscribable,\n  ISubscriber\n} from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\n\n// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n\nconst slice = Array.prototype.slice;\n\nconst slotNames: string[] = [];\nconst versionSlotNames: string[] = [];\nlet lastSlot = -1;\nfunction ensureEnoughSlotNames(currentSlot: number): void {\n  if (currentSlot === lastSlot) {\n    lastSlot += 5;\n    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;\n    for (let i = currentSlot + 1; i < ii; ++i) {\n      slotNames[i] = `_observer${i}`;\n      versionSlotNames[i] = `_observerVersion${i}`;\n    }\n  }\n}\nensureEnoughSlotNames(-1);\n\nexport interface IPartialConnectableBinding extends IBinding, ISubscriber {\n  observerLocator: IObserverLocator;\n}\n\nexport interface IConnectableBinding extends IPartialConnectableBinding, IConnectable {\n  id: number;\n  observerSlots: number;\n  version: number;\n  addObserver(observer: ISubscribable | IProxySubscribable): void;\n  unobserve(all?: boolean): void;\n}\n\n/** @internal */\nexport function addObserver(\n  this: IConnectableBinding & { [key: string]: ISubscribable & { [id: string]: number } | number },\n  observer: ISubscribable & { [id: number]: number }\n): void {\n  // find the observer.\n  const observerSlots = this.observerSlots == null ? 0 : this.observerSlots;\n  let i = observerSlots;\n\n  while (i-- && this[slotNames[i]] !== observer);\n\n  // if we are not already observing, put the observer in an open slot and subscribe.\n  if (i === -1) {\n    i = 0;\n    while (this[slotNames[i]]) {\n      i++;\n    }\n    this[slotNames[i]] = observer;\n    observer.subscribe(this);\n    observer[this.id] |= LifecycleFlags.updateTargetInstance;\n    // increment the slot count.\n    if (i === observerSlots) {\n      this.observerSlots = i + 1;\n    }\n  }\n  // set the \"version\" when the observer was used.\n  if (this.version == null) {\n    this.version = 0;\n  }\n  this[versionSlotNames[i]] = this.version;\n  ensureEnoughSlotNames(i);\n}\n\n/** @internal */\nexport function observeProperty(this: IConnectableBinding, flags: LifecycleFlags, obj: IIndexable, propertyName: string): void {\n  if (Tracer.enabled) { Tracer.enter(this['constructor'].name, 'observeProperty', slice.call(arguments)); }\n  const observer = this.observerLocator.getObserver(flags, obj, propertyName) as IBindingTargetObserver;\n  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n   *\n   * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n   */\n  this.addObserver(observer);\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\n/** @internal */\nexport function unobserve(this: IConnectableBinding & { [key: string]: unknown }, all?: boolean): void {\n  const slots = this.observerSlots;\n  let slotName: string;\n  let observer: IBindingTargetObserver & { [key: string]: number };\n  if (all === true) {\n    for (let i = 0; i < slots; ++i) {\n      slotName = slotNames[i];\n      observer = this[slotName] as IBindingTargetObserver & { [key: string]: number };\n      if (observer != null) {\n        this[slotName] = void 0;\n        observer.unsubscribe(this);\n        observer[this.id] &= ~LifecycleFlags.updateTargetInstance;\n      }\n    }\n  } else {\n    const version = this.version;\n    for (let i = 0; i < slots; ++i) {\n      if (this[versionSlotNames[i]] !== version) {\n        slotName = slotNames[i];\n        observer = this[slotName] as IBindingTargetObserver & { [key: string]: number };\n        if (observer != null) {\n          this[slotName] = void 0;\n          observer.unsubscribe(this);\n          observer[this.id] &= ~LifecycleFlags.updateTargetInstance;\n        }\n      }\n    }\n  }\n}\n\ntype DecoratableConnectable<TProto, TClass> = Class<TProto & Partial<IConnectableBinding> & IPartialConnectableBinding, TClass>;\ntype DecoratedConnectable<TProto, TClass> = Class<TProto & IConnectableBinding, TClass>;\n\nfunction connectableDecorator<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> {\n  const proto = target.prototype;\n  if (!proto.hasOwnProperty('observeProperty')) proto.observeProperty = observeProperty;\n  if (!proto.hasOwnProperty('unobserve')) proto.unobserve = unobserve;\n  if (!proto.hasOwnProperty('addObserver')) proto.addObserver = addObserver;\n  return target as DecoratedConnectable<TProto, TClass>;\n}\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass>;\nexport function connectable<TProto, TClass>(target?: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> | typeof connectableDecorator {\n  return target == null ? connectableDecorator : connectableDecorator(target);\n}\n\nlet value = 0;\n\nconnectable.assignIdTo = (instance: IConnectableBinding): void => {\n  instance.id = ++value;\n};\n","import {\n  IServiceLocator,\n  Reporter,\n  Tracer,\n} from '@aurelia/kernel';\n\nimport {\n  IForOfStatement,\n  IsBindingBehavior,\n} from '../ast';\nimport {\n  BindingMode,\n  ExpressionKind,\n  LifecycleFlags,\n  State,\n} from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  AccessorOrObserver,\n  IBindingTargetObserver,\n  IObservable,\n  IScope,\n} from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport {\n  hasBind,\n  hasUnbind,\n} from './ast';\nimport {\n  connectable,\n  IConnectableBinding,\n  IPartialConnectableBinding,\n} from './connectable';\n\nconst slice = Array.prototype.slice;\n\n// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak\nconst { oneTime, toView, fromView } = BindingMode;\n\n// pre-combining flags for bitwise checks is a minor perf tweak\nconst toViewOrOneTime = toView | oneTime;\n\nexport interface Binding extends IConnectableBinding {}\n\n@connectable()\nexport class Binding implements IPartialConnectableBinding {\n  public id!: number;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $scope?: IScope;\n\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IsBindingBehavior | IForOfStatement;\n  public target: IObservable;\n  public targetProperty: string;\n\n  public targetObserver?: AccessorOrObserver;\n\n  public persistentFlags: LifecycleFlags;\n\n  constructor(\n    sourceExpression: IsBindingBehavior | IForOfStatement,\n    target: IObservable,\n    targetProperty: string,\n    mode: BindingMode,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n  ) {\n    connectable.assignIdTo(this);\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$scope = void 0;\n\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n    this.targetObserver = void 0;\n    this.persistentFlags = LifecycleFlags.none;\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.targetObserver!.setValue(value, flags);\n  }\n\n  public updateSource(value: unknown, flags: LifecycleFlags): void {\n    flags |= this.persistentFlags;\n    this.sourceExpression.assign!(flags, this.$scope!, this.locator, value);\n  }\n\n  public handleChange(newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding', 'handleChange', slice.call(arguments)); }\n    if ((this.$state & State.isBound) === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    flags |= this.persistentFlags;\n\n    if ((flags & LifecycleFlags.updateTargetInstance) > 0) {\n      const previousValue = this.targetObserver!.getValue();\n      // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value\n      if (this.sourceExpression.$kind !== ExpressionKind.AccessScope || this.observerSlots > 1) {\n        newValue = this.sourceExpression.evaluate(flags, this.$scope!, this.locator);\n      }\n      if (newValue !== previousValue) {\n        this.updateTarget(newValue, flags);\n      }\n      if ((this.mode & oneTime) === 0) {\n        this.version++;\n        this.sourceExpression.connect(flags, this.$scope!, this);\n        this.unobserve(false);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if ((flags & LifecycleFlags.updateSourceExpression) > 0) {\n      if (newValue !== this.sourceExpression.evaluate(flags, this.$scope!, this.locator)) {\n        this.updateSource(newValue, flags);\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    throw Reporter.error(15, flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Binding', '$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    // Store flags which we can only receive during $bind and need to pass on\n    // to the AST during evaluate/connect/assign\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n\n    this.$scope = scope;\n\n    let sourceExpression = this.sourceExpression;\n    if (hasBind(sourceExpression)) {\n      sourceExpression.bind(flags, scope, this);\n    }\n\n    let targetObserver = this.targetObserver as IBindingTargetObserver | undefined;\n    if (!targetObserver) {\n      if (this.mode & fromView) {\n        targetObserver = this.targetObserver = this.observerLocator.getObserver(flags, this.target, this.targetProperty) as IBindingTargetObserver;\n      } else {\n        targetObserver = this.targetObserver = this.observerLocator.getAccessor(flags, this.target, this.targetProperty) as IBindingTargetObserver;\n      }\n    }\n    if (this.mode !== BindingMode.oneTime && targetObserver.bind) {\n      targetObserver.bind(flags);\n    }\n\n    // during bind, binding behavior might have changed sourceExpression\n    sourceExpression = this.sourceExpression;\n    if (this.mode & toViewOrOneTime) {\n      this.updateTarget(sourceExpression.evaluate(flags, scope, this.locator), flags);\n    }\n    if (this.mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n    if (this.mode & fromView) {\n      targetObserver.subscribe(this);\n      (targetObserver as typeof targetObserver & { [key: string]: number })[this.id] |= LifecycleFlags.updateSourceExpression;\n    }\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Binding', '$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    // clear persistent flags\n    this.persistentFlags = LifecycleFlags.none;\n\n    if (hasUnbind(this.sourceExpression)) {\n      this.sourceExpression.unbind(flags, this.$scope!, this);\n    }\n    this.$scope = void 0;\n\n    if ((this.targetObserver as IBindingTargetObserver).unbind) {\n      (this.targetObserver as IBindingTargetObserver).unbind!(flags);\n    }\n    if ((this.targetObserver as IBindingTargetObserver).unsubscribe) {\n      (this.targetObserver as IBindingTargetObserver).unsubscribe(this);\n      (this.targetObserver as this['targetObserver'] & { [key: string]: number })[this.id] &= ~LifecycleFlags.updateSourceExpression;\n    }\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import {\n  IServiceLocator,\n  Tracer,\n} from '@aurelia/kernel';\n\nimport { IsBindingBehavior } from '../ast';\nimport {\n  LifecycleFlags,\n  State,\n} from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  IAccessor,\n  IBindingContext,\n  IObservable,\n  IScope,\n} from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport {\n  hasBind,\n  hasUnbind,\n} from './ast';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Call extends IConnectableBinding {}\nexport class Call {\n  public $state: State;\n  public $scope?: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public targetObserver: IAccessor;\n\n  constructor(\n    sourceExpression: IsBindingBehavior,\n    target: IObservable | IBindingContext,\n    targetProperty: string,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n  ) {\n    this.$state = State.none;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.targetObserver = observerLocator.getObserver(LifecycleFlags.none, target, targetProperty);\n  }\n\n  public callSource(args: object): unknown {\n    if (Tracer.enabled) { Tracer.enter('Call', 'callSource', slice.call(arguments)); }\n    const overrideContext = this.$scope!.overrideContext;\n    Object.assign(overrideContext, args);\n    const result = this.sourceExpression.evaluate(LifecycleFlags.mustEvaluate, this.$scope!, this.locator);\n\n    for (const prop in args) {\n      Reflect.deleteProperty(overrideContext, prop);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return result;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Call', '$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    if (hasBind(this.sourceExpression)) {\n      this.sourceExpression.bind(flags, scope, this);\n    }\n\n    this.targetObserver.setValue(($args: object) => this.callSource($args), flags);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Call', '$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    if (hasUnbind(this.sourceExpression)) {\n      this.sourceExpression.unbind(flags, this.$scope!, this);\n    }\n\n    this.$scope = void 0;\n    this.targetObserver.setValue(null, flags);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(flags: LifecycleFlags, obj: object, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import {\n  DI,\n  PLATFORM,\n  Reporter,\n} from '@aurelia/kernel';\n\nimport {\n  AnyBindingExpression,\n  IForOfStatement,\n  IInterpolationExpression,\n  IsBindingBehavior,\n} from '../ast';\nimport { ExpressionKind } from '../flags';\nimport {\n  AccessMember,\n  AccessScope,\n  CallMember,\n  CallScope,\n  ForOfStatement,\n  Interpolation,\n  PrimitiveLiteral,\n} from './ast';\n\nexport interface IExpressionParser {\n  cache(expressions: Record<string, AnyBindingExpression>): void;\n  parse(expression: string, bindingType: BindingType.ForCommand): IForOfStatement;\n  parse(expression: string, bindingType: BindingType.Interpolation): IInterpolationExpression;\n  parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  parse(expression: string, bindingType: BindingType): AnyBindingExpression;\n}\n\nexport const IExpressionParser = DI.createInterface<IExpressionParser>('IExpressionParser').withDefault(x => x.singleton(ExpressionParser));\n\n/** @internal */\nexport class ExpressionParser implements IExpressionParser {\n  private readonly expressionLookup: Record<string, IsBindingBehavior>;\n  private readonly forOfLookup: Record<string, IForOfStatement>;\n  private readonly interpolationLookup: Record<string, IInterpolationExpression>;\n\n  constructor() {\n    this.expressionLookup = Object.create(null);\n    this.forOfLookup = Object.create(null);\n    this.interpolationLookup = Object.create(null);\n  }\n\n  public parse(expression: string, bindingType: BindingType.ForCommand): IForOfStatement;\n  public parse(expression: string, bindingType: BindingType.Interpolation): IInterpolationExpression;\n  public parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  public parse(expression: string, bindingType: BindingType): AnyBindingExpression {\n    switch (bindingType) {\n      case BindingType.Interpolation: {\n        let found = this.interpolationLookup[expression];\n        if (found === void 0) {\n          found = this.interpolationLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      case BindingType.ForCommand: {\n        let found = this.forOfLookup[expression];\n        if (found === void 0) {\n          found = this.forOfLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n      default: {\n        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n        // But don't cache it, because empty strings are always invalid for any other type of binding\n        if (expression.length === 0 && (bindingType & (BindingType.BindCommand | BindingType.OneTimeCommand | BindingType.ToViewCommand))) {\n          return PrimitiveLiteral.$empty;\n        }\n        let found = this.expressionLookup[expression];\n        if (found === void 0) {\n          found = this.expressionLookup[expression] = this.parseCore(expression, bindingType);\n        }\n        return found;\n      }\n    }\n  }\n\n  public cache(expressions: Record<string, AnyBindingExpression>): void {\n    const { forOfLookup, expressionLookup, interpolationLookup } = this;\n    for (const expression in expressions) {\n      const expr = expressions[expression];\n      switch (expr.$kind) {\n        case ExpressionKind.Interpolation:\n          interpolationLookup[expression] = expr;\n          break;\n        case ExpressionKind.ForOfStatement:\n          forOfLookup[expression] = expr;\n          break;\n        default:\n          expressionLookup[expression] = expr;\n      }\n    }\n  }\n\n  private parseCore(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  private parseCore(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  private parseCore(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  private parseCore(expression: string, bindingType: BindingType): AnyBindingExpression {\n    try {\n      const parts = expression.split('.');\n      const firstPart = parts[0];\n      let current: AnyBindingExpression;\n\n      if (firstPart.endsWith('()')) {\n        current = new CallScope(firstPart.replace('()', ''), PLATFORM.emptyArray);\n      } else {\n        current = new AccessScope(parts[0]);\n      }\n\n      let index = 1;\n\n      while (index < parts.length) {\n        const currentPart = parts[index];\n\n        if (currentPart.endsWith('()')) {\n          current = new CallMember(current, currentPart.replace('()', ''), PLATFORM.emptyArray);\n        } else {\n          current = new AccessMember(current, parts[index]);\n        }\n\n        index++;\n      }\n\n      return current;\n    } catch (e) {\n      throw Reporter.error(3, e);\n    }\n  }\n}\n\nexport const enum BindingType {\n              None = 0,\n     Interpolation = 0b10000000_0000,\n        IsRef      = 0b01010000_0000,\n        IsIterator = 0b00100000_0000,\n        IsCustom   = 0b00010000_0000,\n        IsFunction = 0b00001000_0000,\n        IsEvent    = 0b00000100_0000,\n        IsProperty = 0b00000010_0000,\n        IsCommand  = 0b00000001_0000,\nIsPropertyCommand  = 0b00000011_0000,\n   IsEventCommand  = 0b00000101_0000,\nDelegationStrategyDelta =     0b0110,\n           Command =          0b1111,\n    OneTimeCommand = 0b00000011_0001,\n     ToViewCommand = 0b00000011_0010,\n   FromViewCommand = 0b00000011_0011,\n     TwoWayCommand = 0b00000011_0100,\n       BindCommand = 0b00000011_0101,\n    TriggerCommand = 0b00000101_0110,\n    CaptureCommand = 0b00000101_0111,\n   DelegateCommand = 0b00000101_1000,\n       CallCommand = 0b00001001_1001,\n    OptionsCommand = 0b00000001_1010,\n        ForCommand = 0b00100001_1011,\n     CustomCommand = 0b00010001_1100\n}\n","import { IServiceLocator } from '@aurelia/kernel';\n\nimport {\n  IExpression,\n  IInterpolationExpression,\n} from '../ast';\nimport {\n  BindingMode,\n  LifecycleFlags,\n  State,\n} from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  IBindingTargetAccessor,\n  IObservable,\n  IScope,\n} from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport {\n  connectable,\n  IConnectableBinding,\n  IPartialConnectableBinding,\n} from './connectable';\n\nconst { toView, oneTime } = BindingMode;\n\nexport class MultiInterpolationBinding implements IBinding {\n  public $state: State;\n  public $scope?: IScope;\n\n  public interpolation: IInterpolationExpression;\n  public observerLocator: IObserverLocator;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public parts: InterpolationBinding[];\n  public target: IObservable;\n  public targetProperty: string;\n\n  constructor(\n    observerLocator: IObserverLocator,\n    interpolation: IInterpolationExpression,\n    target: IObservable,\n    targetProperty: string,\n    mode: BindingMode,\n    locator: IServiceLocator,\n  ) {\n    this.$state = State.none;\n    this.$scope = void 0;\n\n    this.interpolation = interpolation;\n    this.locator = locator;\n    this.mode = mode;\n    this.observerLocator = observerLocator;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    // Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n    // value converters and binding behaviors.\n    // Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,\n    // in which case the renderer will create the TextBinding directly\n    const expressions = interpolation.expressions;\n    const parts = this.parts = Array(expressions.length);\n    for (let i = 0, ii = expressions.length; i < ii; ++i) {\n      parts[i] = new InterpolationBinding(expressions[i], interpolation, target, targetProperty, mode, observerLocator, locator, i === 0);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$bind(flags, scope);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n    this.$scope = void 0;\n    const parts = this.parts;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      parts[i].$unbind(flags);\n    }\n  }\n}\n\nexport interface InterpolationBinding extends IConnectableBinding {}\n\n@connectable()\nexport class InterpolationBinding implements IPartialConnectableBinding {\n  public id!: number;\n  public $scope?: IScope;\n  public $state: State;\n\n  public interpolation: IInterpolationExpression;\n  public isFirst: boolean;\n  public locator: IServiceLocator;\n  public mode: BindingMode;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IObservable;\n  public targetProperty: string;\n\n  public targetObserver: IBindingTargetAccessor;\n\n  // tslint:disable-next-line:parameters-max-number\n  constructor(\n    sourceExpression: IExpression,\n    interpolation: IInterpolationExpression,\n    target: IObservable,\n    targetProperty: string,\n    mode: BindingMode,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n    isFirst: boolean,\n  ) {\n    connectable.assignIdTo(this);\n    this.$state = State.none;\n\n    this.interpolation = interpolation;\n    this.isFirst = isFirst;\n    this.mode = mode;\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n    this.targetProperty = targetProperty;\n\n    this.targetObserver = observerLocator.getAccessor(LifecycleFlags.none, target, targetProperty);\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    this.targetObserver.setValue(value, flags | LifecycleFlags.updateTargetInstance);\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n\n    const previousValue = this.targetObserver.getValue();\n    const newValue = this.interpolation.evaluate(flags, this.$scope!, this.locator);\n    if (newValue !== previousValue) {\n      this.updateTarget(newValue, flags);\n    }\n\n    if ((this.mode & oneTime) === 0) {\n      this.version++;\n      this.sourceExpression.connect(flags, this.$scope!, this);\n      this.unobserve(false);\n    }\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        return;\n      }\n      this.$unbind(flags);\n    }\n\n    this.$state |= State.isBound;\n    this.$scope = scope;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n    if (this.mode !== BindingMode.oneTime && this.targetObserver.bind) {\n      this.targetObserver.bind(flags);\n    }\n\n    // since the interpolation already gets the whole value, we only need to let the first\n    // text binding do the update if there are multiple\n    if (this.isFirst) {\n      this.updateTarget(this.interpolation.evaluate(flags, scope, this.locator), flags);\n    }\n    if (this.mode & toView) {\n      sourceExpression.connect(flags, scope, this);\n    }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!(this.$state & State.isBound)) {\n      return;\n    }\n    this.$state &= ~State.isBound;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope!, this);\n    }\n    if (this.targetObserver.unbind) {\n      this.targetObserver.unbind(flags);\n    }\n\n    this.$scope = void 0;\n    this.unobserve(true);\n  }\n}\n","import {\n  IIndexable,\n  IServiceLocator,\n  Reporter,\n  Tracer,\n} from '@aurelia/kernel';\n\nimport { IExpression } from '../ast';\nimport {\n  LifecycleFlags,\n  State,\n} from '../flags';\nimport {\n  IBinding,\n  ILifecycle,\n} from '../lifecycle';\nimport {\n  IObservable,\n  IScope,\n} from '../observation';\nimport { IObserverLocator } from '../observation/observer-locator';\nimport {\n  connectable,\n  IConnectableBinding,\n  IPartialConnectableBinding,\n} from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface LetBinding extends IConnectableBinding {}\n\n@connectable()\nexport class LetBinding implements IPartialConnectableBinding {\n  public id!: number;\n  public $state: State;\n  public $lifecycle: ILifecycle;\n  public $scope?: IScope;\n\n  public locator: IServiceLocator;\n  public observerLocator: IObserverLocator;\n  public sourceExpression: IExpression;\n  public target: IObservable | null;\n  public targetProperty: string;\n\n  private readonly toViewModel: boolean;\n\n  constructor(\n    sourceExpression: IExpression,\n    targetProperty: string,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n    toViewModel: boolean = false,\n  ) {\n    connectable.assignIdTo(this);\n    this.$state = State.none;\n    this.$lifecycle = locator.get(ILifecycle);\n    this.$scope = void 0;\n\n    this.locator = locator;\n    this.observerLocator = observerLocator;\n    this.sourceExpression = sourceExpression;\n    this.target = null;\n    this.targetProperty = targetProperty;\n\n    this.toViewModel = toViewModel;\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown, flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding', 'handleChange', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    if (flags & LifecycleFlags.updateTargetInstance) {\n      const { target, targetProperty } = this as {target: IIndexable; targetProperty: string};\n      const previousValue: unknown = target[targetProperty];\n      const newValue: unknown = this.sourceExpression.evaluate(flags, this.$scope!, this.locator);\n      if (newValue !== previousValue) {\n        target[targetProperty] = newValue;\n      }\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    throw Reporter.error(15, flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding', '$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n    this.target = (this.toViewModel ? scope.bindingContext : scope.overrideContext) as IIndexable;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.bind) {\n      sourceExpression.bind(flags, scope, this);\n    }\n    // sourceExpression might have been changed during bind\n    this.target[this.targetProperty] = this.sourceExpression.evaluate(LifecycleFlags.fromBind, scope, this.locator);\n    this.sourceExpression.connect(flags, scope, this);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('LetBinding', '$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    const sourceExpression = this.sourceExpression;\n    if (sourceExpression.unbind) {\n      sourceExpression.unbind(flags, this.$scope!, this);\n    }\n    this.$scope = void 0;\n    this.unobserve(true);\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import {\n  IIndexable,\n  IServiceLocator,\n  Tracer,\n} from '@aurelia/kernel';\n\nimport { IsBindingBehavior } from '../ast';\nimport {\n  LifecycleFlags,\n  State,\n} from '../flags';\nimport { IBinding } from '../lifecycle';\nimport {\n  IObservable,\n  IScope,\n} from '../observation';\nimport {\n  hasBind,\n  hasUnbind,\n} from './ast';\nimport { IConnectableBinding } from './connectable';\n\nconst slice = Array.prototype.slice;\n\nexport interface Ref extends IConnectableBinding {}\nexport class Ref implements IBinding {\n  public $state: State;\n  public $scope?: IScope;\n\n  public locator: IServiceLocator;\n  public sourceExpression: IsBindingBehavior;\n  public target: IObservable;\n\n  constructor(\n    sourceExpression: IsBindingBehavior,\n    target: IObservable,\n    locator: IServiceLocator,\n  ) {\n    this.$state = State.none;\n    this.$scope = void 0;\n\n    this.locator = locator;\n    this.sourceExpression = sourceExpression;\n    this.target = target;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: IScope): void {\n    if (Tracer.enabled) { Tracer.enter('Ref', '$bind', slice.call(arguments)); }\n    if (this.$state & State.isBound) {\n      if (this.$scope === scope) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      }\n\n      this.$unbind(flags | LifecycleFlags.fromBind);\n    }\n    // add isBinding flag\n    this.$state |= State.isBinding;\n\n    this.$scope = scope;\n\n    if (hasBind(this.sourceExpression)) {\n      this.sourceExpression.bind(flags, scope, this);\n    }\n\n    this.sourceExpression.assign!(flags, this.$scope, this.locator, this.target);\n\n    // add isBound flag and remove isBinding flag\n    this.$state |= State.isBound;\n    this.$state &= ~State.isBinding;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (Tracer.enabled) { Tracer.enter('Ref', '$unbind', slice.call(arguments)); }\n    if (!(this.$state & State.isBound)) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n    // add isUnbinding flag\n    this.$state |= State.isUnbinding;\n\n    if (this.sourceExpression.evaluate(flags, this.$scope!, this.locator) === this.target) {\n      this.sourceExpression.assign!(flags, this.$scope!, this.locator, null);\n    }\n\n    const sourceExpression = this.sourceExpression;\n    if (hasUnbind(sourceExpression)) {\n      sourceExpression.unbind(flags, this.$scope!, this);\n    }\n\n    this.$scope = void 0;\n\n    // remove isBound and isUnbinding flags\n    this.$state &= ~(State.isBound | State.isUnbinding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public observeProperty(flags: LifecycleFlags, obj: IIndexable, propertyName: string): void {\n    return;\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    return;\n  }\n}\n","import { IIndexable } from '@aurelia/kernel';\nimport { LifecycleFlags } from './flags';\nimport { ILifecycle, Priority } from './lifecycle';\n\n/** @internal */\nexport const enum SubscriberFlags {\n  None            = 0,\n  Subscriber0     = 0b0001,\n  Subscriber1     = 0b0010,\n  Subscriber2     = 0b0100,\n  SubscribersRest = 0b1000,\n  Any             = 0b1111,\n}\n\nexport enum DelegationStrategy {\n  none = 0,\n  capturing = 1,\n  bubbling = 2\n}\n\nexport interface IBatchable {\n  flushBatch(flags: LifecycleFlags): void;\n}\n\nexport interface ISubscriber<TValue = unknown> {\n  id?: number;\n  handleChange(newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void;\n}\n\nexport interface IProxySubscriber<TValue = unknown> {\n  handleProxyChange(key: PropertyKey, newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void;\n}\n\nexport interface ICollectionSubscriber {\n  handleCollectionChange(indexMap: IndexMap, flags: LifecycleFlags): void;\n}\n\nexport interface ISubscribable {\n  subscribe(subscriber: ISubscriber): void;\n  unsubscribe(subscriber: ISubscriber): void;\n}\n\nexport interface IProxySubscribable {\n  subscribeToProxy(subscriber: IProxySubscriber): void;\n  unsubscribeFromProxy(subscriber: IProxySubscriber): void;\n}\n\nexport interface ICollectionSubscribable {\n  subscribeToCollection(subscriber: ICollectionSubscriber): void;\n  unsubscribeFromCollection(subscriber: ICollectionSubscriber): void;\n}\n\nexport interface ISubscriberCollection extends ISubscribable {\n  /** @internal */_subscriberFlags: SubscriberFlags;\n  /** @internal */_subscriber0?: ISubscriber;\n  /** @internal */_subscriber1?: ISubscriber;\n  /** @internal */_subscriber2?: ISubscriber;\n  /** @internal */_subscribersRest?: ISubscriber[];\n\n  callSubscribers(newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void;\n  hasSubscribers(): boolean;\n  hasSubscriber(subscriber: ISubscriber): boolean;\n  removeSubscriber(subscriber: ISubscriber): boolean;\n  addSubscriber(subscriber: ISubscriber): boolean;\n\n  [key: number]: LifecycleFlags;\n}\n\nexport interface IProxySubscriberCollection extends IProxySubscribable {\n  /** @internal */_proxySubscriberFlags: SubscriberFlags;\n  /** @internal */_proxySubscriber0?: IProxySubscriber;\n  /** @internal */_proxySubscriber1?: IProxySubscriber;\n  /** @internal */_proxySubscriber2?: IProxySubscriber;\n  /** @internal */_proxySubscribersRest?: IProxySubscriber[];\n\n  callProxySubscribers(key: PropertyKey, newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void;\n  hasProxySubscribers(): boolean;\n  hasProxySubscriber(subscriber: IProxySubscriber): boolean;\n  removeProxySubscriber(subscriber: IProxySubscriber): boolean;\n  addProxySubscriber(subscriber: IProxySubscriber): boolean;\n\n  [key: number]: LifecycleFlags;\n}\n\nexport interface ICollectionSubscriberCollection extends ICollectionSubscribable {\n  /** @internal */_collectionSubscriberFlags: SubscriberFlags;\n  /** @internal */_collectionSubscriber0?: ICollectionSubscriber;\n  /** @internal */_collectionSubscriber1?: ICollectionSubscriber;\n  /** @internal */_collectionSubscriber2?: ICollectionSubscriber;\n  /** @internal */_collectionSubscribersRest?: ICollectionSubscriber[];\n\n  callCollectionSubscribers(indexMap: IndexMap, flags: LifecycleFlags): void;\n  hasCollectionSubscribers(): boolean;\n  hasCollectionSubscriber(subscriber: ICollectionSubscriber): boolean;\n  removeCollectionSubscriber(subscriber: ICollectionSubscriber): boolean;\n  addCollectionSubscriber(subscriber: ICollectionSubscriber): boolean;\n\n  [key: number]: LifecycleFlags;\n}\n\n/**\n * Describes a complete property observer with an accessor, change tracking fields, normal and batched subscribers\n */\nexport interface IPropertyObserver<TObj extends Record<string, unknown>, TProp extends keyof TObj> extends\n  IAccessor<TObj[TProp]>,\n  IPropertyChangeTracker<TObj, TProp>,\n  ISubscriberCollection,\n  IBatchable {\n  inBatch: boolean;\n  observing: boolean;\n  persistentFlags: LifecycleFlags;\n}\n\n/**\n * An any-typed property observer\n */\nexport type PropertyObserver = IPropertyObserver<IIndexable, string>;\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = unknown[] | Set<unknown> | Map<unknown, unknown>;\ninterface IObservedCollection<T extends CollectionKind = CollectionKind> {\n  $observer?: ICollectionObserver<T>;\n  $raw?: this;\n}\n\n/**\n * An array that is being observed for mutations\n */\nexport interface IObservedArray<T = unknown> extends IObservedCollection<CollectionKind.array>, Array<T> { }\n/**\n * A set that is being observed for mutations\n */\nexport interface IObservedSet<T = unknown> extends IObservedCollection<CollectionKind.set>, Set<T> { }\n/**\n * A map that is being observed for mutations\n */\nexport interface IObservedMap<K = unknown, V = unknown> extends IObservedCollection<CollectionKind.map>, Map<K, V> { }\n/**\n * A collection that is being observed for mutations\n */\nexport type ObservedCollection = IObservedArray | IObservedSet | IObservedMap;\n\nexport const enum CollectionKind {\n  indexed = 0b1000,\n  keyed   = 0b0100,\n  array   = 0b1001,\n  map     = 0b0110,\n  set     = 0b0111\n}\n\nexport type LengthPropertyName<T> =\n  T extends unknown[] ? 'length' :\n  T extends Set<unknown> ? 'size' :\n  T extends Map<unknown, unknown> ? 'size' :\n  never;\n\nexport type CollectionTypeToKind<T> =\n  T extends unknown[] ? CollectionKind.array | CollectionKind.indexed :\n  T extends Set<unknown> ? CollectionKind.set | CollectionKind.keyed :\n  T extends Map<unknown, unknown> ? CollectionKind.map | CollectionKind.keyed :\n  never;\n\nexport type CollectionKindToType<T> =\n  T extends CollectionKind.array ? unknown[] :\n  T extends CollectionKind.indexed ? unknown[] :\n  T extends CollectionKind.map ? Map<unknown, unknown> :\n  T extends CollectionKind.set ? Set<unknown> :\n  T extends CollectionKind.keyed ? Set<unknown> | Map<unknown, unknown> :\n  never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends CollectionKind.array ? IObservedArray :\n  T extends CollectionKind.indexed ? IObservedArray :\n  T extends CollectionKind.map ? IObservedMap :\n  T extends CollectionKind.set ? IObservedSet :\n  T extends CollectionKind.keyed ? IObservedSet | IObservedMap :\n  never;\n\nexport interface IProxyObserver<TObj extends object = object> extends IProxySubscriberCollection {\n  proxy: IProxy<TObj>;\n}\n\nexport type IProxy<TObj extends object = object> = TObj & {\n  $raw: TObj;\n  $observer: IProxyObserver<TObj>;\n};\n\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = unknown> {\n  getValue(): TValue;\n  setValue(newValue: TValue, flags: LifecycleFlags): void;\n}\n\n/**\n * Describes a target observer for to-view bindings (in other words, an observer without the observation).\n */\nexport interface IBindingTargetAccessor<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IAccessor<TValue>,\n          IPropertyChangeTracker<TObj, TProp> {\n  priority?: Priority;\n  bind?(flags: LifecycleFlags): void;\n  unbind?(flags: LifecycleFlags): void;\n}\n\n/**\n * Describes a target observer for from-view or two-way bindings.\n */\nexport interface IBindingTargetObserver<\n  TObj = any,\n  TProp = keyof TObj,\n  TValue = unknown>\n  extends IBindingTargetAccessor<TObj, TProp, TValue>,\n          ISubscribable,\n          ISubscriberCollection {}\n\nexport type AccessorOrObserver = IBindingTargetAccessor | IBindingTargetObserver;\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedItems property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\nexport type IndexMap = number[] & {\n  deletedItems: number[];\n  isIndexMap: true;\n};\n\nexport function copyIndexMap(\n  existing: number[] & { deletedItems?: number[] },\n  deletedItems?: number[],\n): IndexMap {\n  const { length } = existing;\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = existing[i];\n    ++i;\n  }\n  if (deletedItems !== void 0) {\n    arr.deletedItems = deletedItems.slice(0);\n  } else if (existing.deletedItems !== void 0) {\n    arr.deletedItems = existing.deletedItems.slice(0);\n  } else {\n    arr.deletedItems = [];\n  }\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function createIndexMap(length: number = 0): IndexMap {\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = i++;\n  }\n  arr.deletedItems = [];\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function cloneIndexMap(indexMap: IndexMap): IndexMap {\n  const clone = indexMap.slice() as IndexMap;\n  clone.deletedItems = indexMap.deletedItems.slice();\n  clone.isIndexMap = true;\n  return clone;\n}\n\nexport function isIndexMap(value: unknown): value is IndexMap {\n  return value instanceof Array && (value as IndexMap).isIndexMap === true;\n}\n\n/**\n * Describes a type that specifically tracks changes in an object property, or simply something that can have a getter and/or setter\n */\nexport interface IPropertyChangeTracker<TObj extends Record<string, unknown>, TProp = keyof TObj, TValue = unknown> {\n  obj: TObj;\n  propertyKey?: TProp;\n  currentValue?: TValue;\n}\n\nexport interface ICollectionLengthObserver extends IAccessor<number>, IPropertyChangeTracker<unknown[], 'length', number>, ISubscriberCollection {\n  currentValue: number;\n}\n\nexport interface ICollectionSizeObserver extends IAccessor<number>, IPropertyChangeTracker<Set<unknown> | Map<unknown, unknown>, 'size', number>, ISubscriberCollection {\n  currentValue: number;\n}\n\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> {\n  collection: T;\n  indexMap: IndexMap;\n}\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ICollectionSubscriberCollection,\n  IBatchable {\n    inBatch: boolean;\n    lifecycle: ILifecycle;\n    persistentFlags: LifecycleFlags;\n    collection: ObservedCollectionKindToType<T>;\n    lengthObserver: T extends CollectionKind.array ? ICollectionLengthObserver : ICollectionSizeObserver;\n    getLengthObserver(): T extends CollectionKind.array ? ICollectionLengthObserver : ICollectionSizeObserver;\n    notify(): void;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\nexport interface IBindingContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  getObservers?(flags: LifecycleFlags): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IOverrideContext {\n  [key: string]: unknown;\n\n  readonly $synthetic?: true;\n  readonly $observers?: ObserversLookup<IOverrideContext>;\n  readonly bindingContext: IBindingContext;\n  readonly parentOverrideContext: IOverrideContext | null;\n  getObservers(flags: LifecycleFlags): ObserversLookup<IOverrideContext>;\n}\n\nexport interface IScope {\n  readonly bindingContext: IBindingContext;\n  readonly overrideContext: IOverrideContext;\n  /**\n   * Associates replace-part names with the scopes they have access to.\n   */\n  readonly partScopes?: Record<string, IScope | undefined>;\n}\n\n// TODO: currently unused, still need to fix the observersLookup type\nexport interface IObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> { }\n\nexport type ObserversLookup<TObj extends IIndexable = IIndexable, TKey extends keyof TObj =\n  Exclude<keyof TObj, '$synthetic' | '$observers' | 'bindingContext' | 'overrideContext' | 'parentOverrideContext'>> =\n  { [P in TKey]: PropertyObserver; } & {\n    getOrCreate(\n      lifecycle: ILifecycle,\n      flags: LifecycleFlags,\n      obj: IBindingContext | IOverrideContext,\n      key: string,\n    ): PropertyObserver;\n  };\n\nexport type IObservable = IIndexable & {\n  readonly $synthetic?: false;\n  $observers?: IObserversLookup;\n};\n","import { LifecycleFlags } from '../flags';\nimport { ISubscriberCollection } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface CollectionLengthObserver extends ISubscriberCollection {}\n\n@subscriberCollection()\nexport class CollectionLengthObserver {\n  public currentValue: number;\n  public obj: unknown[];\n  constructor(obj: unknown[]) {\n    this.obj = obj;\n    this.currentValue = obj.length;\n  }\n  public getValue(): number {\n    return this.obj.length;\n  }\n  public setValue(newValue: number, flags: LifecycleFlags): void {\n    const { currentValue } = this;\n    if (newValue !== currentValue) {\n      this.currentValue = newValue;\n      this.callSubscribers(newValue, currentValue, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  CollectionKind,\n  createIndexMap,\n  ICollectionObserver,\n  IndexMap,\n  IObservedArray\n} from '../observation';\nimport { CollectionLengthObserver } from './collection-length-observer';\nimport { collectionSubscriberCollection } from './subscriber-collection';\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nfunction sortCompare(x: unknown, y: unknown): number {\n  if (x === y) {\n    return 0;\n  }\n  x = x === null ? 'null' : (x as {}).toString();\n  y = y === null ? 'null' : (y as {}).toString();\n  return (x as {}) < (y as {}) ? -1 : 1;\n}\n\nfunction preSortCompare(x: unknown, y: unknown): number {\n  if (x === void 0) {\n    if (y === void 0) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  if (y === void 0) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction insertionSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let velement, ielement, vtmp, itmp, order;\n  let i, j;\n  for (i = from + 1; i < to; i++) {\n    velement = arr[i];\n    ielement = indexMap[i];\n    for (j = i - 1; j >= from; j--) {\n      vtmp = arr[j];\n      itmp = indexMap[j];\n      order = compareFn(vtmp, velement);\n      if (order > 0) {\n        arr[j + 1] = vtmp;\n        indexMap[j + 1] = itmp;\n      } else {\n        break;\n      }\n    }\n    arr[j + 1] = velement;\n    indexMap[j + 1] = ielement;\n  }\n}\n\n// tslint:disable-next-line:cognitive-complexity\nfunction quickSort(arr: IObservedArray, indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let thirdIndex = 0, i = 0;\n  let v0, v1, v2;\n  let i0, i1, i2;\n  let c01, c02, c12;\n  let vtmp, itmp;\n  let vpivot, ipivot, lowEnd, highStart;\n  let velement, ielement, order, vtopElement;\n\n  // tslint:disable-next-line:no-constant-condition\n  while (true) {\n    if (to - from <= 10) {\n      insertionSort(arr, indexMap, from, to, compareFn);\n      return;\n    }\n\n    // tslint:disable:no-statements-same-line\n    thirdIndex = from + ((to - from) >> 1);\n    v0 = arr[from];                i0 = indexMap[from];\n    v1 = arr[to - 1];              i1 = indexMap[to - 1];\n    v2 = arr[thirdIndex];          i2 = indexMap[thirdIndex];\n    c01 = compareFn(v0, v1);\n    if (c01 > 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v1;                     i0 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    }\n    c02 = compareFn(v0, v2);\n    if (c02 >= 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v2;                     i0 = i2;\n      v2 = v1;                     i2 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    } else {\n      c12 = compareFn(v1, v2);\n      if (c12 > 0) {\n        vtmp = v1;                 itmp = i1;\n        v1 = v2;                   i1 = i2;\n        v2 = vtmp;                 i2 = itmp;\n      }\n    }\n    arr[from] = v0;                indexMap[from] = i0;\n    arr[to - 1] = v2;              indexMap[to - 1] = i2;\n    vpivot = v1;                   ipivot = i1;\n    lowEnd = from + 1;\n    highStart = to - 1;\n    arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n    arr[lowEnd] = vpivot;          indexMap[lowEnd] = ipivot;\n\n    partition: for (i = lowEnd + 1; i < highStart; i++) {\n      velement = arr[i];           ielement = indexMap[i];\n      order = compareFn(velement, vpivot);\n      if (order < 0) {\n        arr[i] = arr[lowEnd];      indexMap[i] = indexMap[lowEnd];\n        arr[lowEnd] = velement;    indexMap[lowEnd] = ielement;\n        lowEnd++;\n      } else if (order > 0) {\n        do {\n          highStart--;\n          // tslint:disable-next-line:triple-equals\n          if (highStart == i) {\n            break partition;\n          }\n          vtopElement = arr[highStart]; order = compareFn(vtopElement, vpivot);\n        } while (order > 0);\n        arr[i] = arr[highStart];   indexMap[i] = indexMap[highStart];\n        arr[highStart] = velement; indexMap[highStart] = ielement;\n        if (order < 0) {\n          velement = arr[i];       ielement = indexMap[i];\n          arr[i] = arr[lowEnd];    indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement;  indexMap[lowEnd] = ielement;\n          lowEnd++;\n        }\n      }\n    }\n    // tslint:enable:no-statements-same-line\n\n    if (to - highStart < lowEnd - from) {\n      quickSort(arr, indexMap, highStart, to, compareFn);\n      to = lowEnd;\n    } else {\n      quickSort(arr, indexMap, from, lowEnd, compareFn);\n      from = highStart;\n    }\n  }\n}\n\nconst proto = Array.prototype as { [K in keyof Array<any>]: Array<any>[K] & { observing?: boolean } };\n\nconst $push = proto.push;\nconst $unshift = proto.unshift;\nconst $pop = proto.pop;\nconst $shift = proto.shift;\nconst $splice = proto.splice;\nconst $reverse = proto.reverse;\nconst $sort = proto.sort;\n\nconst native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };\nconst methods: ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'] = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-array.prototype.push\n  push: function(this: IObservedArray): ReturnType<typeof Array.prototype.push> {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      return $push.apply($this, arguments as IArguments & unknown[]);\n    }\n    const len = $this.length;\n    const argCount = arguments.length;\n    if (argCount === 0) {\n      return len;\n    }\n    $this.length = o.indexMap.length = len + argCount;\n    let i = len;\n    while (i < $this.length) {\n      $this[i] = arguments[i - len];\n      o.indexMap[i] = - 2;\n      i++;\n    }\n    o.notify();\n    return $this.length;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.unshift\n  unshift: function(this: IObservedArray): ReturnType<typeof Array.prototype.unshift>  {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      return $unshift.apply($this, arguments as IArguments & unknown[]);\n    }\n    const argCount = arguments.length;\n    const inserts = new Array(argCount);\n    let i = 0;\n    while (i < argCount) {\n      inserts[i++] = - 2;\n    }\n    $unshift.apply(o.indexMap, inserts);\n    const len = $unshift.apply($this, arguments as IArguments & unknown[]);\n    o.notify();\n    return len;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.pop\n  pop: function(this: IObservedArray): ReturnType<typeof Array.prototype.pop> {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      return $pop.call($this);\n    }\n    const indexMap = o.indexMap;\n    const element = $pop.call($this);\n    // only mark indices as deleted if they actually existed in the original array\n    const index = indexMap.length - 1;\n    if (indexMap[index] > -1) {\n      indexMap.deletedItems!.push(indexMap[index]);\n    }\n    $pop.call(indexMap);\n    o.notify();\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.shift\n  shift: function(this: IObservedArray): ReturnType<typeof Array.prototype.shift> {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      return $shift.call($this);\n    }\n    const indexMap = o.indexMap;\n    const element = $shift.call($this);\n    // only mark indices as deleted if they actually existed in the original array\n    if (indexMap[0] > -1) {\n      indexMap.deletedItems!.push(indexMap[0]);\n    }\n    $shift.call(indexMap);\n    o.notify();\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.splice\n  splice: function(this: IObservedArray, start: number, deleteCount?: number): ReturnType<typeof Array.prototype.splice> {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      return $splice.apply($this, arguments as IArguments & [number, number, ...any[]]);\n    }\n    const indexMap = o.indexMap;\n    if (deleteCount! > 0) {\n      let i = isNaN(start) ? 0 : start;\n      const to = i + deleteCount!;\n      while (i < to) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems!.push(indexMap[i]);\n        }\n        i++;\n      }\n    }\n    const argCount = arguments.length;\n    if (argCount > 2) {\n      const itemCount = argCount - 2;\n      const inserts = new Array(itemCount);\n      let i = 0;\n      while (i < itemCount) {\n        inserts[i++] = - 2;\n      }\n      $splice.call(indexMap, start, deleteCount!, ...inserts);\n    } else if (argCount === 2) {\n      $splice.call(indexMap, start, deleteCount!);\n    }\n    const deleted = $splice.apply($this, arguments as IArguments & [number, number, ...any[]]);\n    o.notify();\n    return deleted;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n  reverse: function(this: IObservedArray): ReturnType<typeof Array.prototype.reverse> {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      $reverse.call($this);\n      return this;\n    }\n    const len = $this.length;\n    const middle = (len / 2) | 0;\n    let lower = 0;\n    // tslint:disable:no-statements-same-line\n    while (lower !== middle) {\n      const upper = len - lower - 1;\n      const lowerValue = $this[lower];  const lowerIndex = o.indexMap[lower];\n      const upperValue = $this[upper];  const upperIndex = o.indexMap[upper];\n      $this[lower] = upperValue;        o.indexMap[lower] = upperIndex;\n      $this[upper] = lowerValue;        o.indexMap[upper] = lowerIndex;\n      lower++;\n    }\n    // tslint:enable:no-statements-same-line\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.sort\n  // https://github.com/v8/v8/blob/master/src/js/array.js\n  sort: function(this: IObservedArray, compareFn?: (a: unknown, b: unknown) => number): IObservedArray {\n    let $this = this;\n    if ($this.$raw !== void 0) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === void 0) {\n      $sort.call($this, compareFn);\n      return this;\n    }\n    const len = $this.length;\n    if (len < 2) {\n      return this;\n    }\n    quickSort($this, o.indexMap, 0, len, preSortCompare);\n    let i = 0;\n    while (i < len) {\n      if ($this[i] === void 0) {\n        break;\n      }\n      i++;\n    }\n    if (compareFn === void 0 || typeof compareFn !== 'function'/*spec says throw a TypeError, should we do that too?*/) {\n      compareFn = sortCompare;\n    }\n    quickSort($this, o.indexMap, 0, i, compareFn);\n    o.notify();\n    return this;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Reflect.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableArrayObservationCalled = false;\n\nexport function enableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nexport function disableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface ArrayObserver extends ICollectionObserver<CollectionKind.array> {}\n\n@collectionSubscriberCollection()\nexport class ArrayObserver {\n  public inBatch: boolean;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, array: IObservedArray) {\n    if (Tracer.enabled) { Tracer.enter('ArrayObserver', 'constructor', slice.call(arguments)); }\n\n    if (!enableArrayObservationCalled) {\n      enableArrayObservationCalled = true;\n      enableArrayObservation();\n    }\n\n    this.inBatch = false;\n\n    this.collection = array;\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n    this.indexMap = createIndexMap(array.length);\n    this.lifecycle = lifecycle;\n    this.lengthObserver = (void 0)!;\n\n    Reflect.defineProperty(\n      array,\n      '$observer',\n      {\n        value: this,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n    );\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public notify(): void {\n    if (this.lifecycle.batch.depth > 0) {\n      if (!this.inBatch) {\n        this.inBatch = true;\n        this.lifecycle.batch.add(this);\n      }\n    } else {\n      this.flushBatch(LifecycleFlags.none);\n    }\n  }\n\n  public getLengthObserver(): CollectionLengthObserver {\n    if (this.lengthObserver === void 0) {\n      this.lengthObserver = new CollectionLengthObserver(this.collection);\n    }\n    return this.lengthObserver;\n  }\n\n  public flushBatch(flags: LifecycleFlags): void {\n    this.inBatch = false;\n    const { indexMap, collection } = this;\n    const { length } = collection;\n    this.indexMap = createIndexMap(length);\n    this.callCollectionSubscribers(indexMap, LifecycleFlags.updateTargetInstance | this.persistentFlags);\n    if (this.lengthObserver !== void 0) {\n      this.lengthObserver.setValue(length, LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n\nexport function getArrayObserver(flags: LifecycleFlags, lifecycle: ILifecycle, array: IObservedArray): ArrayObserver {\n  if (array.$observer === void 0) {\n    array.$observer = new ArrayObserver(flags, lifecycle, array);\n  }\n  return array.$observer;\n}\n","import { LifecycleFlags } from '../flags';\nimport { ISubscriberCollection } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface CollectionSizeObserver extends ISubscriberCollection {}\n\n@subscriberCollection()\nexport class CollectionSizeObserver {\n  public currentValue: number;\n  public obj: Set<unknown> | Map<unknown, unknown>;\n  constructor(obj: Set<unknown> | Map<unknown, unknown>) {\n    this.obj = obj;\n    this.currentValue = obj.size;\n  }\n  public getValue(): number {\n    return this.obj.size;\n  }\n  public setValue(newValue: number, flags: LifecycleFlags): void {\n    const { currentValue } = this;\n    if (newValue !== currentValue) {\n      this.currentValue = newValue;\n      this.callSubscribers(newValue, currentValue, flags | LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  CollectionKind,\n  createIndexMap,\n  ICollectionObserver,\n  IObservedMap\n} from '../observation';\nimport { CollectionSizeObserver } from './collection-size-observer';\nimport { collectionSubscriberCollection } from './subscriber-collection';\n\nconst proto = Map.prototype as { [K in keyof Map<any, any>]: Map<any, any>[K] & { observing?: boolean } };\n\nconst $set = proto.set;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { set: $set, clear: $clear, delete: $delete };\nconst methods: ['set', 'clear', 'delete'] = ['set', 'clear', 'delete'];\n\n// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-map.prototype.map\n  set: function(this: IObservedMap, key: unknown, value: unknown): ReturnType<typeof $set> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $set.call($this, key, value);\n      return this;\n    }\n    const oldSize = $this.size;\n    $set.call($this, key, value);\n    const newSize = $this.size;\n    if (newSize === oldSize) {\n      let i = 0;\n      for (const entry of $this.entries()) {\n        if (entry[0] === key) {\n          if (entry[1] !== value) {\n            o.indexMap[i] = -2;\n          }\n          return this;\n        }\n        i++;\n      }\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.clear\n  clear: function(this: IObservedMap): ReturnType<typeof $clear>  {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $clear.call($this);\n    }\n    const size = $this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      for (const entry of $this.keys()) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems!.push(indexMap[i]);\n        }\n        i++;\n      }\n      $clear.call($this);\n      indexMap.length = 0;\n      o.notify();\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.delete\n  delete: function(this: IObservedMap, value: unknown): ReturnType<typeof $delete> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $delete.call($this, value);\n    }\n    const size = $this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of $this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems!.push(indexMap[i]);\n        }\n        indexMap.splice(i, 1);\n        return $delete.call($this, value);\n      }\n      i++;\n    }\n    o.notify();\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Reflect.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableMapObservationCalled = false;\n\nexport function enableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nexport function disableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface MapObserver extends ICollectionObserver<CollectionKind.map> {}\n\n@collectionSubscriberCollection()\nexport class MapObserver {\n  public inBatch: boolean;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, map: IObservedMap) {\n    if (Tracer.enabled) { Tracer.enter('MapObserver', 'constructor', slice.call(arguments)); }\n\n    if (!enableMapObservationCalled) {\n      enableMapObservationCalled = true;\n      enableMapObservation();\n    }\n\n    this.inBatch = false;\n\n    this.collection = map;\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n    this.indexMap = createIndexMap(map.size);\n    this.lifecycle = lifecycle;\n    this.lengthObserver = (void 0)!;\n\n    map.$observer = this;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public notify(): void {\n    if (this.lifecycle.batch.depth > 0) {\n      if (!this.inBatch) {\n        this.inBatch = true;\n        this.lifecycle.batch.add(this);\n      }\n    } else {\n      this.flushBatch(LifecycleFlags.none);\n    }\n  }\n\n  public getLengthObserver(): CollectionSizeObserver {\n    if (this.lengthObserver === void 0) {\n      this.lengthObserver = new CollectionSizeObserver(this.collection);\n    }\n    return this.lengthObserver;\n  }\n\n  public flushBatch(flags: LifecycleFlags): void {\n    this.inBatch = false;\n    const { indexMap, collection } = this;\n    const { size } = collection;\n    this.indexMap = createIndexMap(size);\n    this.callCollectionSubscribers(indexMap, LifecycleFlags.updateTargetInstance | this.persistentFlags);\n    if (this.lengthObserver !== void 0) {\n      this.lengthObserver.setValue(size, LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n\nexport function getMapObserver(flags: LifecycleFlags, lifecycle: ILifecycle, map: IObservedMap): MapObserver {\n  if (map.$observer === void 0) {\n    map.$observer = new MapObserver(flags, lifecycle, map);\n  }\n  return map.$observer;\n}\n","import { Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { CollectionKind, createIndexMap, ICollectionObserver, IObservedSet } from '../observation';\nimport { CollectionSizeObserver } from './collection-size-observer';\nimport { collectionSubscriberCollection } from './subscriber-collection';\n\nconst proto = Set.prototype as { [K in keyof Set<any>]: Set<any>[K] & { observing?: boolean } };\n\nconst $add = proto.add;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { add: $add, clear: $clear, delete: $delete };\nconst methods: ['add', 'clear', 'delete'] = ['add', 'clear', 'delete'];\n\n// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-set.prototype.add\n  add: function(this: IObservedSet, value: unknown): ReturnType<typeof $add> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      $add.call($this, value);\n      return this;\n    }\n    const oldSize = $this.size;\n    $add.call($this, value);\n    const newSize = $this.size;\n    if (newSize === oldSize) {\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.clear\n  clear: function(this: IObservedSet): ReturnType<typeof $clear>  {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $clear.call($this);\n    }\n    const size = $this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      for (const entry of $this.keys()) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems!.push(indexMap[i]);\n        }\n        i++;\n      }\n      $clear.call($this);\n      indexMap.length = 0;\n      o.notify();\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.delete\n  delete: function(this: IObservedSet, value: unknown): ReturnType<typeof $delete> {\n    let $this = this;\n    if ($this.$raw !== undefined) {\n      $this = $this.$raw;\n    }\n    const o = $this.$observer;\n    if (o === undefined) {\n      return $delete.call($this, value);\n    }\n    const size = $this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of $this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems!.push(indexMap[i]);\n        }\n        indexMap.splice(i, 1);\n        return $delete.call($this, value);\n      }\n      i++;\n    }\n    o.notify();\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nconst def = Reflect.defineProperty;\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableSetObservationCalled = false;\n\nexport function enableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nexport function disableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface SetObserver extends ICollectionObserver<CollectionKind.set> {}\n\n@collectionSubscriberCollection()\nexport class SetObserver {\n  public inBatch: boolean;\n\n  constructor(flags: LifecycleFlags, lifecycle: ILifecycle, observedSet: IObservedSet) {\n    if (Tracer.enabled) { Tracer.enter('SetObserver', 'constructor', slice.call(arguments)); }\n\n    if (!enableSetObservationCalled) {\n      enableSetObservationCalled = true;\n      enableSetObservation();\n    }\n\n    this.inBatch = false;\n\n    this.collection = observedSet;\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n    this.indexMap = createIndexMap(observedSet.size);\n    this.lifecycle = lifecycle;\n    this.lengthObserver = (void 0)!;\n\n    observedSet.$observer = this;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public notify(): void {\n    if (this.lifecycle.batch.depth > 0) {\n      if (!this.inBatch) {\n        this.inBatch = true;\n        this.lifecycle.batch.add(this);\n      }\n    } else {\n      this.flushBatch(LifecycleFlags.none);\n    }\n  }\n\n  public getLengthObserver(): CollectionSizeObserver {\n    if (this.lengthObserver === void 0) {\n      this.lengthObserver = new CollectionSizeObserver(this.collection);\n    }\n    return this.lengthObserver;\n  }\n\n  public flushBatch(flags: LifecycleFlags): void {\n    this.inBatch = false;\n    const { indexMap, collection } = this;\n    const { size } = collection;\n    this.indexMap = createIndexMap(size);\n    this.callCollectionSubscribers(indexMap, LifecycleFlags.updateTargetInstance | this.persistentFlags);\n    if (this.lengthObserver !== void 0) {\n      this.lengthObserver.setValue(size, LifecycleFlags.updateTargetInstance);\n    }\n  }\n}\n\nexport function getSetObserver(flags: LifecycleFlags, lifecycle: ILifecycle, observedSet: IObservedSet): SetObserver {\n  if (observedSet.$observer === void 0) {\n    observedSet.$observer = new SetObserver(flags, lifecycle, observedSet);\n  }\n  return observedSet.$observer;\n}\n","import { Constructable, PLATFORM, Reporter, Tracer } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  IBindingTargetObserver,\n  ICollectionSubscribable,\n  IObservable,\n  ISubscribable,\n  ISubscriber\n} from '../observation';\nimport { IDirtyChecker } from './dirty-checker';\nimport { IObserverLocator } from './observer-locator';\nimport { subscriberCollection } from './subscriber-collection';\n\nconst slice = Array.prototype.slice;\n\nexport interface ComputedOverrides {\n  // Indicates that a getter doesn't need to re-calculate its dependencies after the first observation.\n  static?: boolean;\n\n  // Indicates that the getter of a getter/setter pair can change its value based on side-effects outside the setter.\n  volatile?: boolean;\n}\n\nexport type ComputedLookup = { computed?: Record<string, ComputedOverrides> };\n\nexport function computed(config: ComputedOverrides): PropertyDecorator {\n  return function (target: Constructable & ComputedLookup, key: string): void {\n    (target.computed || (target.computed = {}))[key] = config;\n  } as PropertyDecorator;\n}\n\nconst computedOverrideDefaults: ComputedOverrides = { static: false, volatile: false };\n\n/* @internal */\nexport function createComputedObserver(\n  flags: LifecycleFlags,\n  observerLocator: IObserverLocator,\n  dirtyChecker: IDirtyChecker,\n  lifecycle: ILifecycle,\n  instance: IObservable & { constructor: IObservable & ComputedLookup },\n  propertyName: string,\n  descriptor: PropertyDescriptor): IBindingTargetObserver {\n\n  if (descriptor.configurable === false) {\n    return dirtyChecker.createProperty(instance, propertyName);\n  }\n\n  if (descriptor.get) {\n    const overrides = instance.constructor.computed && instance.constructor.computed[propertyName] || computedOverrideDefaults;\n\n    if (descriptor.set) {\n      if (overrides.volatile) {\n        return new GetterObserver(flags, overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n      }\n      return new CustomSetterObserver(instance, propertyName, descriptor);\n    }\n    return new GetterObserver(flags, overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n  }\n  throw Reporter.error(18, propertyName);\n}\n\nexport interface CustomSetterObserver extends IBindingTargetObserver { }\n\n// Used when the getter is dependent solely on changes that happen within the setter.\n@subscriberCollection()\nexport class CustomSetterObserver implements CustomSetterObserver {\n  public readonly obj: IObservable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  private readonly descriptor: PropertyDescriptor;\n  private observing: boolean;\n\n  constructor(obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    this.currentValue = this.oldValue = undefined;\n    this.descriptor = descriptor;\n    this.observing = false;\n  }\n\n  public setValue(newValue: unknown): void {\n    if (Tracer.enabled) { Tracer.enter('CustomSetterObserver', 'setValue', slice.call(arguments)); }\n    // tslint:disable-next-line: no-non-null-assertion // Non-null is implied because descriptors without setters won't end up here\n    this.descriptor.set!.call(this.obj, newValue);\n    if (this.currentValue !== newValue) {\n      this.oldValue = this.currentValue;\n      this.currentValue = newValue;\n      this.callSubscribers(newValue, this.oldValue, LifecycleFlags.updateTargetInstance);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (!this.observing) {\n      this.convertProperty();\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    this.removeSubscriber(subscriber);\n  }\n\n  public convertProperty(): void {\n    if (Tracer.enabled) { Tracer.enter('CustomSetterObserver', 'convertProperty', slice.call(arguments)); }\n    this.observing = true;\n    this.currentValue = this.obj[this.propertyKey];\n\n    const set = (newValue: unknown): void => { this.setValue(newValue); };\n    Reflect.defineProperty(this.obj, this.propertyKey, { set });\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport interface GetterObserver extends IBindingTargetObserver { }\n\n// Used when there is no setter, and the getter is dependent on other properties of the object;\n// Used when there is a setter but the value of the getter can change based on properties set outside of the setter.\n/** @internal */\n@subscriberCollection()\nexport class GetterObserver implements GetterObserver {\n  public readonly obj: IObservable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  private readonly proxy: ProxyHandler<object>;\n  private readonly propertyDeps: ISubscribable[];\n  private readonly collectionDeps: ICollectionSubscribable[];\n  private readonly overrides: ComputedOverrides;\n  private readonly descriptor: PropertyDescriptor;\n  private subscriberCount: number;\n  private isCollecting: boolean;\n\n  constructor(flags: LifecycleFlags, overrides: ComputedOverrides, obj: IObservable, propertyKey: string, descriptor: PropertyDescriptor, observerLocator: IObserverLocator, lifecycle: ILifecycle) {\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    this.isCollecting = false;\n    this.currentValue = this.oldValue = undefined;\n\n    this.propertyDeps = [];\n    this.collectionDeps = [];\n    this.overrides = overrides;\n    this.subscriberCount = 0;\n    this.descriptor = descriptor;\n    this.proxy = new Proxy(obj, createGetterTraps(flags, observerLocator, this));\n\n    const get = (): unknown => this.getValue();\n    Reflect.defineProperty(obj, propertyKey, { get });\n  }\n\n  public addPropertyDep(subscribable: ISubscribable): void {\n    if (this.propertyDeps.indexOf(subscribable) === -1) {\n      this.propertyDeps.push(subscribable);\n    }\n  }\n\n  public addCollectionDep(subscribable: ICollectionSubscribable): void {\n    if (this.collectionDeps.indexOf(subscribable) === -1) {\n      this.collectionDeps.push(subscribable);\n    }\n  }\n\n  public getValue(): unknown {\n    if (Tracer.enabled) { Tracer.enter('GetterObserver', 'getValue', slice.call(arguments)); }\n    if (this.subscriberCount === 0 || this.isCollecting) {\n      // tslint:disable-next-line: no-non-null-assertion // Non-null is implied because descriptors without getters won't end up here\n      this.currentValue = Reflect.apply(this.descriptor.get!, this.proxy, PLATFORM.emptyArray);\n    } else {\n      // tslint:disable-next-line: no-non-null-assertion // Non-null is implied because descriptors without getters won't end up here\n      this.currentValue = Reflect.apply(this.descriptor.get!, this.obj, PLATFORM.emptyArray);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.currentValue;\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    this.addSubscriber(subscriber);\n    if (++this.subscriberCount === 1) {\n      this.getValueAndCollectDependencies(true);\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    this.removeSubscriber(subscriber);\n    if (--this.subscriberCount === 0) {\n      this.unsubscribeAllDependencies();\n    }\n  }\n\n  public handleChange(): void {\n    const oldValue = this.currentValue;\n    const newValue = this.getValueAndCollectDependencies(false);\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public handleCollectionChange(): void {\n    const oldValue = this.currentValue;\n    const newValue = this.getValueAndCollectDependencies(false);\n    if (oldValue !== newValue) {\n      this.callSubscribers(newValue, oldValue, LifecycleFlags.updateTargetInstance);\n    }\n  }\n\n  public getValueAndCollectDependencies(requireCollect: boolean): unknown {\n    if (Tracer.enabled) { Tracer.enter('GetterObserver', 'getValueAndCollectDependencies', slice.call(arguments)); }\n    const dynamicDependencies = !this.overrides.static || requireCollect;\n\n    if (dynamicDependencies) {\n      this.unsubscribeAllDependencies();\n      this.isCollecting = true;\n    }\n\n    this.currentValue = this.getValue();\n\n    if (dynamicDependencies) {\n      this.propertyDeps.forEach(x => { x.subscribe(this); });\n      this.collectionDeps.forEach(x => { x.subscribeToCollection(this); });\n      this.isCollecting = false;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return this.currentValue;\n  }\n\n  public doNotCollect(key: PropertyKey): boolean {\n    return !this.isCollecting || key === '$observers';\n  }\n\n  private unsubscribeAllDependencies(): void {\n    this.propertyDeps.forEach(x => { x.unsubscribe(this); });\n    this.propertyDeps.length = 0;\n    this.collectionDeps.forEach(x => { x.unsubscribeFromCollection(this); });\n    this.collectionDeps.length = 0;\n  }\n}\n\nconst toStringTag = Object.prototype.toString;\n\nfunction createGetterTraps(flags: LifecycleFlags, observerLocator: IObserverLocator, observer: GetterObserver): ProxyHandler<object> {\n  if (Tracer.enabled) { Tracer.enter('computed', 'createGetterTraps', slice.call(arguments)); }\n  const traps = {\n    get: function(target: object, key: PropertyKey, receiver?: unknown): unknown {\n      if (Tracer.enabled) { Tracer.enter('computed', 'get', slice.call(arguments)); }\n      if (observer.doNotCollect(key)) {\n        if (Tracer.enabled) { Tracer.leave(); }\n        return Reflect.get(target, key, receiver);\n      }\n\n      // The length and iterator properties need to be invoked on the original object (for Map and Set\n      // at least) or they will throw.\n      switch (toStringTag.call(target)) {\n        case '[object Array]':\n          observer.addCollectionDep(observerLocator.getArrayObserver(flags, target as unknown[]));\n          if (key === 'length') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        case '[object Map]':\n          observer.addCollectionDep(observerLocator.getMapObserver(flags, target as Map<unknown, unknown>));\n          if (key === 'size') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        case '[object Set]':\n          observer.addCollectionDep(observerLocator.getSetObserver(flags, target as Set<unknown>));\n          if (key === 'size') {\n            if (Tracer.enabled) { Tracer.leave(); }\n            return Reflect.get(target, key, target);\n          }\n        default:\n          observer.addPropertyDep(observerLocator.getObserver(flags, target, key as string) as IBindingTargetObserver);\n      }\n\n      if (Tracer.enabled) { Tracer.leave(); }\n      return proxyOrValue(flags, target, key, observerLocator, observer);\n    }\n  };\n  if (Tracer.enabled) { Tracer.leave(); }\n  return traps;\n}\n\nfunction proxyOrValue(flags: LifecycleFlags, target: object, key: PropertyKey, observerLocator: IObserverLocator, observer: GetterObserver): ProxyHandler<object> {\n  const value = Reflect.get(target, key, target);\n  if (typeof value === 'function') {\n    // tslint:disable-next-line: ban-types // We need Function's bind() method here\n    return (target as { [key: string]: Function })[key as string].bind(target);\n  }\n  if (typeof value !== 'object' || value === null) {\n    return value;\n  }\n  return new Proxy(value, createGetterTraps(flags, observerLocator, observer));\n}\n","import { DI, PLATFORM, Reporter, Tracer, InjectArray } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { IBindingTargetObserver, IObservable, ISubscriber } from '../observation';\nimport { subscriberCollection } from './subscriber-collection';\nimport { ILifecycle, Priority } from '../lifecycle';\n\nexport interface IDirtyChecker {\n  createProperty(obj: IObservable, propertyName: string): IBindingTargetObserver;\n  addProperty(property: DirtyCheckProperty): void;\n  removeProperty(property: DirtyCheckProperty): void;\n}\n\nexport const IDirtyChecker = DI.createInterface<IDirtyChecker>('IDirtyChecker').withDefault(x => x.singleton(DirtyChecker));\n\nexport const DirtyCheckSettings = {\n  /**\n   * Default: `6`\n   *\n   * Adjust the global dirty check frequency.\n   * Measures in \"frames per check\", such that (given an FPS of 60):\n   * - A value of 1 will result in 60 dirty checks per second\n   * - A value of 6 will result in 10 dirty checks per second\n   */\n  framesPerCheck: 6,\n  /**\n   * Default: `false`\n   *\n   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking\n   * or an adapter, will simply not be observed.\n   */\n  disabled: false,\n  /**\n   * Default: `true`\n   *\n   * Log a warning message to the console if a property is being dirty-checked.\n   */\n  warn: true,\n  /**\n   * Default: `false`\n   *\n   * Throw an error if a property is being dirty-checked.\n   */\n  throw: false,\n  /**\n   * Resets all dirty checking settings to the framework's defaults.\n   */\n  resetToDefault(): void {\n    this.framesPerCheck = 6;\n    this.disabled = false;\n    this.warn = true;\n    this.throw = false;\n  }\n};\n\n/** @internal */\nexport class DirtyChecker {\n  public static readonly inject: InjectArray = [ILifecycle];\n\n  private readonly tracked: DirtyCheckProperty[];\n  private readonly lifecycle: ILifecycle;\n\n  private elapsedFrames: number;\n\n  public constructor(lifecycle: ILifecycle) {\n    this.elapsedFrames = 0;\n    this.tracked = [];\n    this.lifecycle = lifecycle;\n  }\n\n  public createProperty(obj: IObservable, propertyName: string): DirtyCheckProperty {\n    if (DirtyCheckSettings.throw) {\n      throw Reporter.error(800, propertyName); // TODO: create/organize error code\n    }\n    if (DirtyCheckSettings.warn) {\n      Reporter.write(801, propertyName);\n    }\n    return new DirtyCheckProperty(this, obj, propertyName);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    this.tracked.push(property);\n\n    if (this.tracked.length === 1) {\n      this.lifecycle.enqueueRAF(this.check, this, Priority.low);\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    this.tracked.splice(this.tracked.indexOf(property), 1);\n    if (this.tracked.length === 0) {\n      this.lifecycle.dequeueRAF(this.check, this);\n    }\n  }\n\n  public check(delta?: number): void {\n    if (DirtyCheckSettings.disabled) {\n      return;\n    }\n    if (++this.elapsedFrames < DirtyCheckSettings.framesPerCheck) {\n      return;\n    }\n    this.elapsedFrames = 0;\n    const tracked = this.tracked;\n    const len = tracked.length;\n    let current: DirtyCheckProperty;\n    let i = 0;\n    for (; i < len; ++i) {\n      current = tracked[i];\n      if (current.isDirty()) {\n        current.flush(LifecycleFlags.fromTick);\n      }\n    }\n  }\n}\n\nconst slice = Array.prototype.slice;\n\nexport interface DirtyCheckProperty extends IBindingTargetObserver { }\n\n@subscriberCollection()\nexport class DirtyCheckProperty implements DirtyCheckProperty {\n  public obj: IObservable;\n  public oldValue: unknown;\n  public propertyKey: string;\n\n  private readonly dirtyChecker: IDirtyChecker;\n\n  constructor(dirtyChecker: IDirtyChecker, obj: IObservable, propertyKey: string) {\n    if (Tracer.enabled) { Tracer.enter('DirtyCheckProperty', 'constructor', slice.call(arguments)); }\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n\n    this.dirtyChecker = dirtyChecker;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public isDirty(): boolean {\n    return this.oldValue !== this.obj[this.propertyKey];\n  }\n\n  public flush(flags: LifecycleFlags): void {\n    const oldValue = this.oldValue;\n    const newValue = this.obj[this.propertyKey];\n\n    this.callSubscribers(newValue, oldValue, flags | LifecycleFlags.updateTargetInstance);\n\n    this.oldValue = newValue;\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (!this.hasSubscribers()) {\n      this.oldValue = this.obj[this.propertyKey];\n      this.dirtyChecker.addProperty(this);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n      this.dirtyChecker.removeProperty(this);\n    }\n  }\n}\n","import { PLATFORM, Primitive, Tracer } from '@aurelia/kernel';\nimport { IAccessor, ISubscribable } from '../observation';\n\nconst slice = Array.prototype.slice;\n\nconst noop = PLATFORM.noop;\n\n// note: string.length is the only property of any primitive that is not a function,\n// so we can hardwire it to that and simply return undefined for anything else\n// note#2: a modified primitive constructor prototype would not work (and really, it shouldn't..)\nexport class PrimitiveObserver implements IAccessor, ISubscribable {\n  public getValue: () => undefined | number;\n  // removed the error reporter here because technically any primitive property that can get, can also set,\n  // but since that never serves any purpose (e.g. setting string.length doesn't throw but doesn't change the length either),\n  // we could best just leave this as a no-op and so don't need to store the propertyName\n  public setValue!: () => void;\n  public subscribe!: () => void;\n  public unsubscribe!: () => void;\n  public dispose!: () => void;\n\n  public doNotCache: boolean = true;\n  public obj: Primitive;\n\n  constructor(obj: Primitive, propertyKey: PropertyKey) {\n    if (Tracer.enabled) { Tracer.enter('PrimitiveObserver', 'constructor', slice.call(arguments)); }\n    // we don't need to store propertyName because only 'length' can return a useful value\n    if (propertyKey === 'length') {\n      // deliberately not checking for typeof string as users probably still want to know via an error that their string is undefined\n      this.obj = obj;\n      this.getValue = this.getStringLength;\n    } else {\n      this.getValue = this.returnUndefined;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private getStringLength(): number {\n    return (this.obj as string).length;\n  }\n  private returnUndefined(): undefined {\n    return undefined;\n  }\n}\nPrimitiveObserver.prototype.setValue = noop;\nPrimitiveObserver.prototype.subscribe = noop;\nPrimitiveObserver.prototype.unsubscribe = noop;\nPrimitiveObserver.prototype.dispose = noop;\n","import { Tracer } from '@aurelia/kernel';\nimport { IBindingTargetAccessor } from '../observation';\n\nexport interface PropertyAccessor extends IBindingTargetAccessor<Record<string, unknown>, string> {}\nconst slice = Array.prototype.slice;\n\nexport class PropertyAccessor implements PropertyAccessor {\n  public obj: Record<string, unknown>;\n  public propertyKey: string;\n\n  constructor(obj: Record<string, unknown>, propertyKey: string) {\n    if (Tracer.enabled) { Tracer.enter('PropertyAccessor', 'constructor', slice.call(arguments)); }\n    this.obj = obj;\n    this.propertyKey = propertyKey;\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  public getValue(): unknown {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(value: unknown): void {\n    this.obj[this.propertyKey] = value;\n  }\n}\n","import {\n  DI,\n  IContainer,\n  InjectArray,\n  IResolver,\n  Primitive,\n  Registration,\n  Reporter,\n} from '@aurelia/kernel';\n\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport {\n  AccessorOrObserver,\n  CollectionKind,\n  CollectionObserver,\n  IBindingContext,\n  IBindingTargetAccessor,\n  IBindingTargetObserver,\n  ICollectionObserver,\n  IObservable,\n  IObservedArray,\n  IObservedMap,\n  IObservedSet,\n  ObserversLookup,\n  PropertyObserver,\n} from '../observation';\nimport { getArrayObserver } from './array-observer';\nimport { createComputedObserver } from './computed-observer';\nimport { IDirtyChecker } from './dirty-checker';\nimport { getMapObserver } from './map-observer';\nimport { PrimitiveObserver } from './primitive-observer';\nimport { PropertyAccessor } from './property-accessor';\nimport { ProxyObserver } from './proxy-observer';\nimport { getSetObserver } from './set-observer';\nimport { SetterObserver } from './setter-observer';\n\nconst toStringTag = Object.prototype.toString;\n\nexport interface IObjectObservationAdapter {\n  getObserver(flags: LifecycleFlags, object: unknown, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver;\n}\n\nexport interface IObserverLocator {\n  getObserver(flags: LifecycleFlags, obj: IObservable|IBindingContext, propertyName: string): AccessorOrObserver;\n  getAccessor(flags: LifecycleFlags, obj: IObservable, propertyName: string): IBindingTargetAccessor;\n  addAdapter(adapter: IObjectObservationAdapter): void;\n  getArrayObserver(flags: LifecycleFlags, observedArray: unknown[]): ICollectionObserver<CollectionKind.array>;\n  getMapObserver(flags: LifecycleFlags, observedMap: Map<unknown, unknown>): ICollectionObserver<CollectionKind.map>;\n  getSetObserver(flags: LifecycleFlags, observedSet: Set<unknown>): ICollectionObserver<CollectionKind.set>;\n}\n\nexport const IObserverLocator = DI.createInterface<IObserverLocator>('IObserverLocator').noDefault();\n\nexport interface ITargetObserverLocator {\n  getObserver(flags: LifecycleFlags, lifecycle: ILifecycle, observerLocator: IObserverLocator, obj: unknown, propertyName: string): IBindingTargetAccessor | IBindingTargetObserver;\n  overridesAccessor(flags: LifecycleFlags, obj: unknown, propertyName: string): boolean;\n  handles(flags: LifecycleFlags, obj: unknown): boolean;\n}\nexport const ITargetObserverLocator = DI.createInterface<ITargetObserverLocator>('ITargetObserverLocator').noDefault();\n\nexport interface ITargetAccessorLocator {\n  getAccessor(flags: LifecycleFlags, lifecycle: ILifecycle, obj: unknown, propertyName: string): IBindingTargetAccessor;\n  handles(flags: LifecycleFlags, obj: unknown): boolean;\n}\nexport const ITargetAccessorLocator = DI.createInterface<ITargetAccessorLocator>('ITargetAccessorLocator').noDefault();\n\nfunction getPropertyDescriptor(subject: object, name: string): PropertyDescriptor {\n  let pd = Object.getOwnPropertyDescriptor(subject, name);\n  let proto = Object.getPrototypeOf(subject);\n\n  while (pd == null && proto != null) {\n    pd = Object.getOwnPropertyDescriptor(proto, name);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return pd!;\n}\n\n/** @internal */\nexport class ObserverLocator implements IObserverLocator {\n  public static readonly inject: InjectArray = [ILifecycle, IDirtyChecker, ITargetObserverLocator, ITargetAccessorLocator];\n\n  private readonly adapters: IObjectObservationAdapter[];\n  private readonly dirtyChecker: IDirtyChecker;\n  private readonly lifecycle: ILifecycle;\n  private readonly targetObserverLocator: ITargetObserverLocator;\n  private readonly targetAccessorLocator: ITargetAccessorLocator;\n\n  constructor(\n    lifecycle: ILifecycle,\n    dirtyChecker: IDirtyChecker,\n    targetObserverLocator: ITargetObserverLocator,\n    targetAccessorLocator: ITargetAccessorLocator\n  ) {\n    this.adapters = [];\n    this.dirtyChecker = dirtyChecker;\n    this.lifecycle = lifecycle;\n    this.targetObserverLocator = targetObserverLocator;\n    this.targetAccessorLocator = targetAccessorLocator;\n  }\n\n  public static register(container: IContainer): IResolver<IObserverLocator> {\n    return Registration.singleton(IObserverLocator, this).register(container);\n  }\n\n  public getObserver(flags: LifecycleFlags, obj: IObservable|IBindingContext, propertyName: string): AccessorOrObserver {\n    if (flags & LifecycleFlags.proxyStrategy && typeof obj === 'object') {\n      return ProxyObserver.getOrCreate(obj, propertyName) as unknown as AccessorOrObserver; // TODO: fix typings (and ensure proper contracts ofc)\n    }\n    if (isBindingContext(obj)) {\n      return obj.getObservers!(flags).getOrCreate(this.lifecycle, flags, obj, propertyName);\n    }\n    let observersLookup = obj.$observers as ObserversLookup;\n    let observer: AccessorOrObserver & { doNotCache?: boolean };\n\n    if (observersLookup && propertyName in observersLookup) {\n      return observersLookup[propertyName];\n    }\n\n    observer = this.createPropertyObserver(flags, obj, propertyName);\n\n    if (!observer.doNotCache) {\n      if (observersLookup === void 0) {\n        observersLookup = this.getOrCreateObserversLookup(obj) as ObserversLookup;\n      }\n\n      observersLookup[propertyName] = observer as PropertyObserver;\n    }\n\n    return observer;\n  }\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this.adapters.push(adapter);\n  }\n\n  public getAccessor(flags: LifecycleFlags, obj: IObservable, propertyName: string): IBindingTargetAccessor {\n    if (this.targetAccessorLocator.handles(flags, obj)) {\n      if (this.targetObserverLocator.overridesAccessor(flags, obj, propertyName)) {\n        return this.getObserver(flags, obj, propertyName);\n      }\n      return this.targetAccessorLocator.getAccessor(flags, this.lifecycle, obj, propertyName);\n    }\n\n    if (flags & LifecycleFlags.proxyStrategy) {\n      return ProxyObserver.getOrCreate(obj, propertyName) as unknown as AccessorOrObserver;\n    }\n    return new PropertyAccessor(obj, propertyName);\n  }\n\n  public getArrayObserver(flags: LifecycleFlags, observedArray: IObservedArray): ICollectionObserver<CollectionKind.array> {\n    return getArrayObserver(flags, this.lifecycle, observedArray);\n  }\n\n  public getMapObserver(flags: LifecycleFlags, observedMap: IObservedMap): ICollectionObserver<CollectionKind.map>  {\n    return getMapObserver(flags, this.lifecycle, observedMap);\n  }\n\n  public getSetObserver(flags: LifecycleFlags, observedSet: IObservedSet): ICollectionObserver<CollectionKind.set>  {\n    return getSetObserver(flags, this.lifecycle, observedSet);\n  }\n\n  private getOrCreateObserversLookup(obj: IObservable): Record<string, AccessorOrObserver | IBindingTargetObserver> {\n    return obj.$observers as ObserversLookup || this.createObserversLookup(obj);\n  }\n\n  private createObserversLookup(obj: IObservable): Record<string, IBindingTargetObserver> {\n    const value: Record<string, IBindingTargetObserver> = {};\n    if (!Reflect.defineProperty(obj, '$observers', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    })) {\n      Reporter.write(0, obj);\n    }\n    return value;\n  }\n\n  private getAdapterObserver(flags: LifecycleFlags, obj: IObservable, propertyName: string, descriptor: PropertyDescriptor): IBindingTargetObserver | null {\n    for (let i = 0, ii = this.adapters.length; i < ii; i++) {\n      const adapter = this.adapters[i];\n      const observer = adapter.getObserver(flags, obj, propertyName, descriptor);\n      if (observer != null) {\n        return observer;\n      }\n    }\n    return null;\n  }\n\n  private createPropertyObserver(flags: LifecycleFlags, obj: IObservable, propertyName: string): AccessorOrObserver {\n    if (!(obj instanceof Object)) {\n      return new PrimitiveObserver(obj as unknown as Primitive, propertyName) as IBindingTargetAccessor;\n    }\n\n    let isNode = false;\n    if (this.targetObserverLocator.handles(flags, obj)) {\n      const observer = this.targetObserverLocator.getObserver(flags, this.lifecycle, this, obj, propertyName);\n      if (observer != null) {\n        return observer;\n      }\n      isNode = true;\n    }\n\n    const tag = toStringTag.call(obj);\n    switch (tag) {\n      case '[object Array]':\n        if (propertyName === 'length') {\n          return this.getArrayObserver(flags, obj as IObservedArray).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Map]':\n        if (propertyName === 'size') {\n          return this.getMapObserver(flags, obj as IObservedMap).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      case '[object Set]':\n        if (propertyName === 'size') {\n          return this.getSetObserver(flags, obj as IObservedSet).getLengthObserver();\n        }\n        return this.dirtyChecker.createProperty(obj, propertyName);\n    }\n\n    const descriptor = getPropertyDescriptor(obj, propertyName) as PropertyDescriptor & {\n      get: PropertyDescriptor['get'] & { getObserver(obj: IObservable): IBindingTargetObserver };\n    };\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n      if (descriptor.get && descriptor.get.getObserver) {\n        return descriptor.get.getObserver(obj);\n      }\n\n      // attempt to use an adapter before resorting to dirty checking.\n      const adapterObserver = this.getAdapterObserver(flags, obj, propertyName, descriptor);\n      if (adapterObserver) {\n        return adapterObserver;\n      }\n      if (isNode) {\n        // TODO: use MutationObserver\n        return this.dirtyChecker.createProperty(obj, propertyName);\n      }\n\n      return createComputedObserver(flags, this, this.dirtyChecker, this.lifecycle, obj, propertyName, descriptor);\n    }\n    return new SetterObserver(this.lifecycle, flags, obj, propertyName);\n  }\n}\n\ntype RepeatableCollection = IObservedMap | IObservedSet | IObservedArray | null | undefined | number;\n\nexport function getCollectionObserver(flags: LifecycleFlags, lifecycle: ILifecycle, collection: RepeatableCollection): CollectionObserver | undefined {\n  // If the collection is wrapped by a proxy then `$observer` will return the proxy observer instead of the collection observer, which is not what we want\n  // when we ask for getCollectionObserver\n  const rawCollection = collection instanceof Object ? ProxyObserver.getRawIfProxy(collection) : collection;\n  switch (toStringTag.call(collection)) {\n    case '[object Array]':\n      return getArrayObserver(flags, lifecycle, rawCollection as IObservedArray);\n    case '[object Map]':\n      return getMapObserver(flags, lifecycle, rawCollection as IObservedMap);\n    case '[object Set]':\n      return getSetObserver(flags, lifecycle, rawCollection as IObservedSet);\n  }\n  return void 0;\n}\n\nfunction isBindingContext(obj: unknown): obj is IBindingContext {\n  return (obj as IBindingContext).$synthetic === true;\n}\n","import { IIndexable, Reporter } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../flags';\nimport { ILifecycle } from '../lifecycle';\nimport { IPropertyObserver, ISubscriber } from '../observation';\nimport { ProxyObserver } from './proxy-observer';\nimport { subscriberCollection } from './subscriber-collection';\n\nexport interface SelfObserver extends IPropertyObserver<IIndexable, string> {}\n\n@subscriberCollection()\nexport class SelfObserver {\n  public readonly lifecycle: ILifecycle;\n\n  public readonly obj: IIndexable;\n  public readonly propertyKey: string;\n  public currentValue: unknown;\n  public oldValue: unknown;\n\n  public readonly persistentFlags: LifecycleFlags;\n  public inBatch: boolean;\n  public observing: boolean;\n\n  private readonly callback?: (newValue: unknown, oldValue: unknown, flags: LifecycleFlags) => void;\n\n  constructor(\n    lifecycle: ILifecycle,\n    flags: LifecycleFlags,\n    obj: IIndexable,\n    propertyName: string,\n    cbName: string\n  ) {\n    this.lifecycle = lifecycle;\n\n    let isProxy = false;\n    if (ProxyObserver.isProxy(obj)) {\n      isProxy = true;\n      obj.$observer.subscribe(this, propertyName);\n      this.obj = obj.$raw;\n    } else {\n      this.obj = obj;\n    }\n    this.propertyKey = propertyName;\n    this.currentValue = void 0;\n    this.oldValue = void 0;\n\n    this.inBatch = false;\n\n    this.callback = this.obj[cbName] as typeof SelfObserver.prototype.callback;\n\n    if (this.callback === void 0) {\n      this.observing = false;\n    } else {\n      this.observing = true;\n      this.currentValue = this.obj[this.propertyKey];\n      if (!isProxy) {\n        this.createGetterSetter();\n      }\n    }\n    this.persistentFlags = flags & LifecycleFlags.persistentBindingFlags;\n  }\n\n  public handleChange(newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n    this.setValue(newValue, flags);\n  }\n\n  public getValue(): unknown {\n    return this.currentValue;\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    if (this.observing) {\n      const currentValue = this.currentValue;\n      this.currentValue = newValue;\n      if (this.lifecycle.batch.depth === 0) {\n        if ((flags & LifecycleFlags.fromBind) === 0) {\n          this.callSubscribers(newValue, currentValue, this.persistentFlags | flags);\n          if (this.callback !== void 0) {\n            this.callback.call(this.obj, newValue, currentValue, this.persistentFlags | flags);\n          }\n        }\n      } else if (!this.inBatch) {\n        this.inBatch = true;\n        this.oldValue = currentValue;\n        this.lifecycle.batch.add(this);\n      }\n    } else {\n      // See SetterObserver.setValue for explanation\n      this.obj[this.propertyKey] = newValue;\n    }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.observing === false) {\n      this.observing = true;\n      this.currentValue = this.obj[this.propertyKey];\n      this.createGetterSetter();\n    }\n\n    this.addSubscriber(subscriber);\n  }\n\n  private createGetterSetter(): void {\n    if (\n      !Reflect.defineProperty(\n        this.obj,\n        this.propertyKey,\n        {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return this.currentValue;\n          },\n          set: value => {\n            this.setValue(value, LifecycleFlags.none);\n          },\n        }\n      )\n    ) {\n      Reporter.write(1, this.propertyKey, this.obj);\n    }\n  }\n}\n","import { IRegistry } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nconst { oneTime, toView, fromView, twoWay } = BindingMode;\n\nexport type WithMode = { mode: BindingMode; originalMode?: BindingMode };\n\nexport abstract class BindingModeBehavior {\n  private readonly mode: BindingMode;\n\n  constructor(mode: BindingMode) {\n    this.mode = mode;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.originalMode = binding.mode;\n    binding.mode = this.mode;\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: Binding & WithMode): void {\n    binding.mode = binding.originalMode!;\n    binding.originalMode = null!;\n  }\n}\n\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(oneTime);\n  }\n}\nBindingBehaviorResource.define('oneTime', OneTimeBindingBehavior);\n\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(toView);\n  }\n}\nBindingBehaviorResource.define('toView', ToViewBindingBehavior);\n\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(fromView);\n  }\n}\nBindingBehaviorResource.define('fromView', FromViewBindingBehavior);\n\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  public static register: IRegistry['register'];\n\n  constructor() {\n    super(twoWay);\n  }\n}\nBindingBehaviorResource.define('twoWay', TwoWayBindingBehavior);\n","import { IRegistry, PLATFORM } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IBinding } from '../../lifecycle';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type DebounceableBinding = IBinding & {\n  debouncedMethod: ((newValue: unknown, oldValue: unknown, flags: LifecycleFlags) => void) & { originalName: string };\n  debounceState: {\n    callContextToDebounce: LifecycleFlags;\n    delay: number;\n    timeoutId: number;\n    oldValue: unknown;\n  };\n};\n\nconst unset = {};\n\n/** @internal */\nexport function debounceCallSource(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  PLATFORM.global.clearTimeout(state.timeoutId);\n  state.timeoutId = PLATFORM.global.setTimeout(() => { this.debouncedMethod(newValue, oldValue, flags); }, state.delay);\n}\n\n/** @internal */\nexport function debounceCall(this: DebounceableBinding, newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n  const state = this.debounceState;\n  PLATFORM.global.clearTimeout(state.timeoutId);\n  if (!(flags & state.callContextToDebounce)) {\n    state.oldValue = unset;\n    this.debouncedMethod(newValue, oldValue, flags);\n    return;\n  }\n  if (state.oldValue === unset) {\n    state.oldValue = oldValue;\n  }\n  const timeoutId = PLATFORM.global.setTimeout(\n    () => {\n      const ov = state.oldValue;\n      state.oldValue = unset;\n      this.debouncedMethod(newValue, ov, flags);\n    },\n    state.delay\n  );\n  state.timeoutId = timeoutId;\n}\n\nconst fromView = BindingMode.fromView;\n\nexport class DebounceBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding, delay: number = 200): void {\n    let methodToDebounce;\n    let callContextToDebounce;\n    let debouncer: typeof debounceCall | typeof debounceCallSource;\n\n    if (binding instanceof Binding) {\n      methodToDebounce = 'handleChange';\n      debouncer = debounceCall;\n      callContextToDebounce = binding.mode & fromView ? LifecycleFlags.updateSourceExpression : LifecycleFlags.updateTargetInstance;\n    } else {\n      methodToDebounce = 'callSource';\n      debouncer = debounceCallSource;\n      callContextToDebounce = LifecycleFlags.updateTargetInstance;\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.debouncedMethod = binding[methodToDebounce as keyof DebounceableBinding]! as DebounceableBinding['debouncedMethod'];\n    binding.debouncedMethod.originalName = methodToDebounce;\n\n    // replace the original method with the debouncing version.\n    (binding as typeof binding & { [key: string]: typeof debouncer })[methodToDebounce] = debouncer;\n\n    // create the debounce state.\n    binding.debounceState = {\n      callContextToDebounce,\n      delay,\n      timeoutId: 0,\n      oldValue: unset\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: DebounceableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.debouncedMethod.originalName;\n    (binding as typeof binding & { [key: string]: DebounceableBinding['debouncedMethod'] })[methodToRestore] = binding.debouncedMethod;\n    binding.debouncedMethod = null!;\n    PLATFORM.global.clearTimeout(binding.debounceState.timeoutId);\n    binding.debounceState = null!;\n  }\n}\nBindingBehaviorResource.define('debounce', DebounceBindingBehavior);\n","import {\n  IContainer,\n  Registration,\n} from '@aurelia/kernel';\n\nimport {\n  Binding,\n} from '../../binding/binding';\nimport {\n  Priority,\n} from '../../lifecycle';\nimport {\n  BindingBehaviorResource,\n  IBindingBehaviorDefinition,\n  IBindingBehaviorResource,\n} from '../binding-behavior';\n\nexport class PriorityBindingBehavior {\n  [id: number]: number | undefined;\n\n  public static readonly kind: IBindingBehaviorResource = BindingBehaviorResource;\n  public static readonly description: Required<IBindingBehaviorDefinition> = Object.freeze({\n    name: 'priority',\n  });\n\n  public static register(container: IContainer): void {\n    container.register(Registration.singleton(`binding-behavior:priority`, this));\n    container.register(Registration.singleton(this, this));\n  }\n\n  public bind(binding: Binding, priority: number | keyof typeof Priority = Priority.low): void {\n    const { targetObserver } = binding;\n    if (targetObserver != void 0) {\n      this[binding.id] = targetObserver.priority;\n      if (typeof priority === 'number') {\n        targetObserver.priority = priority;\n      } else {\n        switch (priority) {\n          case 'preempt':\n            targetObserver.priority = Priority['preempt'];\n            break;\n          case 'high':\n            targetObserver.priority = Priority['high'];\n            break;\n          case 'bind':\n            targetObserver.priority = Priority['bind'];\n            break;\n          case 'attach':\n            targetObserver.priority = Priority['attach'];\n            break;\n          case 'normal':\n            targetObserver.priority = Priority['normal'];\n            break;\n          case 'propagate':\n            targetObserver.priority = Priority['propagate'];\n            break;\n          case 'connect':\n            targetObserver.priority = Priority['connect'];\n            break;\n          case 'low':\n            targetObserver.priority = Priority['low'];\n        }\n      }\n    }\n  }\n\n  public unbind(binding: Binding): void {\n    if (binding.targetObserver != void 0) {\n      binding.targetObserver.priority = this[binding.id];\n    }\n  }\n}\n","import { InjectArray, IRegistry, Reporter } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { LifecycleFlags } from '../../flags';\nimport { IScope } from '../../observation';\nimport { ISignaler } from '../../observation/signaler';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type SignalableBinding = Binding & {\n  signal: string | string[];\n};\n\nexport class SignalBindingBehavior {\n  public static readonly inject: InjectArray = [ISignaler];\n\n  public static register: IRegistry['register'];\n\n  private readonly signaler: ISignaler;\n\n  constructor(signaler: ISignaler) {\n    this.signaler = signaler;\n  }\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding, ...args: string[]): void {\n    if (!binding.updateTarget) {\n      throw Reporter.error(11);\n    }\n\n    if (arguments.length === 4) {\n      const name = args[0];\n      this.signaler.addSignalListener(name, binding);\n      binding.signal = name;\n    } else if (arguments.length > 4) {\n      const names = Array.prototype.slice.call(arguments, 3);\n      let i = names.length;\n\n      while (i--) {\n        const name = names[i];\n        this.signaler.addSignalListener(name, binding);\n      }\n\n      binding.signal = names;\n    } else {\n      throw Reporter.error(12);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: SignalableBinding): void {\n    const name = binding.signal;\n    binding.signal = null! as string | string[];\n\n    if (Array.isArray(name)) {\n      const names = name;\n      let i = names.length;\n\n      while (i--) {\n        this.signaler.removeSignalListener(names[i], binding);\n      }\n    } else {\n      this.signaler.removeSignalListener(name, binding);\n    }\n  }\n}\nBindingBehaviorResource.define('signal', SignalBindingBehavior);\n","import { IRegistry, PLATFORM } from '@aurelia/kernel';\nimport { Binding } from '../../binding/binding';\nimport { BindingMode, LifecycleFlags } from '../../flags';\nimport { IBinding } from '../../lifecycle';\nimport { IScope } from '../../observation';\nimport { BindingBehaviorResource } from '../binding-behavior';\n\nexport type ThrottleableBinding = IBinding & {\n  throttledMethod: ((value: unknown) => unknown) & { originalName: string };\n  throttleState: {\n    delay: number;\n    timeoutId: number;\n    last: number;\n    newValue?: unknown;\n  };\n};\n\n/** @internal */\nexport function throttle(this: ThrottleableBinding, newValue: unknown): void {\n  const state = this.throttleState;\n  const elapsed = +new Date() - state.last;\n\n  if (elapsed >= state.delay) {\n    PLATFORM.global.clearTimeout(state.timeoutId);\n    state.timeoutId = -1;\n    state.last = +new Date();\n    this.throttledMethod(newValue);\n    return;\n  }\n\n  state.newValue = newValue;\n\n  if (state.timeoutId === -1) {\n    const timeoutId = PLATFORM.global.setTimeout(\n      () => {\n        state.timeoutId = -1;\n        state.last = +new Date();\n        this.throttledMethod(state.newValue);\n      },\n      state.delay - elapsed\n    );\n    state.timeoutId = timeoutId;\n  }\n}\n\nexport class ThrottleBindingBehavior {\n  public static register: IRegistry['register'];\n\n  public bind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding, delay: number = 200): void {\n    let methodToThrottle: string;\n\n    if (binding instanceof Binding) {\n      if (binding.mode === BindingMode.twoWay) {\n        methodToThrottle = 'updateSource';\n      } else {\n        methodToThrottle = 'updateTarget';\n      }\n    } else {\n      methodToThrottle = 'callSource';\n    }\n\n    // stash the original method and it's name.\n    // note: a generic name like \"originalMethod\" is not used to avoid collisions\n    // with other binding behavior types.\n    binding.throttledMethod = binding[methodToThrottle as keyof ThrottleableBinding] as ThrottleableBinding['throttledMethod'];\n    binding.throttledMethod.originalName = methodToThrottle;\n\n    // replace the original method with the throttling version.\n    (binding as typeof binding & { [key: string]: typeof throttle})[methodToThrottle] = throttle as ThrottleableBinding['throttledMethod'];\n\n    // create the throttle state.\n    binding.throttleState = {\n      delay: delay,\n      last: 0,\n      timeoutId: -1\n    };\n  }\n\n  public unbind(flags: LifecycleFlags, scope: IScope, binding: ThrottleableBinding): void {\n    // restore the state of the binding.\n    const methodToRestore = binding.throttledMethod.originalName;\n    (binding as typeof binding & { [key: string]: ThrottleableBinding['throttledMethod'] })[methodToRestore] = binding.throttledMethod;\n    binding.throttledMethod = null!;\n    PLATFORM.global.clearTimeout(binding.throttleState.timeoutId);\n    binding.throttleState = null!;\n  }\n}\nBindingBehaviorResource.define('throttle', ThrottleBindingBehavior);\n","import {\n  Constructable,\n  Reporter,\n  kebabCase,\n} from '@aurelia/kernel';\n\nimport {\n  BindableSource,\n  IBindableDescription,\n} from '../definitions';\nimport {\n  BindingMode,\n} from '../flags';\n\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * @param config The overrides\n */\nexport function bindable(config?: BindableSource): BindableDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param prop The property name\n */\nexport function bindable(prop: string): ClassDecorator;\n/**\n * Decorator: Specifies a bindable property on a class.\n * @param target The class\n * @param prop The property name\n */\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(target: T, prop: string): void;\nexport function bindable<T extends InstanceType<Constructable & Partial<WithBindables>>>(configOrTarget?: BindableSource | T, prop?: string): void | BindableDecorator | ClassDecorator {\n  let config: IBindableDescription;\n\n  const decorator = function decorate($target: T, $prop: string): void {\n    if (arguments.length > 1) {\n      // Non invocation:\n      // - @bindable\n      // Invocation with or w/o opts:\n      // - @bindable()\n      // - @bindable({...opts})\n      config.property = $prop;\n    }\n    Bindable.for($target.constructor as Partial<WithBindables>).add(config);\n  };\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    config = {};\n    decorator(configOrTarget as T, prop!);\n    return;\n  } else if (typeof configOrTarget === 'string') {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    config = {};\n    return decorator as BindableDecorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  config = (configOrTarget || {}) as IBindableDescription;\n  return decorator as BindableDecorator;\n}\n\ninterface IFluentBindableBuilder {\n  add(config: IBindableDescription): IFluentBindableBuilder;\n  add(propertyName: string): IFluentBindableBuilder;\n  get(): Record<string, IBindableDescription>;\n}\n\nexport const Bindable = {\n  for<T extends Partial<WithBindables>>(obj: T): IFluentBindableBuilder {\n    const builder: IFluentBindableBuilder = {\n      add(nameOrConfig: string | IBindableDescription): typeof builder {\n        let description: IBindableDescription = (void 0)!;\n        if (nameOrConfig instanceof Object) {\n          description = nameOrConfig;\n        } else if (typeof nameOrConfig === 'string') {\n          description = {\n            property: nameOrConfig\n          };\n        }\n        const prop = description.property;\n        if (!prop) {\n          throw Reporter.error(0); // TODO: create error code (must provide a property name)\n        }\n        if (!description.attribute) {\n          description.attribute = kebabCase(prop);\n        }\n        if (!description.callback) {\n          description.callback = `${prop}Changed`;\n        }\n        if (description.mode === undefined) {\n          description.mode = BindingMode.toView;\n        }\n        (obj.bindables as Record<string, IBindableDescription>)[prop] = description;\n        return this;\n      },\n      get(): Record<string, IBindableDescription> {\n        return obj.bindables as Record<string, IBindableDescription>;\n      }\n    };\n    if (obj.bindables === undefined) {\n      obj.bindables = {};\n    } else if (Array.isArray(obj.bindables)) {\n      const props = obj.bindables;\n      obj.bindables = {};\n      props.forEach(builder.add);\n    }\n    return builder;\n  }\n};\n\nexport type WithBindables = { bindables: Record<string, IBindableDescription> | string[] };\nexport type BindableDecorator = <T extends InstanceType<Constructable & Partial<WithBindables>>>\n  (target: T, prop: string) => void;\n","import {\n  Constructable,\n  DI,\n  IRegistry,\n  IResourceDefinition,\n  Omit,\n  PLATFORM,\n  ResourceDescription,\n  ResourcePartDescription,\n  toArray\n} from '@aurelia/kernel';\n\nimport {\n  IForOfStatement,\n  IInterpolationExpression,\n  IsBindingBehavior\n} from './ast';\nimport { INode } from './dom';\nimport {\n  BindingMode,\n  BindingStrategy,\n  ensureValidStrategy\n} from './flags';\nimport {\n  IController,\n  IViewModel\n} from './lifecycle';\nimport { CustomElementHost } from './resources/custom-element';\nimport { Bindable } from './templating/bindable';\n\n/** @internal */\nexport const customElementName = 'custom-element';\n/** @internal */\nexport function customElementKey(name: string): string {\n  return `${customElementName}:${name}`;\n}\n/** @internal */\nexport function customElementBehavior<T extends INode = INode>(node: T): IController<T> | undefined {\n  return (node as CustomElementHost<T>).$controller;\n}\n\n/** @internal */\nexport const customAttributeName = 'custom-attribute';\n/** @internal */\nexport function customAttributeKey(name: string): string {\n  return `${customAttributeName}:${name}`;\n}\n\nexport type IElementHydrationOptions = { parts?: Record<string, TemplateDefinition> };\n\nexport type BindableSource = Omit<IBindableDescription, 'property'>;\n\nexport interface IBindableDescription {\n  mode?: BindingMode;\n  callback?: string;\n  attribute?: string;\n  property?: string;\n}\n\n/**\n * TargetedInstructionType enum values become the property names for the associated renderers when they are injected\n * into the `Renderer`.\n *\n * Additional instruction types can be added as long as they are 2 characters long and do not clash with existing ones.\n *\n * By convention, the instruction types for a particular runtime start with the same first letter, and the second letter\n * starts counting from letter `a`. The standard runtime instruction types all start with the letter `r`.\n */\nexport const enum TargetedInstructionType {\n  hydrateElement = 'ra',\n  hydrateAttribute = 'rb',\n  hydrateTemplateController = 'rc',\n  hydrateLetElement = 'rd',\n  setProperty = 're',\n  interpolation = 'rf',\n  propertyBinding = 'rg',\n  callBinding = 'rh',\n  letBinding = 'ri',\n  refBinding = 'rj',\n  iteratorBinding = 'rk',\n}\n\nexport interface IBuildInstruction {\n  required: boolean;\n  compiler?: string;\n}\n\nexport interface ITemplateDefinition extends IResourceDefinition {\n  cache?: '*' | number;\n  template?: unknown;\n  instructions?: ITargetedInstruction[][];\n  dependencies?: IRegistry[];\n  build?: IBuildInstruction;\n  surrogates?: ITargetedInstruction[];\n  bindables?: Record<string, IBindableDescription> | string[];\n  containerless?: boolean;\n  shadowOptions?: { mode: 'open' | 'closed' };\n  hasSlots?: boolean;\n  strategy?: BindingStrategy;\n  hooks?: Readonly<HooksDefinition>;\n}\n\nexport type TemplateDefinition = ResourceDescription<ITemplateDefinition>;\n\nexport type TemplatePartDefinitions = Record<string, ResourcePartDescription<ITemplateDefinition>>;\nexport type BindableDefinitions = Record<string, IBindableDescription>;\n\nexport interface IAttributeDefinition extends IResourceDefinition {\n  defaultBindingMode?: BindingMode;\n  aliases?: string[];\n  isTemplateController?: boolean;\n  hasDynamicOptions?: boolean;\n  bindables?: Record<string, IBindableDescription> | string[];\n  strategy?: BindingStrategy;\n  hooks?: Readonly<HooksDefinition>;\n}\n\nexport type AttributeDefinition = Required<IAttributeDefinition> | null;\n\nexport type InstructionTypeName = string;\n\nexport const ITargetedInstruction = DI.createInterface<ITargetedInstruction>('createInterface').noDefault();\nexport interface ITargetedInstruction {\n  type: InstructionTypeName;\n}\n\nexport type NodeInstruction =\n  IHydrateElementInstruction |\n  IHydrateTemplateController |\n  IHydrateLetElementInstruction;\n\nexport type AttributeInstruction =\n  IInterpolationInstruction |\n  IPropertyBindingInstruction |\n  IIteratorBindingInstruction |\n  ICallBindingInstruction |\n  IRefBindingInstruction |\n  ISetPropertyInstruction |\n  ILetBindingInstruction |\n  IHydrateAttributeInstruction;\n\nexport type TargetedInstruction = NodeInstruction | AttributeInstruction;\n\n// TODO: further improve specificity and integrate with the definitions;\nexport type InstructionRow = [TargetedInstruction, ...AttributeInstruction[]];\n\nexport function isTargetedInstruction(value: unknown): value is TargetedInstruction {\n  const type = (value as { type?: string }).type;\n  return typeof type === 'string' && type.length === 2;\n}\n\nexport interface IInterpolationInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.interpolation;\n  from: string | IInterpolationExpression;\n  to: string;\n}\n\nexport interface IPropertyBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.propertyBinding;\n  mode: BindingMode;\n  from: string | IsBindingBehavior;\n  to: string;\n  oneTime?: boolean;\n}\n\nexport interface IIteratorBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.iteratorBinding;\n  from: string | IForOfStatement;\n  to: string;\n}\n\nexport interface ICallBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.callBinding;\n  from: string | IsBindingBehavior;\n  to: string;\n}\n\nexport interface IRefBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.refBinding;\n  from: string | IsBindingBehavior;\n}\n\nexport interface ISetPropertyInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.setProperty;\n  value: unknown;\n  to: string;\n}\n\nexport interface IHydrateElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateElement;\n  res: string;\n  instructions: ITargetedInstruction[];\n  parts?: Record<string, ITemplateDefinition>;\n}\n\nexport interface IHydrateAttributeInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateAttribute;\n  res: string;\n  instructions: ITargetedInstruction[];\n}\n\nexport interface IHydrateTemplateController extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateTemplateController;\n  res: string;\n  instructions: ITargetedInstruction[];\n  def: ITemplateDefinition;\n  link?: boolean;\n  parts?: Record<string, ITemplateDefinition>;\n}\n\nexport interface IHydrateLetElementInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.hydrateLetElement;\n  instructions: ILetBindingInstruction[];\n  toViewModel: boolean;\n}\n\nexport interface ILetBindingInstruction extends ITargetedInstruction {\n  type: TargetedInstructionType.letBinding;\n  from: string | IsBindingBehavior | IInterpolationExpression;\n  to: string;\n}\n\n/** @internal */\nexport const buildRequired: IBuildInstruction = Object.freeze({\n  required: true,\n  compiler: 'default'\n});\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\nexport class HooksDefinition {\n  public static readonly none: Readonly<HooksDefinition> = Object.freeze(new HooksDefinition({}));\n\n  public readonly hasRender: boolean;\n  public readonly hasCreated: boolean;\n\n  public readonly hasBinding: boolean;\n  public readonly hasBound: boolean;\n\n  public readonly hasUnbinding: boolean;\n  public readonly hasUnbound: boolean;\n\n  public readonly hasAttaching: boolean;\n  public readonly hasAttached: boolean;\n\n  public readonly hasDetaching: boolean;\n  public readonly hasDetached: boolean;\n  public readonly hasCaching: boolean;\n\n  constructor(target: object) {\n    this.hasRender = 'render' in target;\n    this.hasCreated = 'created' in target;\n    this.hasBinding = 'binding' in target;\n    this.hasBound = 'bound' in target;\n    this.hasUnbinding = 'unbinding' in target;\n    this.hasUnbound = 'unbound' in target;\n    this.hasAttaching = 'attaching' in target;\n    this.hasAttached = 'attached' in target;\n    this.hasDetaching = 'detaching' in target;\n    this.hasDetached = 'detached' in target;\n    this.hasCaching = 'caching' in target;\n  }\n}\n\n// Note: this is a little perf thing; having one predefined class with the properties always\n// assigned in the same order ensures the browser can keep reusing the same generated hidden\n// class\nclass DefaultTemplateDefinition implements Required<ITemplateDefinition> {\n  public name: string;\n  public cache: '*' | number;\n  public template: unknown;\n  public instructions: ITargetedInstruction[][];\n  public dependencies: IRegistry[];\n  public build: IBuildInstruction;\n  public surrogates: ITargetedInstruction[];\n  public bindables: Record<string, IBindableDescription> | string[];\n  public containerless: boolean;\n  public shadowOptions: { mode: 'open' | 'closed' };\n  public hasSlots: boolean;\n  public strategy: BindingStrategy;\n  public hooks: Readonly<HooksDefinition>;\n\n  constructor() {\n    this.name = 'unnamed';\n    this.template = null;\n    this.cache = 0;\n    this.build = buildNotRequired;\n    this.bindables = PLATFORM.emptyObject;\n    this.instructions = PLATFORM.emptyArray as typeof PLATFORM.emptyArray & this['instructions'];\n    this.dependencies = PLATFORM.emptyArray as typeof PLATFORM.emptyArray & this['dependencies'];\n    this.surrogates = PLATFORM.emptyArray as typeof PLATFORM.emptyArray & this['surrogates'];\n    this.containerless = false;\n    this.shadowOptions = null!;\n    this.hasSlots = false;\n    this.strategy = BindingStrategy.getterSetter;\n    this.hooks = HooksDefinition.none;\n  }\n}\n\nconst templateDefinitionAssignables = [\n  'name',\n  'template',\n  'cache',\n  'build',\n  'containerless',\n  'shadowOptions',\n  'hasSlots'\n];\n\nconst templateDefinitionArrays = [\n  'instructions',\n  'dependencies',\n  'surrogates'\n];\n\nexport type CustomElementConstructor = Constructable & {\n  containerless?: TemplateDefinition['containerless'];\n  shadowOptions?: TemplateDefinition['shadowOptions'];\n  bindables?: TemplateDefinition['bindables'];\n};\n\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor,\n  name: string): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: null,\n  def: ITemplateDefinition): TemplateDefinition;\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | ITemplateDefinition): TemplateDefinition;\n// tslint:disable-next-line:parameters-max-number\n// @ts-ignore\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  name: string | null,\n  template: unknown,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<ITargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<unknown> | null,\n  surrogates?: ReadonlyArray<ITargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null,\n  strategy?: BindingStrategy | null): TemplateDefinition;\n// tslint:disable-next-line:parameters-max-number // TODO: Reduce complexity (currently at 64)\nexport function buildTemplateDefinition(\n  ctor: CustomElementConstructor | null,\n  nameOrDef: string | ITemplateDefinition | null,\n  template?: unknown | null,\n  cache?: number | '*' | null,\n  build?: IBuildInstruction | boolean | null,\n  bindables?: Record<string, IBindableDescription> | null,\n  instructions?: ReadonlyArray<ReadonlyArray<ITargetedInstruction>> | null,\n  dependencies?: ReadonlyArray<IRegistry> | null,\n  surrogates?: ReadonlyArray<ITargetedInstruction> | null,\n  containerless?: boolean | null,\n  shadowOptions?: { mode: 'open' | 'closed' } | null,\n  hasSlots?: boolean | null,\n  strategy?: BindingStrategy | null): TemplateDefinition {\n\n  const def = new DefaultTemplateDefinition();\n\n  // all cases fall through intentionally\n  const argLen = arguments.length;\n  switch (argLen) {\n    case 13: if (strategy != null) def.strategy = ensureValidStrategy(strategy);\n    case 12: if (hasSlots != null) def.hasSlots = hasSlots!;\n    case 11: if (shadowOptions != null) def.shadowOptions = shadowOptions!;\n    case 10: if (containerless != null) def.containerless = containerless!;\n    case 9: if (surrogates != null) def.surrogates = toArray(surrogates!);\n    case 8: if (dependencies != null) def.dependencies = toArray(dependencies!);\n    case 7: if (instructions != null) def.instructions = toArray(instructions!) as ITargetedInstruction[][];\n    case 6: if (bindables != null) def.bindables = { ...bindables };\n    case 5: if (build != null) def.build = build === true ? buildRequired : build === false ? buildNotRequired : { ...build! };\n    case 4: if (cache != null) def.cache = cache!;\n    case 3: if (template != null) def.template = template;\n    case 2:\n      if (ctor != null) {\n        if (ctor.bindables) {\n          def.bindables = Bindable.for(ctor as unknown as {}).get();\n        }\n        if (ctor.containerless) {\n          def.containerless = ctor.containerless;\n        }\n        if (ctor.shadowOptions) {\n          def.shadowOptions = ctor.shadowOptions as unknown as { mode: 'open' | 'closed' };\n        }\n        if (ctor.prototype) {\n          def.hooks = new HooksDefinition(ctor.prototype);\n        }\n      }\n      if (typeof nameOrDef === 'string') {\n        if (nameOrDef.length > 0) {\n          def.name = nameOrDef;\n        }\n      } else if (nameOrDef != null) {\n        def.strategy = ensureValidStrategy(nameOrDef.strategy);\n        templateDefinitionAssignables.forEach(prop => {\n          if (nameOrDef[prop as keyof typeof nameOrDef]) {\n            def[prop as keyof typeof def] = nameOrDef[prop as keyof typeof nameOrDef];\n          }\n        });\n        templateDefinitionArrays.forEach(prop => {\n          if (nameOrDef[prop as keyof typeof nameOrDef]) {\n            def[prop as keyof typeof def] = toArray(nameOrDef[prop as keyof typeof nameOrDef] as unknown[]);\n          }\n        });\n        if (nameOrDef['bindables']) {\n          if (def.bindables === PLATFORM.emptyObject) {\n            def.bindables = Bindable.for(nameOrDef as unknown as {}).get();\n          } else {\n            Object.assign(def.bindables, nameOrDef.bindables);\n          }\n        }\n      }\n  }\n\n  // special handling for invocations that quack like a @customElement decorator\n  if (argLen === 2 && ctor !== null && (typeof nameOrDef === 'string' || !('build' in nameOrDef!))) {\n    def.build = buildRequired;\n  }\n\n  return def;\n}\n","import {\n  Class,\n  Constructable,\n  IContainer,\n  IResourceKind,\n  IResourceType,\n  Omit,\n  PLATFORM,\n  Registration,\n  ResourceDescription,\n  Writable\n} from '@aurelia/kernel';\nimport {\n  customAttributeKey,\n  customAttributeName,\n  HooksDefinition,\n  IAttributeDefinition\n} from '../definitions';\nimport {\n  BindingMode,\n  ensureValidStrategy,\n} from '../flags';\nimport {\n  IViewModel,\n} from '../lifecycle';\nimport { Bindable } from '../templating/bindable';\n\ntype CustomAttributeStaticProperties = Pick<Required<IAttributeDefinition>, 'bindables'>;\n\nexport type CustomAttributeConstructor = Constructable & CustomAttributeStaticProperties;\n\nexport interface ICustomAttributeType<C extends Constructable = Constructable> extends\n  IResourceType<IAttributeDefinition, InstanceType<C> & IViewModel>,\n  CustomAttributeStaticProperties { }\n\nexport interface ICustomAttributeResource extends\n  IResourceKind<IAttributeDefinition, IViewModel, Class<IViewModel> & CustomAttributeStaticProperties> {\n}\n\n/** @internal */\nexport function registerAttribute(this: ICustomAttributeType, container: IContainer): void {\n  const description = this.description;\n  const resourceKey = this.kind.keyFrom(description.name);\n  const aliases = description.aliases;\n\n  container.register(Registration.transient(resourceKey, this));\n  container.register(Registration.transient(this, this));\n\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    const aliasKey = this.kind.keyFrom(aliases[i]);\n    container.register(Registration.alias(resourceKey, aliasKey));\n  }\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(name: string): CustomAttributeDecorator;\nexport function customAttribute(nameOrDefinition: string | IAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDefinition: string | IAttributeDefinition): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(nameOrDefinition, target);\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(definition: IAttributeDefinition): CustomAttributeDecorator;\nexport function templateController(name: string): CustomAttributeDecorator;\nexport function templateController(nameOrDefinition: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator;\nexport function templateController(nameOrDefinition: string | Omit<IAttributeDefinition, 'isTemplateController'>): CustomAttributeDecorator {\n  return target => CustomAttributeResource.define(\n    typeof nameOrDefinition === 'string'\n    ? { isTemplateController: true , name: nameOrDefinition }\n    : { isTemplateController: true, ...nameOrDefinition },\n    target);\n}\n\ntype HasDynamicOptions = Pick<IAttributeDefinition, 'hasDynamicOptions'>;\n\nfunction dynamicOptionsDecorator<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions> {\n  target.hasDynamicOptions = true;\n  return target as T & Required<HasDynamicOptions>;\n}\n\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions(): typeof dynamicOptionsDecorator;\n/**\n * Decorator: Indicates that the custom attributes has dynamic options.\n */\nexport function dynamicOptions<T extends Constructable>(target: T & HasDynamicOptions): T & Required<HasDynamicOptions>;\nexport function dynamicOptions<T extends Constructable>(target?: T & HasDynamicOptions): T & Required<HasDynamicOptions> | typeof dynamicOptionsDecorator {\n  return target === undefined ? dynamicOptionsDecorator : dynamicOptionsDecorator<T>(target);\n}\n\nfunction isType<T>(this: ICustomAttributeResource, Type: T & Partial<ICustomAttributeType>): Type is T & ICustomAttributeType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable = Constructable>(this: ICustomAttributeResource, definition: IAttributeDefinition, ctor: T): T & ICustomAttributeType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomAttributeResource, name: string, ctor: T): T & ICustomAttributeType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomAttributeResource, nameOrDefinition: string | IAttributeDefinition, ctor: T): T & ICustomAttributeType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomAttributeResource, nameOrDefinition: string | IAttributeDefinition, ctor: T): T & ICustomAttributeType<T> {\n  const Type = ctor as T & ICustomAttributeType<T>;\n  const WritableType = Type as T & Writable<ICustomAttributeType<T>>;\n  const description = createCustomAttributeDescription(typeof nameOrDefinition === 'string' ? { name: nameOrDefinition } : nameOrDefinition, Type);\n\n  WritableType.kind = CustomAttributeResource as ICustomAttributeResource;\n  WritableType.description = description;\n  Type.register = registerAttribute;\n\n  return Type;\n}\n\nexport const CustomAttributeResource = {\n  name: customAttributeName,\n  keyFrom: customAttributeKey,\n  isType,\n  define\n};\n\n/** @internal */\nexport function createCustomAttributeDescription(def: IAttributeDefinition, Type: ICustomAttributeType): ResourceDescription<IAttributeDefinition> {\n  const aliases = def.aliases;\n  const defaultBindingMode = def.defaultBindingMode;\n  return {\n    name: def.name,\n    aliases: aliases == null ? PLATFORM.emptyArray as typeof PLATFORM['emptyArray'] & any[] : aliases,\n    defaultBindingMode: defaultBindingMode == null ? BindingMode.toView : defaultBindingMode,\n    hasDynamicOptions: def.hasDynamicOptions === undefined ? false : def.hasDynamicOptions,\n    isTemplateController: def.isTemplateController === undefined ? false : def.isTemplateController,\n    bindables: { ...Bindable.for(Type as unknown as {}).get(), ...Bindable.for(def).get() },\n    strategy: ensureValidStrategy(def.strategy),\n    hooks: new HooksDefinition(Type.prototype)\n  };\n}\n\nexport type CustomAttributeDecorator = <T extends Constructable>(target: T) => T & ICustomAttributeType<T>;\n","import {\n  DI,\n  IContainer,\n  IResolver,\n  PLATFORM,\n  Reporter,\n} from '@aurelia/kernel';\n\nexport interface INode extends Object { }\n\nexport const INode = DI.createInterface<INode>('INode').noDefault();\n\nexport const IRenderLocation = DI.createInterface<IRenderLocation>('IRenderLocation').noDefault();\nexport interface IRenderLocation<T extends INode = INode> extends INode {\n  $start?: IRenderLocation<T>;\n  $nodes?: INodeSequence<T> | Readonly<{}>;\n}\n\n/**\n * Represents a DocumentFragment\n */\nexport interface INodeSequence<T extends INode = INode> extends INode {\n  readonly isMounted: boolean;\n  readonly isLinked: boolean;\n\n  readonly next?: INodeSequence<T>;\n\n  /**\n   * The nodes of this sequence.\n   */\n  readonly childNodes: ArrayLike<T>;\n\n  readonly firstChild: T;\n\n  readonly lastChild: T;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<T>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: T | IRenderLocation<T>): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: T): void;\n\n  /**\n   * Remove this sequence from the DOM.\n   */\n  remove(): void;\n\n  addToLinked(): void;\n\n  unlink(): void;\n\n  link(next: INodeSequence<T> | IRenderLocation<T> | undefined): void;\n}\n\nexport const IDOM = DI.createInterface<IDOM>('IDOM').noDefault();\n\nexport interface IDOM<T extends INode = INode> {\n  addEventListener(eventName: string, subscriber: unknown, publisher?: unknown, options?: unknown): void;\n  appendChild(parent: T, child: T): void;\n  cloneNode<TClone extends T>(node: TClone, deep?: boolean): TClone;\n  convertToRenderLocation(node: T): IRenderLocation<T>;\n  createDocumentFragment(markupOrNode?: string | T): T;\n  createElement(name: string): T;\n  createCustomEvent(eventType: string, options?: unknown): unknown;\n  dispatchEvent(evt: unknown): void;\n  createNodeObserver?(node: T, cb: (...args: unknown[]) => void, init: unknown): unknown;\n  createTemplate(markup?: string): T;\n  createTextNode(text: string): T;\n  insertBefore(nodeToInsert: T, referenceNode: T): void;\n  isMarker(node: unknown): node is T;\n  isNodeInstance(potentialNode: unknown): potentialNode is T;\n  isRenderLocation(node: unknown): node is IRenderLocation<T>;\n  makeTarget(node: T): void;\n  registerElementResolver(container: IContainer, resolver: IResolver): void;\n  remove(node: T): void;\n  removeEventListener(eventName: string, subscriber: unknown, publisher?: unknown, options?: unknown): void;\n  setAttribute(node: T, name: string, value: unknown): void;\n}\n\nconst ni = function(...args: unknown[]): unknown {\n  throw Reporter.error(1000); // TODO: create error code (not implemented exception)\n  // tslint:disable-next-line:no-any // this function doesn't need typing because it is never directly called\n} as any;\n\nconst niDOM: IDOM = {\n  addEventListener: ni,\n  appendChild: ni,\n  cloneNode: ni,\n  convertToRenderLocation: ni,\n  createDocumentFragment: ni,\n  createElement: ni,\n  createCustomEvent: ni,\n  dispatchEvent: ni,\n  createNodeObserver: ni,\n  createTemplate: ni,\n  createTextNode: ni,\n  insertBefore: ni,\n  isMarker: ni,\n  isNodeInstance: ni,\n  isRenderLocation: ni,\n  makeTarget: ni,\n  registerElementResolver: ni,\n  remove: ni,\n  removeEventListener: ni,\n  setAttribute: ni\n};\n\nexport const DOM: IDOM & {\n  readonly isInitialized: boolean;\n  initialize(dom: IDOM): void;\n  destroy(): void;\n} = {\n  ...niDOM,\n  get isInitialized(): boolean {\n    return Reflect.get(this, '$initialized') === true;\n  },\n  initialize(dom: IDOM): void {\n    if (this.isInitialized) {\n      throw Reporter.error(1001); // TODO: create error code (already initialized, check isInitialized property and call destroy() if you want to assign a different dom)\n    }\n    const descriptors: PropertyDescriptorMap = {};\n    const protos: IDOM[] = [dom];\n    let proto = Object.getPrototypeOf(dom);\n    while (proto && proto !== Object.prototype) {\n      protos.unshift(proto);\n      proto = Object.getPrototypeOf(proto);\n    }\n    for (proto of protos) {\n      Object.assign(descriptors, Object.getOwnPropertyDescriptors(proto));\n    }\n    const keys: string[] = [];\n    let key: string;\n    let descriptor: PropertyDescriptor;\n    for (key in descriptors) {\n      descriptor = descriptors[key];\n      if (descriptor.configurable && descriptor.writable) {\n        Reflect.defineProperty(this, key, descriptor);\n        keys.push(key);\n      }\n    }\n    Reflect.set(this, '$domKeys', keys);\n    Reflect.set(this, '$initialized', true);\n  },\n  destroy(): void {\n    if (!this.isInitialized) {\n      throw Reporter.error(1002); // TODO: create error code (already destroyed)\n    }\n    const keys = Reflect.get(this, '$domKeys') as string[];\n    keys.forEach(key => {\n      Reflect.deleteProperty(this, key);\n    });\n    Object.assign(this, niDOM);\n    Reflect.set(this, '$domKeys', PLATFORM.emptyArray);\n    Reflect.set(this, '$initialized', false);\n  }\n};\n\n// This is an implementation of INodeSequence that represents \"no DOM\" to render.\n// It's used in various places to avoid null and to encode\n// the explicit idea of \"no view\".\nconst emptySequence: INodeSequence = {\n  isMounted: false,\n  isLinked: false,\n  next: void 0,\n  childNodes: PLATFORM.emptyArray,\n  firstChild: null!,\n  lastChild: null!,\n  findTargets(): ArrayLike<INode> { return PLATFORM.emptyArray; },\n  insertBefore(refNode: INode): void { /*do nothing*/ },\n  appendTo(parent: INode): void { /*do nothing*/ },\n  remove(): void { /*do nothing*/ },\n  addToLinked(): void { /*do nothing*/ },\n  unlink(): void { /*do nothing*/ },\n  link(next: INodeSequence | IRenderLocation | undefined): void { /*do nothing*/ },\n};\n\nexport const NodeSequence = {\n  empty: emptySequence\n};\n\nexport interface INodeSequenceFactory<T extends INode = INode> {\n  createNodeSequence(): INodeSequence<T>;\n}\n","\nexport type PromiseOrTask = Promise<unknown> | ILifecycleTask;\nexport type MaybePromiseOrTask = void | PromiseOrTask;\n\nexport const LifecycleTask = {\n  done: {\n    done: true,\n    canCancel(): boolean { return false; },\n    cancel(): void { return; },\n    wait(): Promise<unknown> { return Promise.resolve(); }\n  }\n};\n\nexport interface ILifecycleTask<T = unknown> {\n  readonly done: boolean;\n  canCancel(): boolean;\n  cancel(): void;\n  wait(): Promise<T>;\n}\n\nexport class PromiseTask<TArgs extends unknown[], T = void> implements ILifecycleTask {\n  public done: boolean;\n\n  private hasStarted: boolean;\n  private isCancelled: boolean;\n  private readonly promise: Promise<unknown>;\n\n  constructor(\n    promise: Promise<T>,\n    next: ((result?: T, ...args: TArgs) => MaybePromiseOrTask) | null,\n    context: unknown,\n    ...args: TArgs\n  ) {\n    this.done = false;\n    this.isCancelled = false;\n    this.hasStarted = false;\n    this.promise = promise.then(value => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.hasStarted = true;\n      if (next !== null) {\n        // @ts-ignore\n        const nextResult = next.call(context, value, ...args);\n        if (nextResult === void 0) {\n          this.done = true;\n        } else {\n          const nextPromise = (nextResult as Promise<unknown>).then instanceof Function\n            ? nextResult as Promise<unknown>\n            : (nextResult as ILifecycleTask).wait();\n          return nextPromise.then(() => {\n            this.done = true;\n          });\n        }\n      }\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.hasStarted;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<unknown> {\n    return this.promise;\n  }\n}\n\nexport class ContinuationTask<TArgs extends unknown[]> implements ILifecycleTask {\n  public done: boolean;\n\n  private hasStarted: boolean;\n  private isCancelled: boolean;\n  private readonly promise: Promise<unknown>;\n\n  constructor(\n    antecedent: Promise<unknown> | ILifecycleTask,\n    next: (...args: TArgs) => MaybePromiseOrTask,\n    context: unknown,\n    ...args: TArgs\n  ) {\n    this.done = false;\n    this.hasStarted = false;\n    this.isCancelled = false;\n\n    const promise = (antecedent as Promise<unknown>).then instanceof Function\n      ? antecedent as Promise<unknown>\n      : (antecedent as ILifecycleTask).wait();\n\n    this.promise = promise.then(() => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.hasStarted = true;\n      const nextResult = next.call(context, ...args) as MaybePromiseOrTask;\n      if (nextResult === void 0) {\n        this.done = true;\n      } else {\n        const nextPromise = (nextResult as Promise<unknown>).then instanceof Function\n          ? nextResult as Promise<unknown>\n          : (nextResult as ILifecycleTask).wait();\n        return nextPromise.then(() => {\n          this.done = true;\n        });\n      }\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.hasStarted;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<unknown> {\n    return this.promise;\n  }\n}\n\nexport class TerminalTask implements ILifecycleTask {\n  public done: boolean;\n\n  private readonly promise: Promise<unknown>;\n\n  constructor(antecedent: Promise<unknown> | ILifecycleTask) {\n    this.done = false;\n\n    this.promise = (antecedent as Promise<unknown>).then instanceof Function\n      ? antecedent as Promise<unknown>\n      : (antecedent as ILifecycleTask).wait();\n\n    this.promise.then(() => {\n      this.done = true;\n    }).catch(e => { throw e; });\n  }\n\n  public canCancel(): boolean {\n    return false;\n  }\n\n  public cancel(): void {\n    return;\n  }\n\n  public wait(): Promise<unknown> {\n    return this.promise;\n  }\n}\n\nexport class AggregateContinuationTask<TArgs extends unknown[]> implements ILifecycleTask {\n  public done: boolean;\n\n  private hasStarted: boolean;\n  private isCancelled: boolean;\n  private readonly promise: Promise<unknown>;\n\n  constructor(\n    antecedents: ILifecycleTask[],\n    next: (...args: TArgs) => void | ILifecycleTask,\n    context: unknown,\n    ...args: TArgs\n  ) {\n    this.done = false;\n    this.hasStarted = false;\n    this.isCancelled = false;\n    this.promise = Promise.all(antecedents.map(t => t.wait())).then(() => {\n      if (this.isCancelled === true) {\n        return;\n      }\n      this.hasStarted = true;\n      const nextResult = next.call(context, ...args) as undefined | ILifecycleTask;\n      if (nextResult === void 0) {\n        this.done = true;\n      } else {\n        return nextResult.wait().then(() => {\n          this.done = true;\n        });\n      }\n    });\n  }\n\n  public canCancel(): boolean {\n    return !this.hasStarted;\n  }\n\n  public cancel(): void {\n    if (this.canCancel()) {\n      this.isCancelled = true;\n    }\n  }\n\n  public wait(): Promise<unknown> {\n    return this.promise;\n  }\n}\n\nexport class AggregateTerminalTask implements ILifecycleTask {\n  public done: boolean;\n\n  private readonly promise: Promise<unknown>;\n\n  constructor(antecedents: ILifecycleTask[]) {\n    this.done = false;\n    this.promise = Promise.all(antecedents.map(t => t.wait())).then(() => {\n      this.done = true;\n    });\n  }\n\n  public canCancel(): boolean {\n    return false;\n  }\n\n  public cancel(): void {\n    return;\n  }\n\n  public wait(): Promise<unknown> {\n    return this.promise;\n  }\n}\n\nexport function hasAsyncWork(value: MaybePromiseOrTask): value is PromiseOrTask {\n  return !(value === void 0 || (value as ILifecycleTask).done === true);\n}\n","import {\n  IContainer,\n  InjectArray,\n  nextId,\n  PLATFORM,\n  Registration\n} from '@aurelia/kernel';\nimport {\n  HooksDefinition,\n  IAttributeDefinition\n} from '../../definitions';\nimport {\n  INode,\n  IRenderLocation\n} from '../../dom';\nimport {\n  BindingMode,\n  BindingStrategy,\n  LifecycleFlags,\n  State\n} from '../../flags';\nimport {\n  IController,\n  IViewFactory,\n  Priority,\n} from '../../lifecycle';\nimport {\n  ContinuationTask,\n  ILifecycleTask,\n  LifecycleTask,\n  PromiseTask\n} from '../../lifecycle-task';\nimport {\n  IObserversLookup,\n} from '../../observation';\nimport { SetterObserver } from '../../observation/setter-observer';\nimport { Bindable } from '../../templating/bindable';\nimport {\n  CustomAttributeResource,\n  ICustomAttributeResource\n} from '../custom-attribute';\n\nexport class If<T extends INode = INode> {\n  public static readonly inject: InjectArray = [IViewFactory, IRenderLocation];\n\n  public static readonly kind: ICustomAttributeResource = CustomAttributeResource;\n  public static readonly description: Required<IAttributeDefinition> = Object.freeze({\n    name: 'if',\n    aliases: PLATFORM.emptyArray as typeof PLATFORM.emptyArray & string[],\n    defaultBindingMode: BindingMode.toView,\n    hasDynamicOptions: false,\n    isTemplateController: true,\n    bindables: Object.freeze(Bindable.for({ bindables: ['value'] }).get()),\n    strategy: BindingStrategy.getterSetter,\n    hooks: Object.freeze(new HooksDefinition(If.prototype)),\n  });\n\n  public readonly id: number;\n\n  public get value(): boolean {\n    return this._value;\n  }\n  public set value(newValue: boolean) {\n    const oldValue = this._value;\n    if (oldValue !== newValue) {\n      this._value = newValue;\n      this.valueChanged(newValue, oldValue, this.$controller.flags);\n    }\n  }\n\n  public readonly $observers: IObserversLookup = {\n    value: this as this & SetterObserver,\n  };\n\n  public elseFactory?: IViewFactory<T>;\n  public elseView?: IController<T>;\n  public ifFactory: IViewFactory<T>;\n  public ifView?: IController<T>;\n  public location: IRenderLocation<T>;\n  public readonly noProxy: true;\n  public view?: IController<T>;\n\n  private task: ILifecycleTask;\n  // tslint:disable-next-line: prefer-readonly // This is set by the controller after this instance is constructed\n  public $controller!: IController<T>;\n\n  private _value: boolean;\n\n  constructor(\n    ifFactory: IViewFactory<T>,\n    location: IRenderLocation<T>,\n  ) {\n    this.id = nextId('au$component');\n\n    this.elseFactory = void 0;\n    this.elseView = void 0;\n    this.ifFactory = ifFactory;\n    this.ifView = void 0;\n    this.location = location;\n    this.noProxy = true;\n\n    this.task = LifecycleTask.done;\n    this.view = void 0;\n\n    this._value = false;\n  }\n\n  public static register(container: IContainer): void {\n    container.register(Registration.transient('custom-attribute:if', this));\n    container.register(Registration.transient(this, this));\n  }\n\n  public getValue(): boolean {\n    return this._value;\n  }\n\n  public setValue(newValue: boolean, flags: LifecycleFlags): void {\n    const oldValue = this._value;\n    if (oldValue !== newValue) {\n      this._value = newValue;\n      this.valueChanged(newValue, oldValue, flags | this.$controller.flags);\n    }\n  }\n\n  public binding(flags: LifecycleFlags): ILifecycleTask {\n    if (this.task.done) {\n      this.task = this.swap(this.value, flags);\n    } else {\n      this.task = new ContinuationTask(this.task, this.swap, this, this.value, flags);\n    }\n\n    return this.task;\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    if (this.task.done) {\n      this.attachView(flags);\n    } else {\n      this.task = new ContinuationTask(this.task, this.attachView, this, flags);\n    }\n  }\n\n  public detaching(flags: LifecycleFlags): ILifecycleTask {\n    if (this.view !== void 0) {\n      if (this.task.done) {\n        this.view.detach(flags);\n      } else {\n        this.task = new ContinuationTask(this.task, this.view.detach, this.view, flags);\n      }\n    }\n\n    return this.task;\n  }\n\n  public unbinding(flags: LifecycleFlags): ILifecycleTask {\n    if (this.view !== void 0) {\n      if (this.task.done) {\n        this.task = this.view.unbind(flags);\n      } else {\n        this.task = new ContinuationTask(this.task, this.view.unbind, this.view, flags);\n      }\n    }\n\n    return this.task;\n  }\n\n  public caching(flags: LifecycleFlags): void {\n    if (this.ifView !== void 0 && this.ifView.release(flags)) {\n      this.ifView = void 0;\n    }\n\n    if (this.elseView !== void 0 && this.elseView.release(flags)) {\n      this.elseView = void 0;\n    }\n\n    this.view = void 0;\n  }\n\n  public valueChanged(newValue: boolean, oldValue: boolean, flags: LifecycleFlags): void {\n    if ((this.$controller.state & State.isBound) === 0) {\n      return;\n    }\n    if (this.task.done) {\n      this.task = this.swap(this.value, flags);\n    } else {\n      this.task = new ContinuationTask(this.task, this.swap, this, this.value, flags);\n    }\n  }\n\n  /** @internal */\n  public updateView(value: boolean, flags: LifecycleFlags): IController<T> | undefined {\n    let view: IController<T> | undefined;\n    if (value) {\n      view = this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);\n    } else if (this.elseFactory != void 0) {\n      view = this.elseView  = this.ensureView(this.elseView, this.elseFactory, flags);\n    } else {\n      view = void 0;\n    }\n    return view;\n  }\n\n  /** @internal */\n  public ensureView(view: IController<T> | undefined, factory: IViewFactory<T>, flags: LifecycleFlags): IController<T> {\n    if (view === void 0) {\n      view = factory.create(flags);\n    }\n\n    view.hold(this.location);\n\n    return view;\n  }\n\n  private swap(value: boolean, flags: LifecycleFlags): ILifecycleTask {\n    let task: ILifecycleTask = LifecycleTask.done;\n    if (\n      (value === true && this.elseView !== void 0)\n      || (value !== true && this.ifView !== void 0)\n    ) {\n      task = this.deactivate(flags);\n    }\n    if (task.done) {\n      const view = this.updateView(value, flags);\n      task = this.activate(view, flags);\n    } else {\n      task = new PromiseTask<[LifecycleFlags], IController<T> | undefined>(task.wait().then(() => this.updateView(value, flags)), this.activate, this, flags);\n    }\n    return task;\n  }\n\n  private deactivate(flags: LifecycleFlags): ILifecycleTask {\n    const view = this.view;\n    if (view === void 0) {\n      return LifecycleTask.done;\n    }\n\n    view.detach(flags); // TODO: link this up with unbind\n    return view.unbind(flags);\n  }\n\n  private activate(view: IController<T> | undefined, flags: LifecycleFlags): ILifecycleTask {\n    this.view = view;\n    if (view === void 0) {\n      return LifecycleTask.done;\n    }\n    let task = this.bindView(flags);\n    if ((this.$controller.state & State.isAttached) === 0) {\n      return task;\n    }\n\n    if (task.done) {\n      this.attachView(flags);\n    } else {\n      task = new ContinuationTask(task, this.attachView, this, flags);\n    }\n    return task;\n  }\n\n  private bindView(flags: LifecycleFlags): ILifecycleTask {\n    if (this.view !== void 0 && (this.$controller.state & State.isBoundOrBinding) > 0) {\n      return this.view.bind(flags, this.$controller.scope);\n    }\n    return LifecycleTask.done;\n  }\n\n  private attachView(flags: LifecycleFlags): void {\n    if (this.view !== void 0 && (this.$controller.state & State.isAttachedOrAttaching) > 0) {\n      this.view.attach(flags);\n    }\n  }\n}\n\nexport class Else<T extends INode = INode> {\n  public static readonly inject: InjectArray = [IViewFactory];\n\n  public static readonly kind: ICustomAttributeResource = CustomAttributeResource;\n  public static readonly description: Required<IAttributeDefinition> = {\n    name: 'else',\n    aliases: PLATFORM.emptyArray as typeof PLATFORM.emptyArray & string[],\n    defaultBindingMode: BindingMode.toView,\n    hasDynamicOptions: false,\n    isTemplateController: true,\n    bindables: PLATFORM.emptyObject,\n    strategy: BindingStrategy.getterSetter,\n    hooks: HooksDefinition.none,\n  };\n\n  private readonly factory: IViewFactory<T>;\n\n  constructor(factory: IViewFactory<T>) {\n    this.factory = factory;\n  }\n\n  public static register(container: IContainer): void {\n    container.register(Registration.transient('custom-attribute:else', this));\n  }\n\n  public link(ifBehavior: If<T> | IController<T>): void {\n    if (ifBehavior instanceof If) {\n      ifBehavior.elseFactory = this.factory;\n    } else if (ifBehavior.viewModel instanceof If) {\n      ifBehavior.viewModel.elseFactory = this.factory;\n    } else {\n      throw new Error(`Unsupported IfBehavior`); // TODO: create error code\n    }\n  }\n}\n","import {\n  compareNumber,\n  IContainer,\n  InjectArray,\n  nextId,\n  PLATFORM,\n  Registration,\n} from '@aurelia/kernel';\n\nimport { ForOfStatement } from '../../binding/ast';\nimport { Binding } from '../../binding/binding';\nimport {\n  HooksDefinition,\n  IAttributeDefinition,\n} from '../../definitions';\nimport {\n  INode,\n  INodeSequence,\n  IRenderLocation\n} from '../../dom';\nimport {\n  BindingMode,\n  BindingStrategy,\n  LifecycleFlags as LF,\n  State,\n} from '../../flags';\nimport {\n  IController,\n  IViewFactory,\n  Priority,\n} from '../../lifecycle';\nimport {\n  AggregateContinuationTask,\n  ContinuationTask,\n  ILifecycleTask,\n  LifecycleTask,\n} from '../../lifecycle-task';\nimport {\n  CollectionObserver,\n  IndexMap,\n  IObservable,\n  IObservedArray,\n  IObserversLookup,\n  IScope,\n  ObservedCollection,\n} from '../../observation';\nimport {\n  BindingContext,\n  Scope\n} from '../../observation/binding-context';\nimport { getCollectionObserver } from '../../observation/observer-locator';\nimport { SetterObserver } from '../../observation/setter-observer';\nimport { Bindable } from '../../templating/bindable';\nimport {\n  CustomAttributeResource,\n  ICustomAttributeResource,\n} from '../custom-attribute';\n\ntype Items<C extends ObservedCollection = IObservedArray> = C | undefined | undefined;\n\nconst isMountedOrAttached = State.isMounted | State.isAttached;\nconst isMountedOrAttachedOrAttaching = isMountedOrAttached | State.isAttaching;\nconst isMountedOrAttachedOrDetaching = isMountedOrAttached | State.isDetaching;\nconst isMountedOrAttachedOrDetachingOrAttaching = isMountedOrAttachedOrDetaching | State.isAttaching;\n\nexport class Repeat<C extends ObservedCollection = IObservedArray, T extends INode = INode> implements IObservable {\n  public static readonly inject: InjectArray = [IRenderLocation, IController, IViewFactory];\n\n  public static readonly kind: ICustomAttributeResource = CustomAttributeResource;\n  public static readonly description: Required<IAttributeDefinition> = Object.freeze({\n    name: 'repeat',\n    aliases: PLATFORM.emptyArray as typeof PLATFORM.emptyArray & string[],\n    defaultBindingMode: BindingMode.toView,\n    hasDynamicOptions: false,\n    isTemplateController: true,\n    bindables: Object.freeze(Bindable.for({ bindables: ['items'] }).get()),\n    strategy: BindingStrategy.getterSetter,\n    hooks: Object.freeze(new HooksDefinition(Repeat.prototype)),\n  });\n\n  public readonly id: number;\n\n  public get items(): Items<C> {\n    return this._items;\n  }\n  public set items(newValue: Items<C>) {\n    const oldValue = this._items;\n    if (oldValue !== newValue) {\n      this._items = newValue;\n      this.itemsChanged(this.$controller.flags);\n    }\n  }\n\n  public readonly $observers: IObserversLookup = {\n    items: this as this & SetterObserver,\n  };\n\n  public forOf!: ForOfStatement;\n  public hasPendingInstanceMutation: boolean;\n  public local!: string;\n  public location: IRenderLocation<T>;\n  public observer?: CollectionObserver;\n  public renderable: IController<T>;\n  public factory: IViewFactory<T>;\n  public views: IController<T>[];\n  public key?: string;\n  public readonly noProxy: true;\n\n  private task: ILifecycleTask;\n\n  // tslint:disable-next-line: prefer-readonly // This is set by the controller after this instance is constructed\n  public $controller!: IController<T>;\n\n  private _items: Items<C>;\n\n  constructor(\n    location: IRenderLocation<T>,\n    renderable: IController<T>,\n    factory: IViewFactory<T>\n  ) {\n    this.id = nextId('au$component');\n\n    this.factory = factory;\n    this.hasPendingInstanceMutation = false;\n    this.location = location;\n    this.observer = void 0;\n    this.renderable = renderable;\n    this.views = [];\n    this.key = void 0;\n    this.noProxy = true;\n\n    this.task = LifecycleTask.done;\n  }\n\n  public static register(container: IContainer): void {\n    container.register(Registration.transient('custom-attribute:repeat', this));\n    container.register(Registration.transient(this, this));\n  }\n\n  public binding(flags: LF): ILifecycleTask {\n    this.checkCollectionObserver(flags);\n    const bindings = this.renderable.bindings as Binding[];\n    const { length } = bindings;\n    let binding: Binding;\n    for (let i = 0; i < length; ++i) {\n      binding = bindings[i];\n      if (binding.target === this && binding.targetProperty === 'items') {\n        this.forOf = binding.sourceExpression as ForOfStatement;\n        break;\n      }\n    }\n    this.local = this.forOf.declaration.evaluate(flags, this.$controller.scope!, null) as string;\n\n    this.processViewsKeyed(void 0, flags);\n    return this.task;\n  }\n\n  public attaching(flags: LF): void {\n    if (this.task.done) {\n      this.attachViews(void 0, flags);\n    } else {\n      this.task = new ContinuationTask(this.task, this.attachViews, this, void 0, flags);\n    }\n  }\n\n  public detaching(flags: LF): void {\n    if (this.task.done) {\n      this.detachViewsByRange(0, this.views.length, flags);\n    } else {\n      this.task = new ContinuationTask(this.task, this.detachViewsByRange, this, 0, this.views.length, flags);\n    }\n  }\n\n  public unbinding(flags: LF): ILifecycleTask {\n    this.checkCollectionObserver(flags);\n\n    if (this.task.done) {\n      this.task = this.unbindAndRemoveViewsByRange(0, this.views.length, flags, false);\n    } else {\n      this.task = new ContinuationTask(this.task, this.unbindAndRemoveViewsByRange, this, 0, this.views.length, flags, false);\n    }\n    return this.task;\n  }\n\n  // called by SetterObserver\n  public itemsChanged(flags: LF): void {\n    flags |= this.$controller.flags;\n    this.checkCollectionObserver(flags);\n    flags |= LF.updateTargetInstance;\n    this.processViewsKeyed(void 0, flags);\n  }\n\n  // called by a CollectionObserver\n  public handleCollectionChange(indexMap: IndexMap | undefined, flags: LF): void {\n    flags |= this.$controller.flags;\n    flags |= (LF.fromFlush | LF.updateTargetInstance);\n    this.processViewsKeyed(indexMap, flags);\n  }\n\n  private processViewsKeyed(indexMap: IndexMap | undefined, flags: LF): void {\n    if (indexMap === void 0) {\n      if ((this.$controller.state & State.isBoundOrBinding) > 0) {\n        const oldLength = this.views.length;\n        this.detachViewsByRange(0, oldLength, flags);\n        if (this.task.done) {\n          this.task = this.unbindAndRemoveViewsByRange(0, oldLength, flags, false);\n        } else {\n          this.task = new ContinuationTask(this.task, this.unbindAndRemoveViewsByRange, this, 0, oldLength, flags, false);\n        }\n\n        if (this.task.done) {\n          this.task = this.createAndBindAllViews(flags);\n        } else {\n          this.task = new ContinuationTask(this.task, this.createAndBindAllViews, this, flags);\n        }\n      }\n\n      if ((this.$controller.state & State.isAttachedOrAttaching) > 0) {\n        if (this.task.done) {\n          this.attachViewsKeyed(flags);\n        } else {\n          this.task = new ContinuationTask(this.task, this.attachViewsKeyed, this, flags);\n        }\n      }\n    } else {\n      applyMutationsToIndices(indexMap);\n      if ((this.$controller.state & State.isBoundOrBinding) > 0) {\n        // first detach+unbind+(remove from array) the deleted view indices\n        if (indexMap.deletedItems.length > 0) {\n          indexMap.deletedItems.sort(compareNumber);\n          if (this.task.done) {\n            this.detachViewsByKey(indexMap, flags);\n          } else {\n            this.task = new ContinuationTask(this.task, this.detachViewsByKey, this, indexMap, flags);\n          }\n\n          if (this.task.done) {\n            this.task = this.unbindAndRemoveViewsByKey(indexMap, flags);\n          } else {\n            this.task = new ContinuationTask(this.task, this.unbindAndRemoveViewsByKey, this, indexMap, flags);\n          }\n        }\n\n        // then insert new views at the \"added\" indices to bring the views array in aligment with indexMap size\n        if (this.task.done) {\n          this.task = this.createAndBindNewViewsByKey(indexMap, flags);\n        } else {\n          this.task = new ContinuationTask(this.task, this.createAndBindNewViewsByKey, this, indexMap, flags);\n        }\n      }\n\n      if ((this.$controller.state & State.isAttachedOrAttaching) > 0) {\n        if (this.task.done) {\n          this.sortViewsByKey(indexMap, flags);\n        } else {\n          this.task = new ContinuationTask(this.task, this.sortViewsByKey, this, indexMap, flags);\n        }\n      }\n    }\n  }\n\n  private checkCollectionObserver(flags: LF): void {\n    const oldObserver = this.observer;\n    if ((this.$controller.state & State.isBoundOrBinding) > 0) {\n      const newObserver = this.observer = getCollectionObserver(flags, this.$controller.lifecycle, this.items);\n      if (oldObserver !== newObserver && oldObserver) {\n        oldObserver.unsubscribeFromCollection(this);\n      }\n      if (newObserver) {\n        newObserver.subscribeToCollection(this);\n      }\n    } else if (oldObserver) {\n      oldObserver.unsubscribeFromCollection(this);\n    }\n  }\n\n  private detachViewsByRange(iStart: number, iEnd: number, flags: LF): void {\n    const views = this.views;\n    this.$controller.lifecycle.detached.begin();\n    let view: IController<T>;\n    for (let i = iStart; i < iEnd; ++i) {\n      view = views[i];\n      view.release(flags);\n      view.detach(flags);\n    }\n    this.$controller.lifecycle.detached.end(flags);\n  }\n\n  private unbindAndRemoveViewsByRange(iStart: number, iEnd: number, flags: LF, adjustLength: boolean): ILifecycleTask {\n    const views = this.views;\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask;\n    this.$controller.lifecycle.unbound.begin();\n    let view: IController<T>;\n    for (let i = iStart; i < iEnd; ++i) {\n      view = views[i];\n      task = view.unbind(flags);\n      if (!task.done) {\n        if (tasks === undefined) {\n          tasks = [];\n        }\n        tasks.push(task);\n      }\n    }\n\n    if (adjustLength) {\n      this.views.length = iStart;\n    }\n\n    if (tasks === undefined) {\n      this.$controller.lifecycle.unbound.end(flags);\n      return LifecycleTask.done;\n    }\n\n    return new AggregateContinuationTask(\n      tasks,\n      this.$controller.lifecycle.unbound.end,\n      this.$controller.lifecycle.unbound,\n      flags,\n    );\n  }\n\n  private detachViewsByKey(indexMap: IndexMap, flags: LF): void {\n    const views = this.views;\n    this.$controller.lifecycle.detached.begin();\n    const deleted = indexMap.deletedItems;\n    const deletedLen = deleted.length;\n    let view: IController<T>;\n    for (let i = 0; i < deletedLen; ++i) {\n      view = views[deleted[i]];\n      view.release(flags);\n      view.detach(flags);\n    }\n    this.$controller.lifecycle.detached.end(flags);\n  }\n\n  private unbindAndRemoveViewsByKey(indexMap: IndexMap, flags: LF): ILifecycleTask {\n    const views = this.views;\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask;\n    this.$controller.lifecycle.unbound.begin();\n    const deleted = indexMap.deletedItems;\n    const deletedLen = deleted.length;\n    let view: IController<T>;\n    let i = 0;\n    for (; i < deletedLen; ++i) {\n      view = views[deleted[i]];\n      task = view.unbind(flags);\n      if (!task.done) {\n        if (tasks === undefined) {\n          tasks = [];\n        }\n        tasks.push(task);\n      }\n    }\n\n    i = 0;\n    let j = 0;\n    for (; i < deletedLen; ++i) {\n      j = deleted[i] - i;\n      this.views.splice(j, 1);\n    }\n\n    if (tasks === undefined) {\n      this.$controller.lifecycle.unbound.end(flags);\n      return LifecycleTask.done;\n    }\n\n    return new AggregateContinuationTask(\n      tasks,\n      this.$controller.lifecycle.unbound.end,\n      this.$controller.lifecycle.unbound,\n      flags,\n    );\n  }\n\n  private createAndBindAllViews(flags: LF): ILifecycleTask {\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask;\n    let view: IController<T>;\n    this.$controller.lifecycle.bound.begin();\n    const factory = this.factory;\n    const local = this.local;\n    const items = this.items;\n    const newLen = this.forOf.count(flags, items);\n    const views = this.views = Array(newLen);\n    this.forOf.iterate(flags, items, (arr, i, item) => {\n      view = views[i] = factory.create(flags);\n      task = view.bind(flags, this.createScope(flags, local, item, view));\n\n      if (!task.done) {\n        if (tasks === undefined) {\n          tasks = [];\n        }\n        tasks.push(task);\n      }\n    });\n\n    if (tasks === undefined) {\n      this.$controller.lifecycle.bound.end(flags);\n      return LifecycleTask.done;\n    }\n\n    return new AggregateContinuationTask(\n      tasks,\n      this.$controller.lifecycle.bound.end,\n      this.$controller.lifecycle.bound,\n      flags,\n    );\n  }\n\n  private createAndBindNewViewsByKey(indexMap: IndexMap, flags: LF): ILifecycleTask {\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask;\n    let view: IController<T>;\n    const factory = this.factory;\n    const views = this.views;\n    const local = this.local;\n    const items = this.items;\n    this.$controller.lifecycle.bound.begin();\n    const mapLen = indexMap.length;\n    for (let i = 0; i < mapLen; ++i) {\n      if (indexMap[i] === -2) {\n        view = factory.create(flags);\n        // TODO: test with map/set/undefined/null, make sure we can use strong typing here as well, etc\n        task = view.bind(flags, this.createScope(flags, local, (items as any)[i], view));\n        views.splice(i, 0, view);\n\n        if (!task.done) {\n          if (tasks === undefined) {\n            tasks = [];\n          }\n          tasks.push(task);\n        }\n      }\n    }\n\n    if (views.length !== mapLen) {\n      // TODO: create error code and use reporter with more informative message\n      throw new Error(`viewsLen=${views.length}, mapLen=${mapLen}`);\n    }\n\n    if (tasks === undefined) {\n      this.$controller.lifecycle.bound.end(flags);\n      return LifecycleTask.done;\n    }\n\n    return new AggregateContinuationTask(\n      tasks,\n      this.$controller.lifecycle.bound.end,\n      this.$controller.lifecycle.bound,\n      flags,\n    );\n  }\n\n  private createScope(\n    flags: LF,\n    local: string,\n    item: unknown,\n    view: IController<T>,\n  ): IScope {\n    const controller = this.$controller;\n    const parentScope = controller.scope!;\n    const ctx = BindingContext.create(flags, local, item);\n    ctx.$view = view;\n    const scope = Scope.fromParent(flags, parentScope, ctx);\n    if (controller.scopeParts !== PLATFORM.emptyArray) {\n      if (\n        parentScope.partScopes !== void 0 &&\n        parentScope.partScopes !== PLATFORM.emptyObject\n      ) {\n        scope.partScopes = { ...parentScope.partScopes };\n      } else {\n        scope.partScopes = {};\n      }\n\n      for (const partName of controller.scopeParts) {\n        scope.partScopes[partName] = scope;\n      }\n    }\n\n    return scope;\n  }\n\n  private attachViews(indexMap: IndexMap | undefined, flags: LF): void {\n    let view: IController<T>;\n    const { views, location } = this;\n    this.$controller.lifecycle.attached.begin();\n    if (indexMap === void 0) {\n      for (let i = 0, ii = views.length; i < ii; ++i) {\n        view = views[i];\n        view.hold(location);\n        view.nodes!.unlink();\n        view.attach(flags);\n      }\n    } else {\n      for (let i = 0, ii = views.length; i < ii; ++i) {\n        if (indexMap[i] !== i) {\n          view = views[i];\n          view.hold(location);\n          view.nodes!.unlink();\n          view.attach(flags);\n        }\n      }\n    }\n    this.$controller.lifecycle.attached.end(flags);\n  }\n\n  private attachViewsKeyed(flags: LF): void {\n    let view: IController<T>;\n    const { views, location } = this;\n    this.$controller.lifecycle.attached.begin();\n    for (let i = 0, ii = views.length; i < ii; ++i) {\n      view = views[i];\n      view.hold(location);\n      view.nodes!.unlink();\n      view.attach(flags);\n    }\n    this.$controller.lifecycle.attached.end(flags);\n  }\n\n  private sortViewsByKey(indexMap: IndexMap, flags: LF): void {\n    // TODO: integrate with tasks\n    const location = this.location;\n    const views = this.views;\n    synchronizeIndices(views, indexMap);\n\n    // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater\n    // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed\n    const seq = longestIncreasingSubsequence(indexMap);\n    const seqLen = seq.length;\n    this.$controller.lifecycle.attached.begin();\n\n    flags |= LF.reorderNodes;\n\n    let next: IController;\n    let j = seqLen - 1;\n    let i = indexMap.length - 1;\n    for (; i >= 0; --i) {\n      if (indexMap[i] === -2) {\n        views[i].hold(location);\n        views[i].attach(flags);\n      } else if (j < 0 || seqLen === 1 || i !== seq[j]) {\n        views[i].attach(flags);\n      } else {\n        --j;\n      }\n\n      next = views[i + 1];\n      if (next !== void 0) {\n        views[i].nodes!.link(next.nodes!);\n      } else {\n        views[i].nodes!.link(location);\n      }\n    }\n\n    this.$controller.lifecycle.attached.end(flags);\n  }\n}\n\nlet prevIndices: Int32Array;\nlet tailIndices: Int32Array;\nlet maxLen = 0;\n\n// Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732\n// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)\n/** @internal */\nexport function longestIncreasingSubsequence(indexMap: IndexMap): Int32Array {\n  const len = indexMap.length;\n\n  if (len > maxLen) {\n    maxLen = len;\n    prevIndices = new Int32Array(len);\n    tailIndices = new Int32Array(len);\n  }\n\n  let cursor = 0;\n  let cur = 0;\n  let prev = 0;\n  let i = 0;\n  let j = 0;\n  let low = 0;\n  let high = 0;\n  let mid = 0;\n\n  for (; i < len; i++) {\n    cur = indexMap[i];\n    if (cur !== -2) {\n      j = prevIndices[cursor];\n\n      prev = indexMap[j];\n      if (prev !== -2 && prev < cur) {\n        tailIndices[i] = j;\n        prevIndices[++cursor] = i;\n        continue;\n      }\n\n      low = 0;\n      high = cursor;\n\n      while (low < high) {\n        mid = (low + high) >> 1;\n        prev = indexMap[prevIndices[mid]];\n        if (prev !== -2 && prev < cur) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n\n      prev = indexMap[prevIndices[low]];\n      if (cur < prev || prev === -2) {\n        if (low > 0) {\n          tailIndices[i] = prevIndices[low - 1];\n        }\n        prevIndices[low] = i;\n      }\n    }\n  }\n  i = ++cursor;\n  const result = new Int32Array(i);\n  cur = prevIndices[cursor - 1];\n\n  while (cursor-- > 0) {\n    result[cursor] = cur;\n    cur = tailIndices[cur];\n  }\n  while (i-- > 0) prevIndices[i] = 0;\n  return result;\n}\n\n/**\n * Applies offsets to the non-negative indices in the IndexMap\n * based on added and deleted items relative to those indices.\n *\n * e.g. turn `[-2, 0, 1]` into `[-2, 1, 2]`, allowing the values at the indices to be\n * used for sorting/reordering items if needed\n */\nfunction applyMutationsToIndices(indexMap: IndexMap): void {\n  let offset = 0;\n  let j = 0;\n  const len = indexMap.length;\n  for (let i = 0; i < len; ++i) {\n    while (indexMap.deletedItems[j] <= i - offset) {\n      ++j;\n      --offset;\n    }\n    if (indexMap[i] === -2) {\n      ++offset;\n    } else {\n      indexMap[i] += offset;\n    }\n  }\n}\n\n/**\n * After `applyMutationsToIndices`, this function can be used to reorder items in a derived\n * array (e.g.  the items in the `views` in the repeater are derived from the `items` property)\n */\nfunction synchronizeIndices<T>(items: T[], indexMap: IndexMap): void {\n  const copy = items.slice();\n\n  const len = indexMap.length;\n  let to = 0;\n  let from = 0;\n  while (to < len) {\n    from = indexMap[to];\n    if (from !== -2) {\n      items[to] = copy[from];\n    }\n    ++to;\n  }\n}\n","import {\n  IContainer,\n  InjectArray,\n  nextId,\n  PLATFORM,\n  Registration,\n} from '@aurelia/kernel';\nimport {\n  HooksDefinition,\n  IAttributeDefinition,\n} from '../../definitions';\nimport {\n  INode,\n  IRenderLocation,\n} from '../../dom';\nimport {\n  BindingMode,\n  BindingStrategy,\n  LifecycleFlags,\n} from '../../flags';\nimport {\n  IController,\n  IViewFactory,\n} from '../../lifecycle';\nimport {\n  ILifecycleTask,\n} from '../../lifecycle-task';\nimport {\n  CustomAttributeResource,\n  ICustomAttributeResource,\n} from '../custom-attribute';\nimport { BindingContext } from '../../observation/binding-context';\n\nexport class Replaceable<T extends INode = INode> {\n  public static readonly inject: InjectArray = [IViewFactory, IRenderLocation];\n\n  public static readonly kind: ICustomAttributeResource = CustomAttributeResource;\n  public static readonly description: Required<IAttributeDefinition> = Object.freeze({\n    name: 'replaceable',\n    aliases: PLATFORM.emptyArray as typeof PLATFORM.emptyArray & string[],\n    defaultBindingMode: BindingMode.toView,\n    hasDynamicOptions: false,\n    isTemplateController: true,\n    bindables: PLATFORM.emptyObject,\n    strategy: BindingStrategy.getterSetter,\n    hooks: Object.freeze(new HooksDefinition(Replaceable.prototype)),\n  });\n\n  public readonly id: number;\n\n  public readonly view: IController<T>;\n  private readonly factory: IViewFactory<T>;\n\n  // tslint:disable-next-line: prefer-readonly // This is set by the controller after this instance is constructed\n  private $controller!: IController<T>;\n\n  constructor(\n    factory: IViewFactory<T>,\n    location: IRenderLocation<T>\n  ) {\n    this.id = nextId('au$component');\n\n    this.factory = factory;\n\n    this.view = this.factory.create();\n    this.view.hold(location);\n  }\n\n  public static register(container: IContainer): void {\n    container.register(Registration.transient('custom-attribute:replaceable', this));\n    container.register(Registration.transient(this, this));\n  }\n\n  public binding(flags: LifecycleFlags): ILifecycleTask {\n    const prevName = BindingContext.partName;\n    BindingContext.partName = this.factory.name;\n    const task = this.view.bind(flags | LifecycleFlags.allowParentScopeTraversal, this.$controller.scope);\n    if (task.done) {\n      BindingContext.partName = prevName;\n    } else {\n      task.wait().then(() => {\n        BindingContext.partName = prevName;\n      });\n    }\n    return task;\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.view.attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.view.detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): ILifecycleTask {\n    return this.view.unbind(flags);\n  }\n}\n","import {\n  IContainer,\n  InjectArray,\n  nextId,\n  PLATFORM,\n  Registration\n} from '@aurelia/kernel';\n\nimport {\n  HooksDefinition,\n  IAttributeDefinition\n} from '../../definitions';\nimport {\n  INode,\n  IRenderLocation\n} from '../../dom';\nimport {\n  BindingMode,\n  BindingStrategy,\n  LifecycleFlags,\n  State\n} from '../../flags';\nimport {\n  IController,\n  IViewFactory\n} from '../../lifecycle';\nimport { IObserversLookup } from '../../observation';\nimport { Scope } from '../../observation/binding-context';\nimport { SetterObserver } from '../../observation/setter-observer';\nimport { Bindable } from '../../templating/bindable';\nimport {\n  CustomAttributeResource,\n  ICustomAttributeResource\n} from '../custom-attribute';\n\nexport class With<T extends INode = INode> {\n  public static readonly inject: InjectArray = [IViewFactory, IRenderLocation];\n\n  public static readonly kind: ICustomAttributeResource = CustomAttributeResource;\n  public static readonly description: Required<IAttributeDefinition> = Object.freeze({\n    name: 'with',\n    aliases: PLATFORM.emptyArray as typeof PLATFORM.emptyArray & string[],\n    defaultBindingMode: BindingMode.toView,\n    hasDynamicOptions: false,\n    isTemplateController: true,\n    bindables: Object.freeze(Bindable.for({ bindables: ['value'] }).get()),\n    strategy: BindingStrategy.getterSetter,\n    hooks: Object.freeze(new HooksDefinition(With.prototype)),\n  });\n\n  public readonly id: number;\n\n  public get value(): object | undefined {\n    return this._value;\n  }\n  public set value(newValue: object | undefined) {\n    const oldValue = this._value;\n    if (oldValue !== newValue) {\n      this._value = newValue;\n      this.valueChanged(newValue, oldValue, LifecycleFlags.none);\n    }\n  }\n\n  public readonly $observers: IObserversLookup = {\n    value: this as this & SetterObserver,\n  };\n\n  public readonly view: IController<T>;\n  private readonly factory: IViewFactory<T>;\n  // tslint:disable-next-line: prefer-readonly // This is set by the controller after this instance is constructed\n  private $controller!: IController<T>;\n\n  private _value: object | undefined;\n\n  constructor(\n    factory: IViewFactory<T>,\n    location: IRenderLocation<T>\n  ) {\n    this.id = nextId('au$component');\n\n    this.factory = factory;\n    this.view = this.factory.create();\n    this.view.hold(location);\n\n    this._value = void 0;\n  }\n\n  public static register(container: IContainer): void {\n    container.register(Registration.transient('custom-attribute:with', this));\n    container.register(Registration.transient(this, this));\n  }\n\n  public valueChanged(newValue: unknown, oldValue: unknown, flags: LifecycleFlags): void {\n    if ((this.$controller.state & State.isBoundOrBinding) > 0) {\n      this.bindChild(LifecycleFlags.fromBind);\n    }\n  }\n\n  public binding(flags: LifecycleFlags): void {\n    this.bindChild(flags);\n  }\n\n  public attaching(flags: LifecycleFlags): void {\n    this.view.attach(flags);\n  }\n\n  public detaching(flags: LifecycleFlags): void {\n    this.view.detach(flags);\n  }\n\n  public unbinding(flags: LifecycleFlags): void {\n    this.view.unbind(flags);\n  }\n\n  private bindChild(flags: LifecycleFlags): void {\n    const scope = Scope.fromParent(flags, this.$controller.scope!, this.value === void 0 ? {} : this.value);\n    this.view.bind(flags, scope);\n  }\n}\n","import {\n  Class,\n  Constructable,\n  DI,\n  IContainer,\n  IResourceKind,\n  IResourceType,\n  Registration,\n  Reporter,\n  Writable\n} from '@aurelia/kernel';\n\nimport {\n  buildTemplateDefinition,\n  customElementBehavior,\n  customElementKey,\n  customElementName,\n  ITemplateDefinition,\n  TemplateDefinition\n} from '../definitions';\nimport {\n  IDOM,\n  INode,\n  INodeSequence,\n  IRenderLocation\n} from '../dom';\nimport {\n  IController,\n  IViewModel,\n} from '../lifecycle';\n\nexport interface ICustomElementType<C extends Constructable = Constructable> extends\n  IResourceType<ITemplateDefinition, InstanceType<C> & IViewModel>,\n  ICustomElementStaticProperties {\n  description: TemplateDefinition;\n}\n\nexport type CustomElementHost<T extends INode = INode> = IRenderLocation<T> & T & {\n  $controller?: IController<T>;\n};\n\nexport interface IElementProjector<T extends INode = INode> {\n  readonly host: CustomElementHost<T>;\n  readonly children: ArrayLike<CustomElementHost<T>>;\n\n  provideEncapsulationSource(): T;\n  project(nodes: INodeSequence<T>): void;\n  take(nodes: INodeSequence<T>): void;\n\n  subscribeToChildrenChange(callback: () => void): void;\n}\n\nexport const IProjectorLocator = DI.createInterface<IProjectorLocator>('IProjectorLocator').noDefault();\n\nexport interface IProjectorLocator<T extends INode = INode> {\n  getElementProjector(dom: IDOM<T>, $component: IController<T>, host: CustomElementHost<T>, def: TemplateDefinition): IElementProjector<T>;\n}\n\nexport interface ICustomElementStaticProperties {\n  containerless?: TemplateDefinition['containerless'];\n  shadowOptions?: TemplateDefinition['shadowOptions'];\n  bindables?: TemplateDefinition['bindables'];\n  strategy?: TemplateDefinition['strategy'];\n}\n\nexport interface ICustomElementResource<T extends INode = INode> extends\n  IResourceKind<ITemplateDefinition, IViewModel, Class<IViewModel> & ICustomElementStaticProperties> {\n  behaviorFor(node: T): IController<T> | undefined;\n}\n\n/** @internal */\nexport function registerElement(this: ICustomElementType, container: IContainer): void {\n  const resourceKey = this.kind.keyFrom(this.description.name);\n  container.register(Registration.transient(resourceKey, this));\n  container.register(Registration.transient(this, this));\n}\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(definition: ITemplateDefinition): ICustomElementDecorator;\nexport function customElement(name: string): ICustomElementDecorator;\nexport function customElement(nameOrDefinition: string | ITemplateDefinition): ICustomElementDecorator;\nexport function customElement(nameOrDefinition: string | ITemplateDefinition): ICustomElementDecorator {\n  return (target => CustomElementResource.define(nameOrDefinition, target)) as ICustomElementDecorator;\n}\n\nfunction isType<T>(this: ICustomElementResource, Type: T & Partial<ICustomElementType>): Type is T & ICustomElementType {\n  return Type.kind === this;\n}\n\nfunction define<T extends Constructable = Constructable>(this: ICustomElementResource, definition: ITemplateDefinition, ctor?: T | null): T & ICustomElementType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomElementResource, name: string, ctor?: T | null): T & ICustomElementType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomElementResource, nameOrDefinition: string | ITemplateDefinition, ctor: T | null): T & ICustomElementType<T>;\nfunction define<T extends Constructable = Constructable>(this: ICustomElementResource, nameOrDefinition: string | ITemplateDefinition, ctor: T | null = null): T & ICustomElementType<T> {\n  if (!nameOrDefinition) {\n    throw Reporter.error(70);\n  }\n  const Type = (ctor == null ? class HTMLOnlyElement { /* HTML Only */ } : ctor) as T & ICustomElementType<T>;\n  const WritableType = Type as Writable<ICustomElementType<T>>;\n  const description = buildTemplateDefinition(Type, nameOrDefinition);\n\n  WritableType.kind = CustomElementResource as ICustomElementResource;\n  Type.description = description;\n  Type.register = registerElement;\n\n  return Type;\n}\n\nexport const CustomElementResource = {\n  name: customElementName,\n  keyFrom: customElementKey,\n  isType,\n  behaviorFor: customElementBehavior as ICustomElementResource['behaviorFor'],\n  define\n};\n\n// tslint:enable:align\n\n// TODO\n// ## DefaultSlotProjector\n// An implementation of IElementProjector that can handle a subset of default\n// slot projection scenarios without needing real Shadow DOM.\n// ### Conditions\n// We can do a one-time, static composition of the content and view,\n// to emulate shadow DOM, if the following constraints are met:\n// * There must be exactly one slot and it must be a default slot.\n// * The default slot must not have any fallback content.\n// * The default slot must not have a custom element as its immediate parent or\n//   a slot attribute (re-projection).\n// ### Projection\n// The projector copies all content nodes to the slot's location.\n// The copy process should inject a comment node before and after the slotted\n// content, so that the bounds of the content can be clearly determined,\n// even if the slotted content has template controllers or string interpolation.\n// ### Encapsulation Source\n// Uses the same strategy as HostProjector.\n// ### Children\n// The projector adds a mutation observer to the parent node of the\n// slot comment. When direct children of that node change, the projector\n// will gather up all nodes between the start and end slot comments.\n\nexport interface ICustomElementDecorator {\n  // Using a type breaks syntax highlighting: https://github.com/Microsoft/TypeScript-TmLanguage/issues/481\n  // tslint:disable-next-line:callable-types\n  <T extends Constructable>(target: T): T & ICustomElementType<T>;\n}\n\ntype HasShadowOptions = Pick<ITemplateDefinition, 'shadowOptions'>;\n\nconst defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(options?: HasShadowOptions['shadowOptions']): (target: T & HasShadowOptions) => T & Required<HasShadowOptions>;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM<T extends Constructable>(target: T & HasShadowOptions): T & Required<HasShadowOptions>;\nexport function useShadowDOM<T extends Constructable>(targetOrOptions?: (T & HasShadowOptions) | HasShadowOptions['shadowOptions']): (T & Required<HasShadowOptions>) | ((target: T & HasShadowOptions) => (T & Required<HasShadowOptions>)) {\n  const options = typeof targetOrOptions === 'function' || !targetOrOptions\n    ? defaultShadowOptions\n    : targetOrOptions as HasShadowOptions['shadowOptions'];\n\n  function useShadowDOMDecorator(target: T & HasShadowOptions): T & Required<HasShadowOptions> {\n    target.shadowOptions = options;\n    return target as T & Required<HasShadowOptions>;\n  }\n\n  return typeof targetOrOptions === 'function' ? useShadowDOMDecorator(targetOrOptions) : useShadowDOMDecorator;\n}\n\ntype HasContainerless = Pick<ITemplateDefinition, 'containerless'>;\n\nfunction containerlessDecorator<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless> {\n  target.containerless = true;\n  return target as T & Required<HasContainerless>;\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): typeof containerlessDecorator;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless<T extends Constructable>(target: T & HasContainerless): T & Required<HasContainerless>;\nexport function containerless<T extends Constructable>(target?: T & HasContainerless): T & Required<HasContainerless> | typeof containerlessDecorator {\n  return target === undefined ? containerlessDecorator : containerlessDecorator<T>(target);\n}\n","import { DI, InjectArray, IRegistry } from '@aurelia/kernel';\nimport { ValueConverterResource } from '../value-converter';\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\n\nexport interface ISanitizer {\n /**\n  * Sanitizes the provided input.\n  * @param input The input to be sanitized.\n  */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = DI.createInterface<ISanitizer>('ISanitizer').withDefault(x => x.singleton(class {\n    public sanitize(input: string): string {\n      return input.replace(SCRIPT_REGEX, '');\n    }\n  })\n);\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\nexport class SanitizeValueConverter {\n  public static readonly inject: InjectArray = [ISanitizer];\n\n  public static register: IRegistry['register'];\n\n  private readonly sanitizer: ISanitizer;\n\n  constructor(sanitizer: ISanitizer) {\n    this.sanitizer = sanitizer;\n  }\n\n /**\n  * Process the provided markup that flows to the view.\n  * @param untrustedMarkup The untrusted markup to be sanitized.\n  */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup == null) {\n      return null;\n    }\n\n    return this.sanitizer.sanitize(untrustedMarkup);\n  }\n}\nValueConverterResource.define('sanitize', SanitizeValueConverter);\n","import { Reporter, PLATFORM } from '@aurelia/kernel';\nimport { INode } from '../dom';\nimport { LifecycleFlags, State } from '../flags';\nimport {\n  IController,\n  ILifecycle,\n  IViewFactory\n} from '../lifecycle';\nimport { ITemplate } from '../rendering-engine';\nimport { Controller } from './controller';\nimport { TemplatePartDefinitions, ITemplateDefinition } from '../definitions';\n\nexport class ViewFactory<T extends INode = INode> implements IViewFactory<T> {\n  public static maxCacheSize: number = 0xFFFF;\n\n  public isCaching: boolean;\n  public name: string;\n  public parts: TemplatePartDefinitions;\n\n  private cache: IController<T>[];\n  private cacheSize: number;\n  private readonly lifecycle: ILifecycle;\n  private readonly template: ITemplate<T>;\n\n\n  constructor(name: string, template: ITemplate<T>, lifecycle: ILifecycle) {\n    this.isCaching = false;\n\n    this.cacheSize = -1;\n    this.cache = null!;\n    this.lifecycle = lifecycle;\n    this.name = name;\n    this.template = template;\n    this.parts = PLATFORM.emptyObject;\n  }\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (typeof size === 'string') {\n        size = parseInt(size, 10);\n      }\n\n      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this.cacheSize = size;\n      }\n    }\n\n    if (this.cacheSize > 0) {\n      this.cache = [];\n    } else {\n      this.cache = null!;\n    }\n\n    this.isCaching = this.cacheSize > 0;\n  }\n\n  public canReturnToCache(controller: IController<T>): boolean {\n    return this.cache != null && this.cache.length < this.cacheSize;\n  }\n\n  public tryReturnToCache(controller: IController<T>): boolean {\n    if (this.canReturnToCache(controller)) {\n      controller.cache(LifecycleFlags.none);\n      this.cache.push(controller);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(flags?: LifecycleFlags): IController<T> {\n    const cache = this.cache;\n    let controller: IController<T>;\n\n    if (cache != null && cache.length > 0) {\n      controller = cache.pop()!;\n      controller.state = (controller.state | State.isCached) ^ State.isCached;\n      return controller;\n    }\n\n    controller = Controller.forSyntheticView(this, this.lifecycle, flags);\n    this.template.render(controller, null!, this.parts, flags);\n    if (!controller.nodes) {\n      throw Reporter.error(90);\n    }\n    return controller;\n  }\n\n  public addParts(parts: Record<string, ITemplateDefinition>): void {\n    if (this.parts === PLATFORM.emptyObject) {\n      this.parts = { ...parts };\n    } else {\n      Object.assign(this.parts, parts);\n    }\n  }\n}\n","import {\n  all,\n  DI,\n  IContainer,\n  IDisposable,\n  InjectArray,\n  InstanceProvider,\n  IRegistry,\n  IResolver,\n  IResourceDescriptions,\n  IServiceLocator,\n  PLATFORM,\n  Reporter,\n  RuntimeCompilationResources,\n  Writable,\n} from '@aurelia/kernel';\n\nimport {\n  buildTemplateDefinition,\n  customElementBehavior,\n  InstructionTypeName,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TemplateDefinition,\n  TemplatePartDefinitions,\n} from './definitions';\nimport {\n  IDOM,\n  INode,\n  INodeSequenceFactory,\n  IRenderLocation,\n  NodeSequence,\n} from './dom';\nimport { LifecycleFlags } from './flags';\nimport {\n  IController,\n  ILifecycle,\n  IRenderContext,\n  IViewFactory,\n  IViewModel,\n  Priority,\n} from './lifecycle';\nimport {\n  IAccessor,\n  ISubscribable,\n  ISubscriber,\n  ISubscriberCollection,\n} from './observation';\nimport { subscriberCollection } from './observation/subscriber-collection';\nimport {\n  ICustomElementType,\n  IElementProjector,\n} from './resources/custom-element';\nimport { Controller } from './templating/controller';\nimport { ViewFactory } from './templating/view';\n\nexport interface ITemplateCompiler {\n  readonly name: string;\n  compile(dom: IDOM, definition: ITemplateDefinition, resources: IResourceDescriptions, viewCompileFlags?: ViewCompileFlags): TemplateDefinition;\n}\n\nexport const ITemplateCompiler = DI.createInterface<ITemplateCompiler>('ITemplateCompiler').noDefault();\n\nexport enum ViewCompileFlags {\n  none        = 0b0_001,\n  surrogate   = 0b0_010,\n  shadowDOM   = 0b0_100,\n}\n\nexport interface ITemplateFactory<T extends INode = INode> {\n  create(parentRenderContext: IRenderContext<T>, definition: TemplateDefinition): ITemplate<T>;\n}\n\nexport const ITemplateFactory = DI.createInterface<ITemplateFactory>('ITemplateFactory').noDefault();\n\n// The basic template abstraction that allows consumers to create\n// instances of an INodeSequence on-demand. Templates are contextual in that they are, in the very least,\n// part of a particular application, with application-level resources, but they also may have their\n// own scoped resources or be part of another view (via a template controller) which provides a\n// context for the template.\nexport interface ITemplate<T extends INode = INode> {\n  readonly renderContext: IRenderContext<T>;\n  readonly dom: IDOM<T>;\n  readonly definition: TemplateDefinition\n  render(controller: IController<T>, host?: T, parts?: Record<string, ITemplateDefinition>, flags?: LifecycleFlags): void;\n  render(viewModel: IViewModel<T>, host?: T, parts?: Record<string, ITemplateDefinition>, flags?: LifecycleFlags): void;\n}\n\n// This is the main implementation of ITemplate.\n// It is used to create instances of IController based on a compiled TemplateDefinition.\n// TemplateDefinitions are hand-coded today, but will ultimately be the output of the\n// TemplateCompiler either through a JIT or AOT process.\n// Essentially, CompiledTemplate wraps up the small bit of code that is needed to take a TemplateDefinition\n// and create instances of it on demand.\nexport class CompiledTemplate<T extends INode = INode> implements ITemplate {\n  public readonly factory: INodeSequenceFactory<T>;\n  public readonly renderContext: IRenderContext<T>;\n  public readonly dom: IDOM<T>;\n\n  public readonly definition: TemplateDefinition;\n\n  constructor(dom: IDOM<T>, definition: TemplateDefinition, factory: INodeSequenceFactory<T>, renderContext: IRenderContext<T>) {\n    this.dom = dom;\n    this.definition = definition;\n    this.factory = factory;\n    this.renderContext = renderContext;\n  }\n\n  public render(viewModel: IViewModel<T>, host?: T, parts?: TemplatePartDefinitions, flags?: LifecycleFlags): void;\n  public render(controller: IController<T>, host?: T, parts?: TemplatePartDefinitions, flags?: LifecycleFlags): void;\n  public render(viewModelOrController: IViewModel<T> | IController<T>, host?: T, parts?: TemplatePartDefinitions, flags: LifecycleFlags = LifecycleFlags.none): void {\n    const controller = viewModelOrController instanceof Controller\n      ? viewModelOrController as IController<T>\n      : (viewModelOrController as IViewModel<T>).$controller;\n    if (controller == void 0) {\n      throw new Error(`Controller is missing from the view model`); // TODO: create error code\n    }\n    const nodes = (controller as Writable<IController>).nodes = this.factory.createNodeSequence();\n    (controller as Writable<IController>).context = this.renderContext;\n    flags |= this.definition.strategy;\n    this.renderContext.render(flags, controller, nodes.findTargets(), this.definition, host, parts);\n  }\n}\n\n// This is an implementation of ITemplate that always returns a node sequence representing \"no DOM\" to render.\n/** @internal */\nexport const noViewTemplate: ITemplate = {\n  renderContext: (void 0)!,\n  dom: (void 0)!,\n  definition: (void 0)!,\n  render(viewModelOrController: IViewModel | IController): void {\n    const controller = viewModelOrController instanceof Controller ? viewModelOrController : (viewModelOrController as IViewModel).$controller;\n    (controller as Writable<IController>).nodes = NodeSequence.empty;\n    (controller as Writable<IController>).context = void 0;\n  }\n};\n\nconst defaultCompilerName = 'default';\n\nexport interface IInstructionTypeClassifier<TType extends string = string> {\n  instructionType: TType;\n}\n\nexport interface IInstructionRenderer<\n  TType extends InstructionTypeName = InstructionTypeName\n> extends Partial<IInstructionTypeClassifier<TType>> {\n  render(\n    flags: LifecycleFlags,\n    dom: IDOM,\n    context: IRenderContext,\n    renderable: IController,\n    target: unknown,\n    instruction: ITargetedInstruction,\n    ...rest: unknown[]\n  ): void;\n}\n\nexport const IInstructionRenderer = DI.createInterface<IInstructionRenderer>('IInstructionRenderer').noDefault();\n\nexport interface IRenderer {\n  instructionRenderers: Record<string, IInstructionRenderer>;\n  render(\n    flags: LifecycleFlags,\n    dom: IDOM,\n    context: IRenderContext,\n    renderable: IController,\n    targets: ArrayLike<INode>,\n    templateDefinition: TemplateDefinition,\n    host?: INode,\n    parts?: TemplatePartDefinitions\n  ): void;\n}\n\nexport const IRenderer = DI.createInterface<IRenderer>('IRenderer').noDefault();\n\nexport interface IRenderingEngine {\n  getElementTemplate<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: TemplateDefinition,\n    parentContext?: IContainer | IRenderContext<T>,\n    componentType?: ICustomElementType,\n  ): ITemplate<T>;\n\n  getViewFactory<T extends INode = INode>(\n    dom: IDOM<T>,\n    source: ITemplateDefinition,\n    parentContext?: IContainer | IRenderContext<T>,\n  ): IViewFactory<T>;\n}\n\nexport const IRenderingEngine = DI.createInterface<IRenderingEngine>('IRenderingEngine').withDefault(x => x.singleton(RenderingEngine));\n\n/** @internal */\nexport class RenderingEngine implements IRenderingEngine {\n  public static readonly inject: InjectArray = [IContainer, ITemplateFactory, ILifecycle, all(ITemplateCompiler)];\n\n  private readonly compilers: Record<string, ITemplateCompiler>;\n  private readonly container: IContainer;\n  private readonly templateFactory: ITemplateFactory;\n  private readonly viewFactoryLookup: Map<ITemplateDefinition, IViewFactory>;\n  private readonly lifecycle: ILifecycle;\n  private readonly templateLookup: Map<TemplateDefinition, ITemplate>;\n\n  constructor(container: IContainer, templateFactory: ITemplateFactory, lifecycle: ILifecycle, templateCompilers: ITemplateCompiler[]) {\n    this.container = container;\n    this.templateFactory = templateFactory;\n    this.viewFactoryLookup = new Map();\n    this.lifecycle = lifecycle;\n    this.templateLookup = new Map();\n\n    this.compilers = templateCompilers.reduce(\n      (acc, item) => {\n        acc[item.name] = item;\n        return acc;\n      },\n      Object.create(null)\n    );\n  }\n\n  // @ts-ignore\n  public getElementTemplate<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: TemplateDefinition,\n    parentContext?: IContainer | IRenderContext<T>,\n    componentType?: ICustomElementType\n  ): ITemplate<T> | undefined {\n    if (definition == void 0) {\n      return void 0;\n    }\n\n    let found = this.templateLookup.get(definition);\n\n    if (!found) {\n      found = this.templateFromSource(dom, definition, parentContext, componentType);\n\n      this.templateLookup.set(definition, found);\n    }\n\n    return found as ITemplate<T>;\n  }\n\n  public getViewFactory<T extends INode = INode>(\n    dom: IDOM<T>,\n    definition: ITemplateDefinition,\n    parentContext?: IContainer | IRenderContext<T>\n  ): IViewFactory<T> {\n    if (definition == void 0) {\n      throw new Error(`No definition provided`); // TODO: create error code\n    }\n\n    let factory = this.viewFactoryLookup.get(definition);\n\n    if (!factory) {\n      const validSource = buildTemplateDefinition(null, definition);\n      const template = this.templateFromSource(dom, validSource, parentContext, void 0);\n      factory = new ViewFactory(validSource.name, template, this.lifecycle);\n      factory.setCacheSize(validSource.cache, true);\n      this.viewFactoryLookup.set(definition, factory);\n    }\n\n    return factory as IViewFactory<T>;\n  }\n\n  private templateFromSource(\n    dom: IDOM,\n    definition: TemplateDefinition,\n    parentContext?: IContainer | IRenderContext,\n    componentType?: ICustomElementType\n  ): ITemplate {\n    if (parentContext == void 0) {\n      parentContext = this.container as ExposedContext;\n    }\n\n    if (definition.template != void 0) {\n      const renderContext = createRenderContext(dom, parentContext, definition.dependencies, componentType) as ExposedContext;\n\n      if (definition.build.required) {\n        const compilerName = definition.build.compiler || defaultCompilerName;\n        const compiler = this.compilers[compilerName];\n\n        if (compiler === undefined) {\n          throw Reporter.error(20, compilerName);\n        }\n\n        definition = compiler.compile(dom, definition as ITemplateDefinition, new RuntimeCompilationResources(renderContext), ViewCompileFlags.surrogate);\n      }\n\n      return this.templateFactory.create(renderContext, definition);\n    }\n\n    return noViewTemplate;\n  }\n}\n\nexport function createRenderContext(\n  dom: IDOM,\n  parent: IRenderContext | IContainer,\n  dependencies: IRegistry[],\n  componentType?: ICustomElementType\n): IRenderContext {\n  const context = parent.createChild() as ExposedContext;\n  const renderableProvider = new InstanceProvider();\n  const elementProvider = new InstanceProvider();\n  const instructionProvider = new InstanceProvider<ITargetedInstruction>();\n  const factoryProvider = new ViewFactoryProvider();\n  const renderLocationProvider = new InstanceProvider<IRenderLocation>();\n  const renderer = context.get(IRenderer);\n\n  dom.registerElementResolver(context, elementProvider);\n\n  context.registerResolver(IViewFactory, factoryProvider);\n  context.registerResolver(IController, renderableProvider);\n  context.registerResolver(ITargetedInstruction, instructionProvider);\n  context.registerResolver(IRenderLocation, renderLocationProvider);\n\n  if (dependencies != void 0) {\n    context.register(...dependencies);\n  }\n\n  //If the element has a view, support Recursive Components by adding self to own view template container.\n  if (componentType) {\n    componentType.register(context);\n  }\n\n  context.render = function(\n    this: IRenderContext,\n    flags: LifecycleFlags,\n    renderable: IController,\n    targets: ArrayLike<INode>,\n    templateDefinition: TemplateDefinition,\n    host?: INode,\n    parts?: TemplatePartDefinitions,\n  ): void {\n    renderer.render(flags, dom, this, renderable, targets, templateDefinition, host, parts);\n  };\n\n  // @ts-ignore\n  context.beginComponentOperation = function(\n    renderable: IController,\n    target: INode,\n    instruction: ITargetedInstruction,\n    factory: IViewFactory | null,\n    parts?: TemplatePartDefinitions,\n    location?: IRenderLocation,\n  ): IDisposable {\n    renderableProvider.prepare(renderable);\n    elementProvider.prepare(target);\n    instructionProvider.prepare(instruction);\n\n    if (factory) {\n      factoryProvider.prepare(factory, parts!);\n    }\n\n    if (location) {\n      renderLocationProvider.prepare(location);\n    }\n\n    return context;\n  };\n\n  context.dispose = function (): void {\n    factoryProvider.dispose();\n    renderableProvider.dispose();\n    instructionProvider.dispose();\n    elementProvider.dispose();\n    renderLocationProvider.dispose();\n  };\n\n  return context;\n}\n\n\n/** @internal */\nexport class ViewFactoryProvider implements IResolver {\n  private factory!: IViewFactory | null;\n\n  public prepare(factory: IViewFactory, parts: TemplatePartDefinitions): void {\n    this.factory = factory;\n    factory.addParts(parts);\n  }\n\n  public resolve(handler: IContainer, requestor: ExposedContext): IViewFactory {\n    const factory = this.factory;\n    if (factory == null) { // unmet precondition: call prepare\n      throw Reporter.error(50); // TODO: organize error codes\n    }\n    if (!factory.name || !factory.name.length) { // unmet invariant: factory must have a name\n      throw Reporter.error(51); // TODO: organize error codes\n    }\n    const found = factory.parts[factory.name];\n    if (found) {\n      const renderingEngine = handler.get(IRenderingEngine);\n      const dom = handler.get(IDOM);\n      return renderingEngine.getViewFactory(dom, found, requestor);\n    }\n\n    return factory;\n  }\n\n  public dispose(): void {\n    this.factory = null;\n  }\n}\n\nexport interface IChildrenObserver extends\n  IAccessor,\n  ISubscribable,\n  ISubscriberCollection { }\n\ntype HasChildrenChanged = IViewModel & { $childrenChanged(): void };\nfunction hasChildrenChanged(viewModel: IViewModel | undefined): viewModel is HasChildrenChanged {\n  return viewModel != void 0 && '$childrenChanged' in viewModel;\n}\n\n/** @internal */\n@subscriberCollection()\nexport class ChildrenObserver implements Partial<IChildrenObserver> {\n  [key: number]: LifecycleFlags;\n  public hasChanges: boolean;\n\n  private readonly controller: IController;\n  private readonly lifecycle: ILifecycle;\n  private readonly projector: IElementProjector;\n  private children: IController[];\n  private observing: boolean;\n  private ticking: boolean;\n\n  constructor(lifecycle: ILifecycle, controller: IController) {\n    this.hasChanges = false;\n\n    this.children = (void 0)!;\n    this.controller = controller;\n    this.lifecycle = lifecycle;\n    this.controller = Controller.forCustomElement(controller, (void 0)!, (void 0)!);\n    this.projector = this.controller.projector!;\n    this.observing = false;\n    this.ticking = false;\n  }\n\n  public getValue(): IController[] {\n    if (!this.observing) {\n      this.observing = true;\n      this.projector.subscribeToChildrenChange(() => { this.onChildrenChanged(); });\n      this.children = findElements(this.projector.children);\n    }\n\n    return this.children;\n  }\n\n  public setValue(newValue: unknown): void { /* do nothing */ }\n\n  public flushRAF(this: ChildrenObserver & IChildrenObserver, flags: LifecycleFlags): void {\n    if (this.hasChanges) {\n      this.callSubscribers(this.children, undefined, flags | LifecycleFlags.updateTargetInstance);\n      this.hasChanges = false;\n    }\n  }\n\n  public subscribe(this: ChildrenObserver & IChildrenObserver, subscriber: ISubscriber): void {\n    if (!this.ticking) {\n      this.ticking = true;\n      this.lifecycle.enqueueRAF(this.flushRAF, this, Priority.bind);\n    }\n    this.addSubscriber(subscriber);\n  }\n\n  public unsubscribe(this: ChildrenObserver & IChildrenObserver, subscriber: ISubscriber): void {\n    this.removeSubscriber(subscriber);\n    if (this.ticking && !this.hasSubscribers()) {\n      this.ticking = false;\n      this.lifecycle.dequeueRAF(this.flushRAF, this);\n    }\n  }\n\n  private onChildrenChanged(): void {\n    this.children = findElements(this.projector.children);\n\n    if (hasChildrenChanged(this.controller.viewModel)) {\n      this.controller.viewModel.$childrenChanged();\n    }\n\n    this.hasChanges = true;\n  }\n}\n\n/** @internal */\nexport function findElements<T extends INode = INode>(nodes: ArrayLike<T>): IController<T>[] {\n  const components: IController<T>[] = [];\n\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const current = nodes[i];\n    const component = customElementBehavior<T>(current);\n\n    if (component != void 0) {\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n\n/** @internal */\nexport type ExposedContext = IRenderContext & IDisposable & IContainer;\n","import {\n  IContainer,\n  IIndexable,\n  IServiceLocator,\n  nextId,\n  PLATFORM,\n  Writable,\n} from '@aurelia/kernel';\n\nimport {\n  Binding,\n} from '../binding/binding';\nimport {\n  HooksDefinition,\n  IAttributeDefinition,\n  IBindableDescription,\n  IElementHydrationOptions,\n  ITemplateDefinition,\n  TemplateDefinition,\n  IHydrateElementInstruction,\n  TargetedInstructionType,\n  IHydrateTemplateController\n} from '../definitions';\nimport {\n  IDOM,\n  INode,\n  INodeSequence,\n  IRenderLocation\n} from '../dom';\nimport {\n  LifecycleFlags,\n  State\n} from '../flags';\nimport {\n  IBinding,\n  IController,\n  ILifecycle,\n  IRenderContext,\n  IViewCache,\n  IViewModel,\n  ViewModelKind\n} from '../lifecycle';\nimport {\n  AggregateContinuationTask,\n  ContinuationTask,\n  hasAsyncWork,\n  ILifecycleTask,\n  LifecycleTask,\n  MaybePromiseOrTask,\n} from '../lifecycle-task';\nimport {\n  IBindingTargetAccessor,\n  IScope,\n} from '../observation';\nimport {\n  Scope,\n} from '../observation/binding-context';\nimport {\n  ProxyObserver,\n} from '../observation/proxy-observer';\nimport {\n  SelfObserver,\n} from '../observation/self-observer';\nimport {\n  IRenderingEngine, ITemplate,\n} from '../rendering-engine';\nimport {\n  ICustomElementType,\n  IElementProjector,\n  IProjectorLocator\n} from '../resources/custom-element';\n\ntype Description = Required<IAttributeDefinition> | Required<ITemplateDefinition>;\ntype Kind = { name: string };\n\nfunction hasDescription(type: unknown): type is ({ description: Description; kind: Kind }) {\n  return (type as { description: Description }).description != void 0;\n}\n\ninterface IElementTemplateProvider {\n  getElementTemplate(renderingEngine: unknown, customElementType: unknown, parentContext: IServiceLocator): ITemplate;\n}\n\ntype BindingContext<T extends INode, C extends IViewModel<T>> = C & IIndexable & {\n  render(flags: LifecycleFlags, host: T, parts: Record<string, TemplateDefinition>, parentContext: IServiceLocator): IElementTemplateProvider | void;\n  created(flags: LifecycleFlags): void;\n\n  binding(flags: LifecycleFlags): MaybePromiseOrTask;\n  bound(flags: LifecycleFlags): void;\n\n  unbinding(flags: LifecycleFlags): MaybePromiseOrTask;\n  unbound(flags: LifecycleFlags): void;\n\n  attaching(flags: LifecycleFlags): void;\n  attached(flags: LifecycleFlags): void;\n\n  detaching(flags: LifecycleFlags): void;\n  detached(flags: LifecycleFlags): void;\n\n  caching(flags: LifecycleFlags): void;\n};\n\nexport class Controller<\n  T extends INode = INode,\n  C extends IViewModel<T> = IViewModel<T>\n> implements IController<T, C> {\n  private static readonly lookup: WeakMap<object, Controller> = new WeakMap();\n\n  public readonly id: number;\n\n  public nextBound?: Controller<T, C>;\n  public nextUnbound?: Controller<T, C>;\n  public prevBound?: Controller<T, C>;\n  public prevUnbound?: Controller<T, C>;\n\n  public nextAttached?: Controller<T, C>;\n  public nextDetached?: Controller<T, C>;\n  public prevAttached?: Controller<T, C>;\n  public prevDetached?: Controller<T, C>;\n\n  public nextMount?: Controller<T, C>;\n  public nextUnmount?: Controller<T, C>;\n  public prevMount?: Controller<T, C>;\n  public prevUnmount?: Controller<T, C>;\n\n  public readonly flags: LifecycleFlags;\n  public readonly viewCache?: IViewCache<T>;\n\n  public bindings?: IBinding[];\n  public controllers?: Controller<T, C>[];\n\n  public state: State;\n\n  public readonly lifecycle: ILifecycle;\n\n  public readonly hooks: HooksDefinition;\n  public readonly viewModel?: C;\n  public readonly bindingContext?: BindingContext<T, C>;\n\n  public readonly host?: T;\n\n  public readonly vmKind: ViewModelKind;\n\n  public scope?: IScope;\n  public projector?: IElementProjector;\n\n  public nodes?: INodeSequence<T>;\n  public context?: IContainer | IRenderContext<T>;\n  public location?: IRenderLocation<T>;\n\n  public readonly scopeParts: readonly string[];\n\n  constructor(\n    flags: LifecycleFlags,\n    viewCache: IViewCache<T> | undefined,\n    lifecycle: ILifecycle | undefined,\n    viewModel: C | undefined,\n    parentContext: IContainer | IRenderContext<T> | undefined,\n    host: T | undefined,\n    options: Partial<IElementHydrationOptions>,\n    scopeParts: readonly string[],\n  ) {\n    this.id = nextId('au$component');\n\n    this.nextBound = void 0;\n    this.nextUnbound = void 0;\n    this.prevBound = void 0;\n    this.prevUnbound = void 0;\n\n    this.nextAttached = void 0;\n    this.nextDetached = void 0;\n    this.prevAttached = void 0;\n    this.prevDetached = void 0;\n\n    this.nextMount = void 0;\n    this.nextUnmount = void 0;\n    this.prevMount = void 0;\n    this.prevUnmount = void 0;\n\n    this.flags = flags;\n    this.viewCache = viewCache;\n\n    this.bindings = void 0;\n    this.controllers = void 0;\n\n    this.state = State.none;\n\n    this.scopeParts = scopeParts;\n\n    if (viewModel == void 0) {\n      if (viewCache == void 0) {\n        // TODO: create error code\n        throw new Error(`No IViewCache was provided when rendering a synthetic view.`);\n      }\n      if (lifecycle == void 0) {\n        // TODO: create error code\n        throw new Error(`No ILifecycle was provided when rendering a synthetic view.`);\n      }\n      this.lifecycle = lifecycle;\n\n      this.hooks = HooksDefinition.none;\n      this.viewModel = void 0;\n      this.bindingContext = void 0; // stays undefined\n\n      this.host = void 0; // stays undefined\n\n      this.vmKind = ViewModelKind.synthetic;\n\n      this.scope = void 0; // will be populated during bindSynthetic()\n      this.projector = void 0; // stays undefined\n\n      this.nodes = void 0; // will be populated during ITemplate.render() immediately after the constructor is done\n      this.context = void 0; // will be populated during ITemplate.render() immediately after the constructor is done\n      this.location = void 0; // should be set with `hold(location)` by the consumer\n    } else {\n      if (parentContext == void 0) {\n        // TODO: create error code\n        throw new Error(`No parentContext was provided when rendering a custom element or attribute.`);\n      }\n      this.lifecycle = parentContext.get(ILifecycle);\n\n      (viewModel as Writable<C>).$controller = this;\n\n      const Type = viewModel.constructor;\n      if (!hasDescription(Type)) {\n        // TODO: create error code\n        throw new Error(`The provided viewModel does not have a (valid) description.`);\n      }\n      const { description } = Type;\n      flags |= description.strategy;\n      createObservers(this.lifecycle, description, flags, viewModel);\n      this.hooks = description.hooks;\n      this.viewModel = viewModel;\n      this.bindingContext = getBindingContext<T, C>(flags, viewModel);\n\n      this.host = host;\n\n      switch (Type.kind.name) {\n        case 'custom-element':\n          if (host == void 0) {\n            // TODO: create error code\n            throw new Error(`No host element was provided when rendering a custom element.`);\n          }\n\n          this.vmKind = ViewModelKind.customElement;\n\n          const renderingEngine = parentContext.get(IRenderingEngine);\n\n          let template: ITemplate<INode> | undefined = void 0;\n          if (this.hooks.hasRender) {\n            const result = this.bindingContext.render(\n              flags,\n              host,\n              options.parts == void 0\n                ? PLATFORM.emptyObject\n                : options.parts,\n              parentContext,\n            );\n\n            if (result != void 0 && 'getElementTemplate' in result) {\n              template = result.getElementTemplate(renderingEngine, Type, parentContext);\n            }\n          } else {\n            const dom = parentContext.get(IDOM);\n            template = renderingEngine.getElementTemplate(dom, description, parentContext, Type as ICustomElementType);\n          }\n\n          if (template !== void 0) {\n            let parts: Record<string, TemplateDefinition>;\n            if (\n              template.definition == null ||\n              template.definition.instructions.length === 0 ||\n              template.definition.instructions[0].length === 0 ||\n              (\n                (template.definition.instructions[0][0] as IHydrateElementInstruction | IHydrateTemplateController).parts == void 0\n              )\n            ) {\n              if (options.parts == void 0) {\n                parts = PLATFORM.emptyObject;\n              } else {\n                parts = options.parts;\n              }\n            } else {\n              const instruction = template.definition.instructions[0][0] as IHydrateElementInstruction | IHydrateTemplateController;\n              if (options.parts == void 0) {\n                parts = instruction.parts as typeof parts;\n              } else {\n                parts = { ...options.parts, ...(instruction.parts as typeof parts) };\n              }\n\n              if (scopeParts === PLATFORM.emptyArray) {\n                this.scopeParts = Object.keys(instruction.parts!);\n              }\n            }\n            template.render(this, host, parts);\n          }\n\n          this.scope = Scope.create(flags, this.bindingContext, null);\n\n          this.projector = parentContext.get(IProjectorLocator).getElementProjector(\n            parentContext.get(IDOM),\n            this,\n            host,\n            description\n          );\n\n          this.location = void 0;\n          break;\n        case 'custom-attribute':\n          this.vmKind = ViewModelKind.customAttribute;\n\n          this.scope = void 0;\n          this.projector = void 0;\n\n          this.nodes = void 0;\n          this.context = void 0;\n          this.location = void 0;\n          break;\n        default:\n          throw new Error(`Invalid resource kind: '${Type.kind.name}'`);\n      }\n\n      if (this.hooks.hasCreated) {\n        this.bindingContext.created(flags);\n      }\n    }\n  }\n\n  public static forCustomElement<T extends INode = INode>(\n    viewModel: object,\n    parentContext: IContainer | IRenderContext<T>,\n    host: T,\n    flags: LifecycleFlags = LifecycleFlags.none,\n    options: IElementHydrationOptions = PLATFORM.emptyObject,\n  ): Controller<T> {\n    let controller = Controller.lookup.get(viewModel) as Controller<T> | undefined;\n    if (controller === void 0) {\n      controller = new Controller<T>(\n        flags,\n        void 0,\n        void 0,\n        viewModel,\n        parentContext,\n        host,\n        options,\n        PLATFORM.emptyArray,\n      );\n      this.lookup.set(viewModel, controller);\n    }\n    return controller;\n  }\n\n  public static forCustomAttribute<T extends INode = INode>(\n    viewModel: object,\n    parentContext: IContainer | IRenderContext<T>,\n    flags: LifecycleFlags = LifecycleFlags.none,\n    scopeParts: readonly string[] = PLATFORM.emptyArray,\n  ): Controller<T> {\n    let controller = Controller.lookup.get(viewModel) as Controller<T> | undefined;\n    if (controller === void 0) {\n      controller = new Controller<T>(\n        flags,\n        void 0,\n        void 0,\n        viewModel,\n        parentContext,\n        void 0,\n        PLATFORM.emptyObject,\n        scopeParts,\n      );\n      this.lookup.set(viewModel, controller);\n    }\n    return controller;\n  }\n\n  public static forSyntheticView<T extends INode = INode>(\n    viewCache: IViewCache<T>,\n    lifecycle: ILifecycle,\n    flags: LifecycleFlags = LifecycleFlags.none,\n  ): Controller<T> {\n    return new Controller<T>(\n      flags,\n      viewCache,\n      lifecycle,\n      void 0,\n      void 0,\n      void 0,\n      PLATFORM.emptyObject,\n      PLATFORM.emptyArray,\n    );\n  }\n\n  public lockScope(scope: IScope): void {\n    this.scope = scope;\n    this.state |= State.hasLockedScope;\n  }\n\n  public hold(location: IRenderLocation<T>): void {\n    this.state = (this.state | State.canBeCached) ^ State.canBeCached;\n    this.location = location;\n  }\n\n  public release(flags: LifecycleFlags): boolean {\n    this.state |= State.canBeCached;\n    if ((this.state & State.isAttached) > 0) {\n      // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n      return this.viewCache!.canReturnToCache(this);\n    }\n\n    return this.unmountSynthetic(flags);\n  }\n\n  public bind(flags: LifecycleFlags, scope?: IScope): ILifecycleTask {\n    // TODO: benchmark which of these techniques is fastest:\n    // - the current one (enum with switch)\n    // - set the name of the method in the constructor, e.g. this.bindMethod = 'bindCustomElement'\n    //    and then doing this[this.bindMethod](flags, scope) instead of switch (eliminates branching\n    //    but computed property access might be harmful to browser optimizations)\n    // - make bind() a property and set it to one of the 3 methods in the constructor,\n    //    e.g. this.bind = this.bindCustomElement (eliminates branching + reduces call stack depth by 1,\n    //    but might make the call site megamorphic)\n    flags |= LifecycleFlags.fromBind;\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        return this.bindCustomElement(flags, scope);\n      case ViewModelKind.customAttribute:\n        return this.bindCustomAttribute(flags, scope);\n      case ViewModelKind.synthetic:\n        return this.bindSynthetic(flags, scope);\n    }\n  }\n\n  public unbind(flags: LifecycleFlags): ILifecycleTask {\n    flags |= LifecycleFlags.fromUnbind;\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        return this.unbindCustomElement(flags);\n      case ViewModelKind.customAttribute:\n        return this.unbindCustomAttribute(flags);\n      case ViewModelKind.synthetic:\n        return this.unbindSynthetic(flags);\n    }\n  }\n\n  public bound(flags: LifecycleFlags): void {\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.bindingContext!.bound(flags);\n  }\n\n  public unbound(flags: LifecycleFlags): void {\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.bindingContext!.unbound(flags);\n  }\n\n  public attach(flags: LifecycleFlags): void {\n    if ((this.state & State.isAttachedOrAttaching) > 0 && (flags & LifecycleFlags.reorderNodes) === 0) {\n      return;\n    }\n\n    flags |= LifecycleFlags.fromAttach;\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        this.attachCustomElement(flags);\n        break;\n      case ViewModelKind.customAttribute:\n        this.attachCustomAttribute(flags);\n        break;\n      case ViewModelKind.synthetic:\n        this.attachSynthetic(flags);\n    }\n  }\n\n  public detach(flags: LifecycleFlags): void {\n    if ((this.state & State.isAttachedOrAttaching) === 0) {\n      return;\n    }\n\n    flags |= LifecycleFlags.fromDetach;\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        this.detachCustomElement(flags);\n        break;\n      case ViewModelKind.customAttribute:\n        this.detachCustomAttribute(flags);\n        break;\n      case ViewModelKind.synthetic:\n        this.detachSynthetic(flags);\n    }\n  }\n\n  public attached(flags: LifecycleFlags): void {\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.bindingContext!.attached(flags);\n  }\n\n  public detached(flags: LifecycleFlags): void {\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.bindingContext!.detached(flags);\n  }\n\n  public mount(flags: LifecycleFlags): void {\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        this.mountCustomElement(flags);\n        break;\n      case ViewModelKind.synthetic:\n        this.mountSynthetic(flags);\n    }\n  }\n\n  public unmount(flags: LifecycleFlags): void {\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        this.unmountCustomElement(flags);\n        break;\n      case ViewModelKind.synthetic:\n        this.unmountSynthetic(flags);\n    }\n  }\n\n  public cache(flags: LifecycleFlags): void {\n    switch (this.vmKind) {\n      case ViewModelKind.customElement:\n        this.cacheCustomElement(flags);\n        break;\n      case ViewModelKind.customAttribute:\n        this.cacheCustomAttribute(flags);\n        break;\n      case ViewModelKind.synthetic:\n        this.cacheSynthetic(flags);\n    }\n  }\n\n  public getTargetAccessor(propertyName: string): IBindingTargetAccessor | undefined {\n    const { bindings } = this;\n    if (bindings !== void 0) {\n      const binding = bindings.find(b => (b as Binding).targetProperty === propertyName) as Binding;\n      if (binding !== void 0) {\n        return binding.targetObserver;\n      }\n    }\n    return void 0;\n  }\n\n  // #region bind/unbind\n  private bindCustomElement(flags: LifecycleFlags, scope?: IScope): ILifecycleTask {\n    const $scope = this.scope as Writable<IScope>;\n\n    if ($scope.partScopes == void 0) {\n      if (\n        scope != null &&\n        scope.partScopes != void 0 &&\n        scope.partScopes !== PLATFORM.emptyObject\n      ) {\n        $scope.partScopes = { ...scope.partScopes };\n      } else if (this.scopeParts !== PLATFORM.emptyArray) {\n        $scope.partScopes = {};\n      }\n\n      if ($scope.partScopes == void 0) {\n        $scope.partScopes = PLATFORM.emptyObject;\n      } else {\n        for (const partName of this.scopeParts) {\n          $scope.partScopes[partName] = $scope;\n        }\n      }\n    }\n\n    if ((flags & LifecycleFlags.updateOneTimeBindings) > 0) {\n      this.bindBindings(flags, $scope);\n      return LifecycleTask.done;\n    }\n\n    if ((this.state & State.isBound) > 0) {\n      return LifecycleTask.done;\n    }\n\n    flags |= LifecycleFlags.fromBind;\n\n    this.state |= State.isBinding;\n\n    this.lifecycle.bound.begin();\n    this.bindBindings(flags, $scope);\n\n    if (this.hooks.hasBinding) {\n      const ret = (this.bindingContext as BindingContext<T, C>).binding(flags);\n      if (hasAsyncWork(ret)) {\n        return new ContinuationTask(ret, this.bindControllers, this, flags, $scope);\n      }\n    }\n\n    return this.bindControllers(flags, $scope);\n  }\n\n  private bindCustomAttribute(flags: LifecycleFlags, scope?: IScope): ILifecycleTask {\n    if ((this.state & State.isBound) > 0) {\n      if (this.scope === scope) {\n        return LifecycleTask.done;\n      }\n\n      flags |= LifecycleFlags.fromBind;\n      const task = this.unbind(flags);\n\n      if (!task.done) {\n        return new ContinuationTask(task, this.bind, this, flags, scope);\n      }\n    } else {\n      flags |= LifecycleFlags.fromBind;\n    }\n\n    this.state |= State.isBinding;\n\n    this.scope = scope;\n    this.lifecycle.bound.begin();\n\n    if (this.hooks.hasBinding) {\n      const ret = (this.bindingContext as BindingContext<T, C>).binding(flags);\n      if (hasAsyncWork(ret)) {\n        return new ContinuationTask(ret, this.endBind, this, flags);\n      }\n    }\n\n    this.endBind(flags);\n    return LifecycleTask.done;\n  }\n\n  private bindSynthetic(flags: LifecycleFlags, scope?: IScope): ILifecycleTask {\n    if (scope == void 0) {\n      throw new Error(`Scope is null or undefined`); // TODO: create error code\n    }\n\n    if ((flags & LifecycleFlags.updateOneTimeBindings) > 0) {\n      this.bindBindings(flags, scope);\n      return LifecycleTask.done;\n    }\n\n    if ((this.state & State.isBound) > 0) {\n      if (this.scope === scope || (this.state & State.hasLockedScope) > 0) {\n        return LifecycleTask.done;\n      }\n\n      flags |= LifecycleFlags.fromBind;\n      const task = this.unbind(flags);\n\n      if (!task.done) {\n        return new ContinuationTask(task, this.bind, this, flags, scope);\n      }\n    } else {\n      flags |= LifecycleFlags.fromBind;\n    }\n\n    if ((this.state & State.hasLockedScope) === 0) {\n      this.scope = scope;\n    }\n\n    this.state |= State.isBinding;\n\n    this.lifecycle.bound.begin();\n    this.bindBindings(flags, scope);\n\n    return this.bindControllers(flags, scope);\n  }\n\n  private bindBindings(flags: LifecycleFlags, scope: IScope): void {\n    const { bindings } = this;\n    if (bindings !== void 0) {\n      const { length } = bindings;\n      for (let i = 0; i < length; ++i) {\n        bindings[i].$bind(flags, scope);\n      }\n    }\n  }\n\n  private bindControllers(flags: LifecycleFlags, scope: IScope): ILifecycleTask {\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask | undefined;\n\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      const { length } = controllers;\n      for (let i = 0; i < length; ++i) {\n        task = controllers[i].bind(flags, scope);\n        if (!task.done) {\n          if (tasks === void 0) {\n            tasks = [];\n          }\n          tasks.push(task);\n        }\n      }\n    }\n\n    if (tasks === void 0) {\n      this.endBind(flags);\n      return LifecycleTask.done;\n    }\n    return new AggregateContinuationTask(tasks, this.endBind, this, flags);\n  }\n\n  private endBind(flags: LifecycleFlags): void {\n    if (this.hooks.hasBound) {\n      this.lifecycle.bound.add(this);\n    }\n    this.state = this.state ^ State.isBinding | State.isBound;\n    this.lifecycle.bound.end(flags);\n  }\n\n  private unbindCustomElement(flags: LifecycleFlags): ILifecycleTask {\n    if ((this.state & State.isBound) === 0) {\n      return LifecycleTask.done;\n    }\n\n    this.state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n    this.lifecycle.unbound.begin();\n\n    if (this.hooks.hasUnbinding) {\n      const ret = (this.bindingContext as BindingContext<T, C>).unbinding(flags);\n      if (hasAsyncWork(ret)) {\n        return new ContinuationTask(ret, this.unbindControllers, this, flags);\n      }\n    }\n\n    return this.unbindControllers(flags);\n  }\n\n  private unbindCustomAttribute(flags: LifecycleFlags): ILifecycleTask {\n    if ((this.state & State.isBound) === 0) {\n      return LifecycleTask.done;\n    }\n\n    this.state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n    this.lifecycle.unbound.begin();\n\n    if (this.hooks.hasUnbinding) {\n      const ret = (this.bindingContext as BindingContext<T, C>).unbinding(flags);\n      if (hasAsyncWork(ret)) {\n        return new ContinuationTask(ret, this.endUnbind, this, flags);\n      }\n    }\n\n    this.endUnbind(flags);\n    return LifecycleTask.done;\n  }\n\n  private unbindSynthetic(flags: LifecycleFlags): ILifecycleTask {\n    if ((this.state & State.isBound) === 0) {\n      return LifecycleTask.done;\n    }\n\n    this.state |= State.isUnbinding;\n\n    flags |= LifecycleFlags.fromUnbind;\n    this.lifecycle.unbound.begin();\n\n    return this.unbindControllers(flags);\n  }\n\n  private unbindBindings(flags: LifecycleFlags): void {\n    const { bindings } = this;\n    if (bindings !== void 0) {\n      for (let i = bindings.length - 1; i >= 0; --i) {\n        bindings[i].$unbind(flags);\n      }\n    }\n    this.endUnbind(flags);\n  }\n\n  private unbindControllers(flags: LifecycleFlags): ILifecycleTask {\n    let tasks: ILifecycleTask[] | undefined = void 0;\n    let task: ILifecycleTask | undefined;\n\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      for (let i = controllers.length - 1; i >= 0; --i) {\n        task = controllers[i].unbind(flags);\n        if (!task.done) {\n          if (tasks === void 0) {\n            tasks = [];\n          }\n          tasks.push(task);\n        }\n      }\n    }\n\n    if (tasks === void 0) {\n      this.unbindBindings(flags);\n      return LifecycleTask.done;\n    }\n    return new AggregateContinuationTask(tasks, this.unbindBindings, this, flags);\n  }\n\n  private endUnbind(flags: LifecycleFlags): void {\n    switch (this.vmKind) {\n      case ViewModelKind.customAttribute:\n        this.scope = void 0;\n        break;\n      case ViewModelKind.synthetic:\n        if ((this.state & State.hasLockedScope) === 0) {\n          this.scope = void 0;\n        }\n    }\n    if (this.hooks.hasUnbound) {\n      this.lifecycle.unbound.add(this);\n    }\n\n    this.state = (this.state | State.isBoundOrUnbinding) ^ State.isBoundOrUnbinding;\n    this.lifecycle.unbound.end(flags);\n  }\n  // #endregion\n\n  // #region attach/detach\n  private attachCustomElement(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromAttach;\n    this.state |= State.isAttaching;\n\n    this.lifecycle.mount.add(this);\n    this.lifecycle.attached.begin();\n\n    if (this.hooks.hasAttaching) {\n      (this.bindingContext as BindingContext<T, C>).attaching(flags);\n    }\n\n    this.attachControllers(flags);\n\n    if (this.hooks.hasAttached) {\n      this.lifecycle.attached.add(this);\n    }\n\n    this.state = this.state ^ State.isAttaching | State.isAttached;\n    this.lifecycle.attached.end(flags);\n  }\n\n  private attachCustomAttribute(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromAttach;\n    this.state |= State.isAttaching;\n\n    this.lifecycle.attached.begin();\n\n    if (this.hooks.hasAttaching) {\n      (this.bindingContext as BindingContext<T, C>).attaching(flags);\n    }\n\n    if (this.hooks.hasAttached) {\n      this.lifecycle.attached.add(this);\n    }\n\n    this.state = this.state ^ State.isAttaching | State.isAttached;\n    this.lifecycle.attached.end(flags);\n  }\n\n  private attachSynthetic(flags: LifecycleFlags): void {\n    if (((this.state & State.isAttached) > 0 && flags & LifecycleFlags.reorderNodes) > 0) {\n      this.lifecycle.mount.add(this);\n    } else {\n      flags |= LifecycleFlags.fromAttach;\n      this.state |= State.isAttaching;\n\n      this.lifecycle.mount.add(this);\n      this.lifecycle.attached.begin();\n\n      this.attachControllers(flags);\n\n      this.state = this.state ^ State.isAttaching | State.isAttached;\n      this.lifecycle.attached.end(flags);\n    }\n  }\n\n  private detachCustomElement(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromDetach;\n    this.state |= State.isDetaching;\n\n    this.lifecycle.detached.begin();\n    this.lifecycle.unmount.add(this);\n\n    if (this.hooks.hasDetaching) {\n      (this.bindingContext as BindingContext<T, C>).detaching(flags);\n    }\n\n    this.detachControllers(flags);\n\n    if (this.hooks.hasDetached) {\n      this.lifecycle.detached.add(this);\n    }\n\n    this.state = (this.state | State.isAttachedOrDetaching) ^ State.isAttachedOrDetaching;\n    this.lifecycle.detached.end(flags);\n  }\n\n  private detachCustomAttribute(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromDetach;\n    this.state |= State.isDetaching;\n\n    this.lifecycle.detached.begin();\n\n    if (this.hooks.hasDetaching) {\n      (this.bindingContext as BindingContext<T, C>).detaching(flags);\n    }\n\n    if (this.hooks.hasDetached) {\n      this.lifecycle.detached.add(this);\n    }\n\n    this.state = (this.state | State.isAttachedOrDetaching) ^ State.isAttachedOrDetaching;\n    this.lifecycle.detached.end(flags);\n  }\n\n  private detachSynthetic(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromDetach;\n    this.state |= State.isDetaching;\n\n    this.lifecycle.detached.begin();\n    this.lifecycle.unmount.add(this);\n\n    this.detachControllers(flags);\n\n    this.state = (this.state | State.isAttachedOrDetaching) ^ State.isAttachedOrDetaching;\n    this.lifecycle.detached.end(flags);\n  }\n\n  private attachControllers(flags: LifecycleFlags): void {\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      const { length } = controllers;\n      for (let i = 0; i < length; ++i) {\n        controllers[i].attach(flags);\n      }\n    }\n  }\n\n  private detachControllers(flags: LifecycleFlags): void {\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      for (let i = controllers.length - 1; i >= 0; --i) {\n        controllers[i].detach(flags);\n      }\n    }\n  }\n  // #endregion\n\n  // #region mount/unmount/cache\n  private mountCustomElement(flags: LifecycleFlags): void {\n    if ((this.state & State.isMounted) > 0) {\n      return;\n    }\n\n    this.state |= State.isMounted;\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.projector!.project(this.nodes!);\n  }\n\n  private mountSynthetic(flags: LifecycleFlags): void {\n    this.state |= State.isMounted;\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.nodes!.insertBefore(this.location!);\n  }\n\n  private unmountCustomElement(flags: LifecycleFlags): void {\n    if ((this.state & State.isMounted) === 0) {\n      return;\n    }\n\n    this.state = (this.state | State.isMounted) ^ State.isMounted;\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.projector!.take(this.nodes!);\n  }\n\n  private unmountSynthetic(flags: LifecycleFlags): boolean {\n    if ((this.state & State.isMounted) === 0) {\n      return false;\n    }\n\n    this.state = (this.state | State.isMounted) ^ State.isMounted;\n    // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n    this.nodes!.remove();\n    this.nodes!.unlink();\n\n    if ((this.state & State.canBeCached) > 0) {\n      this.state = (this.state | State.canBeCached) ^ State.canBeCached;\n      // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n      if (this.viewCache!.tryReturnToCache(this)) {\n        this.state |= State.isCached;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private cacheCustomElement(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromCache;\n    if (this.hooks.hasCaching) {\n      // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n      this.bindingContext!.caching(flags);\n    }\n  }\n\n  private cacheCustomAttribute(flags: LifecycleFlags): void {\n    flags |= LifecycleFlags.fromCache;\n    if (this.hooks.hasCaching) {\n      // tslint:disable-next-line: no-non-null-assertion // non-null is implied by the hook\n      this.bindingContext!.caching(flags);\n    }\n\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      const { length } = controllers;\n      for (let i = length - 1; i >= 0; --i) {\n        controllers[i].cache(flags);\n      }\n    }\n  }\n\n  private cacheSynthetic(flags: LifecycleFlags): void {\n    const { controllers } = this;\n    if (controllers !== void 0) {\n      const { length } = controllers;\n      for (let i = length - 1; i >= 0; --i) {\n        controllers[i].cache(flags);\n      }\n    }\n  }\n  // #endregion\n}\n\nfunction createObservers(\n  lifecycle: ILifecycle,\n  description: Description,\n  flags: LifecycleFlags,\n  instance: IIndexable,\n): void {\n  const hasLookup = instance.$observers != void 0;\n  const observers: Record<string, SelfObserver> = hasLookup ? instance.$observers as Record<string, SelfObserver> : {};\n  const bindables = description.bindables as Record<string, Required<IBindableDescription>>;\n  const observableNames = Object.getOwnPropertyNames(bindables);\n  const useProxy = (flags & LifecycleFlags.proxyStrategy) > 0 ;\n\n  const { length } = observableNames;\n  let name: string;\n  for (let i = 0; i < length; ++i) {\n    name = observableNames[i];\n\n    if (observers[name] == void 0) {\n      observers[name] = new SelfObserver(\n        lifecycle,\n        flags,\n        useProxy ? ProxyObserver.getOrCreate(instance).proxy : instance,\n        name,\n        bindables[name].callback\n      );\n    }\n  }\n\n  if (!useProxy) {\n    Reflect.defineProperty(instance, '$observers', {\n      enumerable: false,\n      value: observers\n    });\n  }\n}\n\nfunction getBindingContext<T extends INode, C extends IViewModel<T>>(flags: LifecycleFlags, instance: IIndexable): BindingContext<T, C> {\n  if (instance.noProxy === true || (flags & LifecycleFlags.proxyStrategy) === 0) {\n    return instance as BindingContext<T, C>;\n  }\n\n  return ProxyObserver.getOrCreate(instance).proxy as BindingContext<T, C>;\n}\n","import {\n  DI,\n  IContainer,\n  IResolver,\n  IServiceLocator,\n  Registration,\n} from '@aurelia/kernel';\n\nimport { INode } from './dom';\nimport { LifecycleFlags } from './flags';\nimport { IViewModel } from './lifecycle';\nimport {\n  ContinuationTask,\n  ILifecycleTask,\n} from './lifecycle-task';\nimport { IScope } from './observation';\nimport { ExposedContext } from './rendering-engine';\nimport { Controller } from './templating/controller';\n\nexport interface IActivator {\n  activate(host: INode, component: IViewModel, locator: IServiceLocator, flags?: LifecycleFlags, parentScope?: IScope): ILifecycleTask;\n  deactivate(component: IViewModel, flags?: LifecycleFlags): ILifecycleTask;\n}\n\nexport const IActivator = DI.createInterface<IActivator>('IActivator').withDefault(x => x.singleton(Activator));\n\n/** @internal */\nexport class Activator implements IActivator {\n  public static register(container: IContainer): IResolver<IActivator> {\n    return Registration.singleton(IActivator, this).register(container);\n  }\n\n  public activate(\n    host: INode,\n    component: IViewModel,\n    locator: IServiceLocator,\n    flags: LifecycleFlags = LifecycleFlags.fromStartTask,\n    parentScope?: IScope\n  ): ILifecycleTask {\n    flags = flags === void 0 ? LifecycleFlags.none : flags;\n    const controller = Controller.forCustomElement(\n      component,\n      locator as ExposedContext,\n      host,\n      flags,\n    );\n    let task = controller.bind(flags | LifecycleFlags.fromBind, parentScope);\n    if (task.done) {\n      controller.attach(flags | LifecycleFlags.fromAttach);\n    } else {\n      task = new ContinuationTask(task, controller.attach, controller, flags | LifecycleFlags.fromAttach);\n    }\n    return task;\n  }\n\n  public deactivate(component: IViewModel, flags: LifecycleFlags = LifecycleFlags.fromStopTask): ILifecycleTask {\n    const controller = Controller.forCustomElement(component, (void 0)!, (void 0)!);\n    controller.detach(flags | LifecycleFlags.fromDetach);\n    return controller.unbind(flags | LifecycleFlags.fromUnbind);\n  }\n}\n","import {\n  DI,\n  IContainer,\n  IRegistry,\n  PLATFORM,\n  Profiler,\n  Registration\n} from '@aurelia/kernel';\n\nimport { IActivator } from './activator';\nimport {\n  IDOM,\n  INode\n} from './dom';\nimport {\n  BindingStrategy,\n  LifecycleFlags\n} from './flags';\nimport {\n  IController,\n  IHydratedViewModel,\n  ILifecycle,\n} from './lifecycle';\nimport {\n  ContinuationTask,\n  ILifecycleTask,\n  LifecycleTask,\n} from './lifecycle-task';\nimport { ExposedContext } from './rendering-engine';\nimport {\n  CustomElementResource,\n  ICustomElementType\n} from './resources/custom-element';\nimport { Controller } from './templating/controller';\n\nconst { enter: enterStart, leave: leaveStart } = Profiler.createTimer('Aurelia.start');\nconst { enter: enterStop, leave: leaveStop } = Profiler.createTimer('Aurelia.stop');\n\nexport interface ISinglePageApp<THost extends INode = INode> {\n  enableTimeSlicing?: boolean;\n  adaptiveTimeSlicing?: boolean;\n  strategy?: BindingStrategy;\n  dom?: IDOM;\n  host: THost;\n  component: unknown;\n}\n\ntype Publisher = { dispatchEvent(evt: unknown, options?: unknown): void };\n\nexport class CompositionRoot<T extends INode = INode> {\n  public readonly config: ISinglePageApp<T>;\n  public readonly container: IContainer;\n  public readonly controller: IController;\n  public readonly host: T & { $au?: Aurelia<T> };\n  public readonly dom: IDOM<T>;\n  public readonly viewModel: IHydratedViewModel<T>;\n  public readonly strategy: BindingStrategy;\n  public readonly lifecycle: ILifecycle;\n  public readonly activator: IActivator;\n  public task: ILifecycleTask;\n  public hasPendingStartFrame: boolean;\n  public hasPendingStopFrame: boolean;\n\n  constructor(\n    config: ISinglePageApp<T>,\n    container: IContainer,\n  ) {\n    this.config = config;\n    if (config.host != void 0) {\n      if (container.has(INode, false)) {\n        this.container = container.createChild();\n      } else {\n        this.container = container;\n      }\n      Registration.instance(INode, config.host).register(this.container);\n      this.host = config.host;\n    } else if (container.has(INode, true)) {\n      this.container = container;\n      this.host = container.get(INode) as T;\n    } else {\n      throw new Error(`No host element found.`);\n    }\n    this.strategy = config.strategy != void 0 ? config.strategy : BindingStrategy.getterSetter;\n\n    const initializer = this.container.get(IDOMInitializer);\n    this.dom = initializer.initialize(config) as IDOM<T>;\n\n    this.viewModel = CustomElementResource.isType(config.component as ICustomElementType)\n      ? this.container.get(config.component) as IHydratedViewModel<T>\n      : config.component as IHydratedViewModel<T>;\n\n    this.controller = Controller.forCustomElement(\n      this.viewModel,\n      this.container as ExposedContext,\n      this.host,\n      this.strategy as number,\n    );\n    this.lifecycle = this.container.get(ILifecycle);\n    this.activator = this.container.get(IActivator);\n    if (config.enableTimeSlicing === true) {\n      this.lifecycle.enableTimeslicing(config.adaptiveTimeSlicing);\n    } else {\n      this.lifecycle.disableTimeslicing();\n    }\n    this.task = LifecycleTask.done;\n    this.hasPendingStartFrame = true;\n    this.hasPendingStopFrame = true;\n  }\n\n  public activate(antecedent?: ILifecycleTask): ILifecycleTask {\n    const { task, host, viewModel, container, activator, strategy } = this;\n    const flags = strategy | LifecycleFlags.fromStartTask;\n\n    if (task.done) {\n      if (antecedent == void 0 || antecedent.done) {\n        this.task = activator.activate(host, viewModel, container, flags, void 0);\n      } else {\n        this.task = new ContinuationTask(antecedent, activator.activate, activator, host, viewModel, container, flags, void 0);\n      }\n    } else {\n      if (antecedent == void 0 || antecedent.done) {\n        this.task = new ContinuationTask(task, activator.activate, activator, host, viewModel, container, flags, void 0);\n      } else {\n        const combinedAntecedent = new ContinuationTask(task, antecedent.wait, antecedent);\n        this.task = new ContinuationTask(combinedAntecedent, activator.activate, activator, host, viewModel, container, flags, void 0);\n      }\n    }\n\n    return this.task;\n  }\n\n  public deactivate(antecedent?: ILifecycleTask): ILifecycleTask {\n    const { task, viewModel, activator, strategy } = this;\n    const flags = strategy | LifecycleFlags.fromStopTask;\n\n    if (task.done) {\n      if (antecedent == void 0 || antecedent.done) {\n        this.task = activator.deactivate(viewModel, flags);\n      } else {\n        this.task = new ContinuationTask(antecedent, activator.deactivate, activator, viewModel, flags);\n      }\n    } else {\n      if (antecedent == void 0 || antecedent.done) {\n        this.task = new ContinuationTask(task, activator.deactivate, activator, viewModel, flags);\n      } else {\n        const combinedAntecedent = new ContinuationTask(task, antecedent.wait, antecedent);\n        this.task = new ContinuationTask(combinedAntecedent, activator.deactivate, activator, viewModel, flags);\n      }\n    }\n\n    return this.task;\n  }\n}\n\nexport class Aurelia<TNode extends INode = INode> {\n  public readonly container: IContainer;\n  public get isRunning(): boolean {\n    return this._isRunning;\n  }\n  public get isStarting(): boolean {\n    return this._isStarting;\n  }\n  public get isStopping(): boolean {\n    return this._isStopping;\n  }\n  public get root(): CompositionRoot<TNode> {\n    if (this._root == void 0) {\n      if (this.next == void 0) {\n        throw new Error(`root is not defined`); // TODO: create error code\n      }\n      return this.next;\n    }\n    return this._root;\n  }\n  private task: ILifecycleTask;\n  private _isRunning: boolean;\n  private _isStarting: boolean;\n  private _isStopping: boolean;\n  private _root?: CompositionRoot<TNode>;\n\n  private next?: CompositionRoot<TNode>;\n\n  constructor(container: IContainer = DI.createContainer()) {\n    this.container = container;\n    this.task = LifecycleTask.done;\n\n    this._isRunning = false;\n    this._isStarting = false;\n    this._isStopping = false;\n\n    this._root = void 0;\n\n    this.next = (void 0)!;\n\n    Registration.instance(Aurelia, this).register(container);\n  }\n\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageApp<TNode>): this {\n    this.next = new CompositionRoot(config, this.container);\n\n    if (this.isRunning) {\n      this.start();\n    }\n\n    return this;\n  }\n\n  public start(root: CompositionRoot<TNode> | undefined = this.next): ILifecycleTask {\n    if (root == void 0) {\n      throw new Error(`There is no composition root`); // TODO: create error code\n    }\n\n    this.stop(root);\n\n    if (this.task.done) {\n      this.onBeforeStart(root);\n    } else {\n      this.task = new ContinuationTask(this.task, this.onBeforeStart, this, root);\n    }\n\n    this.task = this.root.activate(this.task);\n\n    if (this.task.done) {\n      this.task = this.onAfterStart(root);\n    } else {\n      this.task = new ContinuationTask(this.task, this.onAfterStart, this, root);\n    }\n\n    return this.task;\n  }\n\n  public stop(root: CompositionRoot<TNode> | undefined = this._root): ILifecycleTask {\n    if (this._isRunning && root != void 0) {\n      if (this.task.done) {\n        this.onBeforeStop(root);\n      } else {\n        this.task = new ContinuationTask(this.task, this.onBeforeStop, this, root);\n      }\n\n      this.task = root.deactivate(this.task);\n\n      if (this.task.done) {\n        this.task = this.onAfterStop(root);\n      } else {\n        this.task = new ContinuationTask(this.task, this.onAfterStop, this, root);\n      }\n    }\n\n    return this.task;\n  }\n\n  public wait(): Promise<void> {\n    return this.task.wait() as Promise<void>;\n  }\n\n  private onBeforeStart(root: CompositionRoot<TNode>): void {\n    Reflect.set(root.host, '$au', this);\n    this._root = root;\n    this._isStarting = true;\n    if (Profiler.enabled) { enterStart(); }\n  }\n\n  private onAfterStart(root: CompositionRoot): ILifecycleTask {\n    this._isRunning = true;\n    this._isStarting = false;\n    this.dispatchEvent(root, 'aurelia-composed', root.dom);\n    this.dispatchEvent(root, 'au-started', root.host as Publisher);\n    if (Profiler.enabled) { leaveStart(); }\n    return LifecycleTask.done;\n  }\n\n  private onBeforeStop(root: CompositionRoot): void {\n    this._isRunning = false;\n    this._isStopping = true;\n    if (Profiler.enabled) { enterStop(); }\n  }\n\n  private onAfterStop(root: CompositionRoot): ILifecycleTask {\n    Reflect.deleteProperty(root.host, '$au');\n    this._root = void 0;\n    this._isStopping = false;\n    this.dispatchEvent(root, 'au-stopped', root.host as Publisher);\n    if (Profiler.enabled) { leaveStop(); }\n    return LifecycleTask.done;\n  }\n\n  private dispatchEvent(root: CompositionRoot, name: string, target: Publisher): void {\n    target = 'dispatchEvent' in target ? target : root.dom;\n    target.dispatchEvent(root.dom.createCustomEvent(name, { detail: this, bubbles: true, cancelable: true }));\n  }\n}\n(PLATFORM.global as typeof PLATFORM.global & {Aurelia: unknown}).Aurelia = Aurelia;\n\nexport const IDOMInitializer = DI.createInterface<IDOMInitializer>('IDOMInitializer').noDefault();\n\nexport interface IDOMInitializer {\n  initialize(config?: ISinglePageApp): IDOM;\n}\n","import {\n  all,\n  Class,\n  IContainer,\n  InjectArray,\n  IRegistry,\n  IResolver,\n  Registration,\n  Reporter,\n  Tracer,\n  Writable,\n  PLATFORM\n} from '@aurelia/kernel';\nimport { AnyBindingExpression } from './ast';\nimport { Binding } from './binding/binding';\nimport { Call } from './binding/call';\nimport { BindingType, IExpressionParser } from './binding/expression-parser';\nimport { InterpolationBinding, MultiInterpolationBinding } from './binding/interpolation-binding';\nimport { LetBinding } from './binding/let-binding';\nimport { Ref } from './binding/ref';\nimport {\n  customAttributeKey,\n  customElementKey,\n  ICallBindingInstruction,\n  IElementHydrationOptions,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  ILetBindingInstruction,\n  InstructionTypeName,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetPropertyInstruction,\n  ITargetedInstruction,\n  TargetedInstructionType,\n  TemplateDefinition,\n  TemplatePartDefinitions\n} from './definitions';\nimport { IDOM, INode, DOM } from './dom';\nimport { BindingMode, LifecycleFlags } from './flags';\nimport {\n  IBinding,\n  IController,\n  IRenderContext,\n} from './lifecycle';\nimport {\n  Controller,\n} from './templating/controller';\nimport { IObserverLocator } from './observation/observer-locator';\nimport {\n  IInstructionRenderer,\n  IInstructionTypeClassifier,\n  IRenderer,\n  IRenderingEngine\n} from './rendering-engine';\n\nconst slice = Array.prototype.slice;\n\ntype DecoratableInstructionRenderer<TType extends string, TProto, TClass> = Class<TProto & Partial<IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>>, TClass> & Partial<IRegistry>;\ntype DecoratedInstructionRenderer<TType extends string, TProto, TClass> =  Class<TProto & IInstructionTypeClassifier<TType> & Pick<IInstructionRenderer, 'render'>, TClass> & IRegistry;\n\ntype InstructionRendererDecorator<TType extends string> = <TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>) => DecoratedInstructionRenderer<TType, TProto, TClass>;\n\nexport function instructionRenderer<TType extends string>(instructionType: TType): InstructionRendererDecorator<TType> {\n  return function decorator<TProto, TClass>(target: DecoratableInstructionRenderer<TType, TProto, TClass>): DecoratedInstructionRenderer<TType, TProto, TClass> {\n    // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)\n    const decoratedTarget = function(...args: unknown[]): TProto {\n      // TODO: fix this\n      // @ts-ignore\n      const instance = new target(...args);\n      instance.instructionType = instructionType;\n      return instance;\n    } as unknown as DecoratedInstructionRenderer<TType, TProto, TClass>;\n    // make sure we register the decorated constructor with DI\n    decoratedTarget.register = function register(container: IContainer): IResolver {\n      return Registration.singleton(IInstructionRenderer, decoratedTarget).register(container, IInstructionRenderer);\n    };\n    // copy over any static properties such as inject (set by preceding decorators)\n    // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)\n    // the length (number of ctor arguments) is copied for the same reason\n    const ownProperties = Object.getOwnPropertyDescriptors(target);\n    Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {\n      Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);\n    });\n    return decoratedTarget;\n  };\n}\n\n/* @internal */\nexport class Renderer implements IRenderer {\n  // TODO: fix this\n  // @ts-ignore\n  public static readonly inject: InjectArray = [all(IInstructionRenderer)];\n\n  public instructionRenderers: Record<InstructionTypeName, IInstructionRenderer>;\n\n  constructor(instructionRenderers: IInstructionRenderer[]) {\n    const record: Record<InstructionTypeName, IInstructionRenderer> = this.instructionRenderers = {};\n    instructionRenderers.forEach(item => {\n      record[item.instructionType!] = item;\n    });\n  }\n\n  public static register(container: IContainer): IResolver<IRenderer> {\n    return Registration.singleton(IRenderer, this).register(container);\n  }\n\n  // tslint:disable-next-line:parameters-max-number\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, targets: ArrayLike<INode>, definition: TemplateDefinition, host?: INode, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('Renderer', 'render', slice.call(arguments)); }\n    const targetInstructions = definition.instructions;\n    const instructionRenderers = this.instructionRenderers;\n\n    if (targets.length !== targetInstructions.length) {\n      if (targets.length > targetInstructions.length) {\n        throw Reporter.error(30);\n      } else {\n        throw Reporter.error(31);\n      }\n    }\n    let instructions: ITargetedInstruction[];\n    let target: INode;\n    let current: ITargetedInstruction;\n    for (let i = 0, ii = targets.length; i < ii; ++i) {\n      instructions = targetInstructions[i];\n      target = targets[i];\n\n      for (let j = 0, jj = instructions.length; j < jj; ++j) {\n        current = instructions[j];\n        instructionRenderers[current.type].render(flags, dom, context, renderable, target, current, parts);\n      }\n    }\n\n    if (host) {\n      const surrogateInstructions = definition.surrogates;\n\n      for (let i = 0, ii = surrogateInstructions.length; i < ii; ++i) {\n        current = surrogateInstructions[i];\n        instructionRenderers[current.type].render(flags, dom, context, renderable, host, current, parts);\n      }\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\nexport function ensureExpression<TFrom>(parser: IExpressionParser, srcOrExpr: TFrom, bindingType: BindingType): Exclude<TFrom, string> {\n  if (typeof srcOrExpr === 'string') {\n    return parser.parse(srcOrExpr, bindingType) as unknown as Exclude<TFrom, string>;\n  }\n  return srcOrExpr as Exclude<TFrom, string>;\n}\n\nexport function addBinding(renderable: IController, binding: IBinding): void {\n  if (Tracer.enabled) { Tracer.enter('Renderer', 'addBinding', slice.call(arguments)); }\n  if (renderable.bindings == void 0) {\n    renderable.bindings = [binding];\n  } else {\n    renderable.bindings.push(binding);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nexport function addComponent(renderable: IController, component: IController): void {\n  if (Tracer.enabled) { Tracer.enter('Renderer', 'addComponent', slice.call(arguments)); }\n  if (renderable.controllers == void 0) {\n    renderable.controllers = [component];\n  } else {\n    renderable.controllers.push(component);\n  }\n  if (Tracer.enabled) { Tracer.leave(); }\n}\n\nexport function getTarget(potentialTarget: object): object {\n  if ((potentialTarget as { bindingContext?: object }).bindingContext !== void 0) {\n    return (potentialTarget as { bindingContext: object }).bindingContext;\n  }\n  return potentialTarget;\n}\n\n@instructionRenderer(TargetedInstructionType.setProperty)\n/** @internal */\nexport class SetPropertyRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: ISetPropertyInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('SetPropertyRenderer', 'render', slice.call(arguments)); }\n    getTarget(target)[instruction.to as keyof object] = instruction.value as never; // Yeah, yeah..\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateElement)\n/** @internal */\nexport class CustomElementRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: INode, instruction: IHydrateElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomElementRenderer', 'render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction, null!, null!, target, true);\n    const component = context.get<object>(customElementKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    const controller = Controller.forCustomElement(\n      component,\n      context,\n      target,\n      flags,\n      instruction as IElementHydrationOptions,\n    );\n\n    let current: ITargetedInstruction;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, controller, current);\n    }\n\n    addComponent(renderable, controller);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateAttribute)\n/** @internal */\nexport class CustomAttributeRenderer implements IInstructionRenderer {\n  public static readonly register: IRegistry['register'];\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: INode, instruction: IHydrateAttributeInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CustomAttributeRenderer', 'render', slice.call(arguments)); }\n    const operation = context.beginComponentOperation(renderable, target, instruction);\n    const component = context.get<object>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    const controller = Controller.forCustomAttribute(\n      component,\n      context,\n      flags,\n    );\n\n    let current: ITargetedInstruction;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, controller, current);\n    }\n\n    addComponent(renderable, controller);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateTemplateController)\n/** @internal */\nexport class TemplateControllerRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IRenderingEngine];\n  public static readonly register: IRegistry['register'];\n\n  private readonly renderingEngine: IRenderingEngine;\n\n  constructor(renderingEngine: IRenderingEngine) {\n    this.renderingEngine = renderingEngine;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: INode, instruction: IHydrateTemplateController, parts?: TemplatePartDefinitions): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateControllerRenderer', 'render', slice.call(arguments)); }\n    const factory = this.renderingEngine.getViewFactory(dom, instruction.def, context);\n    const operation = context.beginComponentOperation(renderable, target, instruction, factory, parts, dom.convertToRenderLocation(target), false);\n    const component = context.get<object>(customAttributeKey(instruction.res));\n    const instructionRenderers = context.get(IRenderer).instructionRenderers;\n    const childInstructions = instruction.instructions;\n\n    const controller = Controller.forCustomAttribute(\n      component,\n      context,\n      flags,\n      instruction.parts == void 0\n        ? PLATFORM.emptyArray\n        : Object.keys(instruction.parts),\n    );\n\n    if (instruction.link) {\n      const controllers = renderable.controllers!;\n      (component as { link(componentTail: IController): void}).link(controllers[controllers.length - 1]);\n    }\n\n    let current: ITargetedInstruction;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      current = childInstructions[i];\n      instructionRenderers[current.type].render(flags, dom, context, renderable, controller, current);\n    }\n\n    addComponent(renderable, controller);\n\n    operation.dispose();\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.hydrateLetElement)\n/** @internal */\nexport class LetElementRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: INode, instruction: IHydrateLetElementInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('LetElementRenderer', 'render', slice.call(arguments)); }\n    dom.remove(target);\n    const childInstructions = instruction.instructions;\n    const toViewModel = instruction.toViewModel;\n\n    let childInstruction: ILetBindingInstruction;\n    let expr: AnyBindingExpression;\n    let binding: LetBinding;\n    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n      childInstruction = childInstructions[i];\n      expr = ensureExpression(this.parser, childInstruction.from, BindingType.IsPropertyCommand);\n      binding = new LetBinding(expr, childInstruction.to, this.observerLocator, context, toViewModel);\n      addBinding(renderable, binding);\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.callBinding)\n/** @internal */\nexport class CallBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: ICallBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('CallBindingRenderer', 'render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.CallCommand);\n    const binding = new Call(expr, getTarget(target), instruction.to, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.refBinding)\n/** @internal */\nexport class RefBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n\n  constructor(parser: IExpressionParser) {\n    this.parser = parser;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: IRefBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('RefBindingRenderer', 'render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsRef);\n    const binding = new Ref(expr, getTarget(target), context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.interpolation)\n/** @internal */\nexport class InterpolationBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: IInterpolationInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('InterpolationBindingRenderer', 'render', slice.call(arguments)); }\n    let binding: MultiInterpolationBinding | InterpolationBinding;\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.Interpolation);\n    if (expr.isMulti) {\n      binding = new MultiInterpolationBinding(this.observerLocator, expr, getTarget(target), instruction.to, BindingMode.toView, context);\n    } else {\n      binding = new InterpolationBinding(expr.firstExpression, expr, getTarget(target), instruction.to, BindingMode.toView, this.observerLocator, context, true);\n    }\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.propertyBinding)\n/** @internal */\nexport class PropertyBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: IPropertyBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('PropertyBindingRenderer', 'render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.IsPropertyCommand | instruction.mode);\n    const binding = new Binding(expr, getTarget(target), instruction.to, instruction.mode, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n\n@instructionRenderer(TargetedInstructionType.iteratorBinding)\n/** @internal */\nexport class IteratorBindingRenderer implements IInstructionRenderer {\n  public static readonly inject: InjectArray = [IExpressionParser, IObserverLocator];\n  public static readonly register: IRegistry['register'];\n\n  private readonly parser: IExpressionParser;\n  private readonly observerLocator: IObserverLocator;\n\n  constructor(parser: IExpressionParser, observerLocator: IObserverLocator) {\n    this.parser = parser;\n    this.observerLocator = observerLocator;\n  }\n\n  public render(flags: LifecycleFlags, dom: IDOM, context: IRenderContext, renderable: IController, target: IController, instruction: IIteratorBindingInstruction): void {\n    if (Tracer.enabled) { Tracer.enter('IteratorBindingRenderer', 'render', slice.call(arguments)); }\n    const expr = ensureExpression(this.parser, instruction.from, BindingType.ForCommand);\n    const binding = new Binding(expr, getTarget(target), instruction.to, BindingMode.toView, this.observerLocator, context);\n    addBinding(renderable, binding);\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n}\n","import {\n  DI,\n  IContainer,\n  IRegistry\n} from '@aurelia/kernel';\n\nimport { Lifecycle } from './lifecycle';\nimport { ObserverLocator } from './observation/observer-locator';\nimport {\n  CallBindingRenderer,\n  CustomAttributeRenderer,\n  CustomElementRenderer,\n  InterpolationBindingRenderer,\n  IteratorBindingRenderer,\n  LetElementRenderer,\n  PropertyBindingRenderer,\n  RefBindingRenderer,\n  Renderer,\n  SetPropertyRenderer,\n  TemplateControllerRenderer\n} from './renderer';\nimport {\n  FromViewBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  TwoWayBindingBehavior\n} from './resources/binding-behaviors/binding-mode';\nimport { DebounceBindingBehavior } from './resources/binding-behaviors/debounce';\nimport { SignalBindingBehavior } from './resources/binding-behaviors/signals';\nimport { ThrottleBindingBehavior } from './resources/binding-behaviors/throttle';\nimport {\n  Else,\n  If\n} from './resources/custom-attributes/if';\nimport { Repeat } from './resources/custom-attributes/repeat';\nimport { Replaceable } from './resources/custom-attributes/replaceable';\nimport { With } from './resources/custom-attributes/with';\nimport { SanitizeValueConverter } from './resources/value-converters/sanitize';\nimport { PriorityBindingBehavior } from './resources/binding-behaviors/priority';\n\nexport const IObserverLocatorRegistration = ObserverLocator as IRegistry;\nexport const ILifecycleRegistration = Lifecycle as IRegistry;\nexport const IRendererRegistration = Renderer as IRegistry;\n\n/**\n * Default implementations for the following interfaces:\n * - `IObserverLocator`\n * - `ILifecycle`\n * - `IRenderer`\n */\nexport const DefaultComponents = [\n  IObserverLocatorRegistration,\n  ILifecycleRegistration,\n  IRendererRegistration\n];\n\nexport const IfRegistration = If as IRegistry;\nexport const ElseRegistration = Else as IRegistry;\nexport const RepeatRegistration = Repeat as IRegistry;\nexport const ReplaceableRegistration = Replaceable as IRegistry;\nexport const WithRegistration = With as IRegistry;\nexport const SanitizeValueConverterRegistration = SanitizeValueConverter as IRegistry;\nexport const DebounceBindingBehaviorRegistration = DebounceBindingBehavior as IRegistry;\nexport const OneTimeBindingBehaviorRegistration = OneTimeBindingBehavior as IRegistry;\nexport const ToViewBindingBehaviorRegistration = ToViewBindingBehavior as IRegistry;\nexport const FromViewBindingBehaviorRegistration = FromViewBindingBehavior as IRegistry;\nexport const SignalBindingBehaviorRegistration = SignalBindingBehavior as IRegistry;\nexport const ThrottleBindingBehaviorRegistration = ThrottleBindingBehavior as IRegistry;\nexport const TwoWayBindingBehaviorRegistration = TwoWayBindingBehavior as IRegistry;\nexport const PriorityBindingBehaviorRegistration = PriorityBindingBehavior as IRegistry;\n\n/**\n * Default resources:\n * - Template controllers (`if`/`else`, `repeat`, `replaceable`, `with`)\n * - Value Converters (`sanitize`)\n * - Binding Behaviors (`oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`)\n */\nexport const DefaultResources = [\n  IfRegistration,\n  ElseRegistration,\n  RepeatRegistration,\n  ReplaceableRegistration,\n  WithRegistration,\n  SanitizeValueConverterRegistration,\n  DebounceBindingBehaviorRegistration,\n  OneTimeBindingBehaviorRegistration,\n  ToViewBindingBehaviorRegistration,\n  FromViewBindingBehaviorRegistration,\n  SignalBindingBehaviorRegistration,\n  PriorityBindingBehaviorRegistration,\n  ThrottleBindingBehaviorRegistration,\n  TwoWayBindingBehaviorRegistration\n];\n\nexport const CallBindingRendererRegistration = CallBindingRenderer as IRegistry;\nexport const CustomAttributeRendererRegistration = CustomAttributeRenderer as IRegistry;\nexport const CustomElementRendererRegistration = CustomElementRenderer as IRegistry;\nexport const InterpolationBindingRendererRegistration = InterpolationBindingRenderer as IRegistry;\nexport const IteratorBindingRendererRegistration = IteratorBindingRenderer as IRegistry;\nexport const LetElementRendererRegistration = LetElementRenderer as IRegistry;\nexport const PropertyBindingRendererRegistration = PropertyBindingRenderer as IRegistry;\nexport const RefBindingRendererRegistration = RefBindingRenderer as IRegistry;\nexport const SetPropertyRendererRegistration = SetPropertyRenderer as IRegistry;\nexport const TemplateControllerRendererRegistration = TemplateControllerRenderer as IRegistry;\n\n/**\n * Default renderers for:\n * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`\n * - IteratorBinding: `for`\n * - CallBinding: `call`\n * - RefBinding: `ref`\n * - InterpolationBinding: `${}`\n * - SetProperty\n * - `customElement` hydration\n * - `customAttribute` hydration\n * - `templateController` hydration\n * - `let` element hydration\n */\nexport const DefaultRenderers = [\n  PropertyBindingRendererRegistration,\n  IteratorBindingRendererRegistration,\n  CallBindingRendererRegistration,\n  RefBindingRendererRegistration,\n  InterpolationBindingRendererRegistration,\n  SetPropertyRendererRegistration,\n  CustomElementRendererRegistration,\n  CustomAttributeRendererRegistration,\n  TemplateControllerRendererRegistration,\n  LetElementRendererRegistration\n];\n\n/**\n * A DI configuration object containing environment/runtime-agnostic registrations:\n * - `DefaultComponents`\n * - `DefaultResources`\n * - `DefaultRenderers`\n */\nexport const RuntimeBasicConfiguration = {\n  /**\n   * Apply this configuration to the provided container.\n   */\n  register(container: IContainer): IContainer {\n    return container.register(\n      ...DefaultComponents,\n      ...DefaultResources,\n      ...DefaultRenderers\n    );\n  },\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n};\n","import {\n  IForOfStatement,\n  IInterpolationExpression,\n  IsBindingBehavior,\n} from './ast';\nimport {\n  ICallBindingInstruction,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateLetElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  ILetBindingInstruction,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  ISetPropertyInstruction,\n  ITargetedInstruction,\n  ITemplateDefinition,\n  TargetedInstructionType\n} from './definitions';\nimport { BindingMode } from './flags';\n\nexport class InterpolationInstruction implements IInterpolationInstruction {\n  public type: TargetedInstructionType.interpolation;\n\n  public from: string | IInterpolationExpression;\n  public to: string;\n\n  constructor(from: string | IInterpolationExpression, to: string) {\n    this.type = TargetedInstructionType.interpolation;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class OneTimeBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.oneTime;\n  public oneTime: true;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.oneTime;\n    this.oneTime = true;\n    this.to = to;\n  }\n}\n\nexport class ToViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.toView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.toView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class FromViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.fromView;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.fromView;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class TwoWayBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n\n  public from: string | IsBindingBehavior;\n  public mode: BindingMode.twoWay;\n  public oneTime: false;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.propertyBinding;\n\n    this.from = from;\n    this.mode = BindingMode.twoWay;\n    this.oneTime = false;\n    this.to = to;\n  }\n}\n\nexport class IteratorBindingInstruction implements IIteratorBindingInstruction {\n  public type: TargetedInstructionType.iteratorBinding;\n\n  public from: string | IForOfStatement;\n  public to: string;\n\n  constructor(from: string | IForOfStatement, to: string) {\n    this.type = TargetedInstructionType.iteratorBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class CallBindingInstruction implements ICallBindingInstruction {\n  public type: TargetedInstructionType.callBinding;\n\n  public from: string | IsBindingBehavior;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior, to: string) {\n    this.type = TargetedInstructionType.callBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n\nexport class RefBindingInstruction implements IRefBindingInstruction {\n  public type: TargetedInstructionType.refBinding;\n\n  public from: string | IsBindingBehavior;\n\n  constructor(from: string | IsBindingBehavior) {\n    this.type = TargetedInstructionType.refBinding;\n\n    this.from = from;\n  }\n}\n\nexport class SetPropertyInstruction implements ISetPropertyInstruction {\n  public type: TargetedInstructionType.setProperty;\n\n  public to: string;\n  public value: unknown;\n\n  constructor(value: unknown, to: string) {\n    this.type = TargetedInstructionType.setProperty;\n\n    this.to = to;\n    this.value = value;\n  }\n}\n\nexport class HydrateElementInstruction implements IHydrateElementInstruction {\n  public type: TargetedInstructionType.hydrateElement;\n\n  public instructions: ITargetedInstruction[];\n  public parts?: Record<string, ITemplateDefinition>;\n  public res: string;\n\n  constructor(res: string, instructions: ITargetedInstruction[], parts?: Record<string, ITemplateDefinition>) {\n    this.type = TargetedInstructionType.hydrateElement;\n\n    this.instructions = instructions;\n    this.parts = parts;\n    this.res = res;\n  }\n}\n\nexport class HydrateAttributeInstruction implements IHydrateAttributeInstruction {\n  public type: TargetedInstructionType.hydrateAttribute;\n\n  public instructions: ITargetedInstruction[];\n  public res: string;\n\n  constructor(res: string, instructions: ITargetedInstruction[]) {\n    this.type = TargetedInstructionType.hydrateAttribute;\n\n    this.instructions = instructions;\n    this.res = res;\n  }\n}\n\nexport class HydrateTemplateController implements IHydrateTemplateController {\n  public type: TargetedInstructionType.hydrateTemplateController;\n\n  public def: ITemplateDefinition;\n  public instructions: ITargetedInstruction[];\n  public link?: boolean;\n  public parts?: Record<string, ITemplateDefinition>;\n  public res: string;\n\n  constructor(\n    def: ITemplateDefinition,\n    res: string,\n    instructions: ITargetedInstruction[],\n    link?: boolean,\n    parts?: Record<string, ITemplateDefinition>,\n  ) {\n    this.type = TargetedInstructionType.hydrateTemplateController;\n\n    this.def = def;\n    this.instructions = instructions;\n    this.link = link;\n    this.parts = parts;\n    this.res = res;\n  }\n}\n\nexport class LetElementInstruction implements IHydrateLetElementInstruction {\n  public type: TargetedInstructionType.hydrateLetElement;\n\n  public instructions: ILetBindingInstruction[];\n  public toViewModel: boolean;\n\n  constructor(instructions: ILetBindingInstruction[], toViewModel: boolean) {\n    this.type = TargetedInstructionType.hydrateLetElement;\n\n    this.instructions = instructions;\n    this.toViewModel = toViewModel;\n  }\n}\n\nexport class LetBindingInstruction implements ILetBindingInstruction {\n  public type: TargetedInstructionType.letBinding;\n\n  public from: string | IsBindingBehavior | IInterpolationExpression;\n  public to: string;\n\n  constructor(from: string | IsBindingBehavior | IInterpolationExpression, to: string) {\n    this.type = TargetedInstructionType.letBinding;\n\n    this.from = from;\n    this.to = to;\n  }\n}\n"],"names":["slice","register","keyFrom","isType","define","RuntimeError","toView","oneTime","proto","native","methods","observe","descriptorProps","def","$clear","$delete","toStringTag","fromView"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YAAA;YACA;YACA;YACA;YACA;;YAEA;YACA;YACA;YACA;;YAEA;YACA;YACA;AACA,AAmCA;AACA,YAAO,SAAS,UAAU,CAAC,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE;YAC1D,IAAI,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;YACjI,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;YACnI,SAAS,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;YACtJ,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAClE,CAAC;;YC3CD;AAEA,qBAAgB,oBAAoB;;gBAElC,OAAO,UAAS,MAAgB;oBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,SAAkC,CAAC;oBAExD,KAAK,CAAC,gBAAgB,gBAAW;oBAEjC,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;oBACpC,KAAK,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBAC1C,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;oBACpC,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;oBACtC,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;oBAExC,IAAI,KAAK,CAAC,SAAS,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,SAAS,GAAG,aAAa,CAAC;oBAChE,IAAI,KAAK,CAAC,WAAW,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,WAAW,GAAG,gBAAgB,CAAC;iBACxE,CAAC;YACJ,CAAC;AAED,qBAAgB,yBAAyB;;gBAEvC,OAAO,UAAS,MAAgB;oBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,SAAuC,CAAC;oBAE7D,KAAK,CAAC,qBAAqB,gBAAW;oBAEtC,KAAK,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;oBAC9C,KAAK,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;oBACpD,KAAK,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;oBAC9C,KAAK,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;oBAChD,KAAK,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;oBAElD,IAAI,KAAK,CAAC,gBAAgB,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,gBAAgB,GAAG,kBAAkB,CAAC;oBACnF,IAAI,KAAK,CAAC,oBAAoB,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,oBAAoB,GAAG,qBAAqB,CAAC;iBAC/F,CAAC;YACJ,CAAC;AAED,qBAAgB,8BAA8B;;gBAE5C,OAAO,UAAS,MAAgB;oBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,SAA4C,CAAC;oBAElE,KAAK,CAAC,0BAA0B,gBAAW;oBAE3C,KAAK,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;oBACxD,KAAK,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;oBAC9D,KAAK,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;oBACxD,KAAK,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;oBAC1D,KAAK,CAAC,yBAAyB,GAAG,yBAAyB,CAAC;oBAE5D,IAAI,KAAK,CAAC,qBAAqB,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;oBAClG,IAAI,KAAK,CAAC,yBAAyB,KAAK,KAAK,CAAC;wBAAE,KAAK,CAAC,yBAAyB,GAAG,0BAA0B,CAAC;iBAC9G,CAAC;YACJ,CAAC;YAED,SAAS,aAAa,CAA8B,UAAuB;gBACzE,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE;oBAClC,OAAO,KAAK,CAAC;iBACd;gBACD,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBAC9C,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBAC5C,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;oBAC/B,IAAI,CAAC,gBAAgB,wBAAmB;iBACzC;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;oBAC/B,IAAI,CAAC,gBAAgB,wBAAmB;iBACzC;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC;oBAC/B,IAAI,CAAC,gBAAgB,wBAAmB;iBACzC;qBAAM,IAAI,CAAC,eAAe,gCAA2B,CAAC,EAAE;oBACvD,IAAI,CAAC,gBAAgB,GAAG,CAAC,UAAU,CAAC,CAAC;oBACrC,IAAI,CAAC,gBAAgB,4BAAuB;iBAC7C;qBAAM;;oBAEL,IAAI,CAAC,gBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;iBACzC;gBACD,OAAO,IAAI,CAAC;YACd,CAAC;YAED,SAAS,kBAAkB,CAAmC,UAA4B;gBACxF,IAAI,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,EAAE;oBACvC,OAAO,KAAK,CAAC;iBACd;gBACD,MAAM,eAAe,GAAG,IAAI,CAAC,qBAAqB,CAAC;gBACnD,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBAC5C,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;oBACpC,IAAI,CAAC,qBAAqB,wBAAmB;iBAC9C;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;oBACpC,IAAI,CAAC,qBAAqB,wBAAmB;iBAC9C;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;oBACpC,IAAI,CAAC,qBAAqB,wBAAmB;iBAC9C;qBAAM,IAAI,CAAC,eAAe,gCAA2B,CAAC,EAAE;oBACvD,IAAI,CAAC,qBAAqB,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC1C,IAAI,CAAC,qBAAqB,4BAAuB;iBAClD;qBAAM;;oBAEL,IAAI,CAAC,qBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;iBAC9C;gBACD,OAAO,IAAI,CAAC;YACd,CAAC;YAED,SAAS,uBAAuB,CAAwC,UAAiC;gBACvG,IAAI,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,EAAE;oBAC5C,OAAO,KAAK,CAAC;iBACd;gBACD,MAAM,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC;gBACxD,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBAC5C,IAAI,CAAC,sBAAsB,GAAG,UAAU,CAAC;oBACzC,IAAI,CAAC,0BAA0B,wBAAmB;iBACnD;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,sBAAsB,GAAG,UAAU,CAAC;oBACzC,IAAI,CAAC,0BAA0B,wBAAmB;iBACnD;qBAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;oBACnD,IAAI,CAAC,sBAAsB,GAAG,UAAU,CAAC;oBACzC,IAAI,CAAC,0BAA0B,wBAAmB;iBACnD;qBAAM,IAAI,CAAC,eAAe,gCAA2B,CAAC,EAAE;oBACvD,IAAI,CAAC,0BAA0B,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC/C,IAAI,CAAC,0BAA0B,4BAAuB;iBACvD;qBAAM;;oBAEL,IAAI,CAAC,0BAA2B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;iBACnD;gBACD,OAAO,IAAI,CAAC;YACd,CAAC;YAED,SAAS,gBAAgB,CAA8B,UAAuB;gBAC5E,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBAC9C,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBAC9E,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAI,CAAC,gBAAgB,8CAAoC;oBAClF,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBACrF,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAI,CAAC,gBAAgB,8CAAoC;oBAClF,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBACrF,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAI,CAAC,gBAAgB,8CAAoC;oBAClF,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAErD,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAiB,CAAC;oBAC3C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;4BACzB,IAAI,EAAE,KAAK,CAAC,EAAE;gCACZ,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAI,CAAC,gBAAgB,sDAA4C;6BAC3F;4BACD,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,qBAAqB,CAAmC,UAA4B;gBAC3F,MAAM,eAAe,GAAG,IAAI,CAAC,qBAAqB,CAAC;gBACnD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBACnF,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,CAAC;oBAChC,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,CAAC,qBAAqB,8CAAoC;oBAC5F,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBAC1F,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,CAAC;oBAChC,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,CAAC,qBAAqB,8CAAoC;oBAC5F,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBAC1F,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,CAAC;oBAChC,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,CAAC,qBAAqB,8CAAoC;oBAC5F,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAErD,MAAM,WAAW,GAAG,IAAI,CAAC,qBAAsB,CAAC;oBAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;4BACzB,IAAI,EAAE,KAAK,CAAC,EAAE;gCACZ,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,CAAC,qBAAqB,sDAA4C;6BACrG;4BACD,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,0BAA0B,CAAwC,UAAiC;gBAC1G,MAAM,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC;gBACxD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBACxF,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC,CAAC;oBACrC,IAAI,CAAC,0BAA0B,GAAG,CAAC,IAAI,CAAC,0BAA0B,8CAAoC;oBACtG,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBAC/F,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC,CAAC;oBACrC,IAAI,CAAC,0BAA0B,GAAG,CAAC,IAAI,CAAC,0BAA0B,8CAAoC;oBACtG,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBAC/F,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC,CAAC;oBACrC,IAAI,CAAC,0BAA0B,GAAG,CAAC,IAAI,CAAC,0BAA0B,8CAAoC;oBACtG,OAAO,IAAI,CAAC;iBACb;qBAAM,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAErD,MAAM,WAAW,GAAG,IAAI,CAAC,0BAA2B,CAAC;oBACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;4BACzB,IAAI,EAAE,KAAK,CAAC,EAAE;gCACZ,IAAI,CAAC,0BAA0B,GAAG,CAAC,IAAI,CAAC,0BAA0B,sDAA4C;6BAC/G;4BACD,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,cAAc;gBACrB,OAAO,IAAI,CAAC,gBAAgB,kBAAa;YAC3C,CAAC;YAED,SAAS,mBAAmB;gBAC1B,OAAO,IAAI,CAAC,qBAAqB,kBAAa;YAChD,CAAC;YAED,SAAS,wBAAwB;gBAC/B,OAAO,IAAI,CAAC,0BAA0B,kBAAa;YACrD,CAAC;YAED,SAAS,aAAa,CAA8B,UAAuB;;;;gBAIzE,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBAC9C,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBAC9E,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBAC9E,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;oBAC9E,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAE9C,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAiB,CAAC;oBAC3C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,kBAAkB,CAAmC,UAA4B;gBACxF,MAAM,eAAe,GAAG,IAAI,CAAC,qBAAqB,CAAC;gBACnD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBACnF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBACnF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,iBAAiB,KAAK,UAAU,EAAE;oBACnF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAE9C,MAAM,WAAW,GAAG,IAAI,CAAC,qBAAsB,CAAC;oBAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,uBAAuB,CAAwC,UAAiC;gBACvG,MAAM,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC;gBACxD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBACxF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBACxF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,sBAAsB,KAAK,UAAU,EAAE;oBACxF,OAAO,IAAI,CAAC;iBACb;gBACD,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;;oBAE9C,MAAM,WAAW,GAAG,IAAI,CAAC,0BAA2B,CAAC;oBACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BACjC,OAAO,IAAI,CAAC;yBACb;qBACF;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,eAAe,CAA8B,QAAiB,EAAE,aAAsB,EAAE,KAAS;;;;;;;;gBAQxG,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;gBACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;gBACtC,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;gBACtC,IAAI,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBACxC,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;iBACnC;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,cAAc,CAAC,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;iBACnH;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,cAAc,CAAC,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;iBACnH;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,cAAc,CAAC,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;iBACnH;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;oBAC/B,IAAI,UAAmC,CAAC;oBACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC5B,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;4BACzB,cAAc,CAAC,UAAU,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,EAAE,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;yBAChH;qBACF;iBACF;YACH,CAAC;YAED,SAAS,cAAc,CACrB,UAAuB,EACvB,QAAiB,EACjB,aAAsB,EACtB,KAAS,EACT,QAAY;gBAEZ,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,CAAC,CAAC,KAAK,yCAA6B,QAAQ,CAAC,CAAC;YACjG,CAAC;YAED,SAAS,oBAAoB,CAAmC,GAAgB,EAAE,QAAiB,EAAE,aAAsB,EAAE,KAAS;gBACpI,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;gBAC3C,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;gBAC3C,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;gBAC3C,IAAI,WAAW,GAAG,IAAI,CAAC,qBAAqB,CAAC;gBAC7C,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;iBACnC;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,iBAAiB,CAAC,GAAG,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;iBACpE;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,iBAAiB,CAAC,GAAG,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;iBACpE;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,iBAAiB,CAAC,GAAG,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;iBACpE;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;oBAC/B,IAAI,UAAwC,CAAC;oBAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC5B,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;4BACzB,UAAU,CAAC,iBAAiB,CAAC,GAAG,EAAE,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;yBACnE;qBACF;iBACF;YACH,CAAC;YAED,SAAS,yBAAyB,CAAwC,QAAkB,EAAE,KAAS;gBACrG,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC;gBAChD,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC;gBAChD,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC;gBAChD,IAAI,WAAW,GAAG,IAAI,CAAC,0BAA0B,CAAC;gBAClD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC;iBACnC;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACrD;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACrD;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,WAAW,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACrD;gBACD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;oBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;oBAC/B,IAAI,UAA6C,CAAC;oBAClD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC5B,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;4BACzB,UAAU,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;yBACpD;qBACF;iBACF;YACH,CAAC;;;AChaD,YAYA,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;YAGpC,MAAM,MAAM,GAA4B,IAAI,OAAO,EAAE,CAAC;YAItD,IAAa,yBAAyB,GAAtC,MAAa,yBAAyB;gBAMpC,YAAY,KAAmB,EAAE,GAAS,EAAE,GAAoB;oBAC9D,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,2BAA2B,EAAE,aAAa,EAAE,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAExG,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC;oBACpC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACzC,IAAI,GAAG,CAAC,GAAiB,CAAC,YAAY,MAAM,EAAE;wBAC5C,GAAG,CAAC,GAAiB,CAAC,GAAG,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,GAAiB,CAAsB,CAAC,CAAC,KAAoC,CAAC;qBACtI;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,QAAQ,CAAC,KAAc,EAAE,KAAsB;oBACpD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAiB,CAAC,CAAC;oBAClD,IAAI,QAAQ,KAAK,KAAK,EAAE;wBACtB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAiB,CAAC,GAAG,KAAyB,CAAC;wBAC7D,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAM,yDAAsE,CAAC;qBACpH;iBACF;gBACM,QAAQ;oBACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAiB,CAAC,CAAC;iBACzC;gBAEM,UAAU,CAAC,KAAqB;iBAEtC;aACF,CAAA;YApCY,yBAAyB;gBADrC,oBAAoB,EAAE;eACV,yBAAyB,CAoCrC;gBAKY,aAAa,8CAA1B,MAAa,aAAa;gBAKxB,YAAY,GAAS;oBACnB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,eAAe,EAAE,aAAa,EAAE,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC5F,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAO,GAAG,EAAE,IAAI,CAAiB,CAAC;oBACxD,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;oBAC5B,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;oBACtB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO,cAAc,CAA4B,GAAM;oBAC5D,IAAK,GAAoB,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzC,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAM,CAAC;wBACnC,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;4BACpB,OAAO,GAAG,CAAC;yBACZ;wBACD,OAAO,KAAK,CAAC;qBACd;oBACD,OAAO,GAAG,CAAC;iBACZ;gBACM,OAAO,aAAa,CAA4B,GAAM;oBAC3D,MAAM,GAAG,GAAI,GAAoB,CAAC,IAAI,CAAC;oBACvC,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;wBAClB,OAAO,GAAG,CAAC;qBACZ;oBACD,OAAO,GAAG,CAAC;iBACZ;gBAIM,OAAO,WAAW,CAAmB,GAAM,EAAE,GAAqB;oBACvE,IAAI,aAA+B,CAAC;oBACpC,IAAK,GAAwB,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;wBAC9B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;4BACpB,aAAa,GAAG,IAAI,eAAa,CAAC,GAAG,CAAC,CAAC;yBACxC;6BAAM;4BACL,aAAa,GAAI,KAA6C,CAAC,SAAS,CAAC;yBAC1E;qBACF;yBAAM;wBACL,aAAa,GAAI,GAA2C,CAAC,SAAS,CAAC;qBACxE;oBACD,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;wBAClB,OAAO,aAAa,CAAC;qBACtB;oBACD,IAAI,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;oBACjD,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;wBACpC,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;wBAClC,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,IAAI,yBAAyB,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;qBAC/F;oBACD,OAAO,WAAW,CAAC;iBACpB;gBAEM,OAAO,OAAO,CAAmB,GAAqB;oBAC3D,OAAO,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC;iBAC5B;gBAEM,GAAG,CAAC,MAAY,EAAE,CAAkB,EAAE,QAAkB;oBAC7D,IAAI,CAAC,KAAK,WAAW,EAAE;wBACrB,OAAO,IAAI,CAAC;qBACb;oBACD,IAAI,CAAC,KAAK,MAAM,EAAE;wBAChB,OAAO,MAAM,CAAC;qBACf;oBACD,OAAO,MAAM,CAAC,CAAe,CAAC,CAAC;iBAChC;gBAEM,GAAG,CAAC,MAAY,EAAE,CAAkB,EAAE,KAAc,EAAE,QAAkB;oBAC7E,MAAM,QAAQ,GAAG,MAAM,CAAC,CAAe,CAAC,CAAC;oBACzC,IAAI,QAAQ,KAAK,KAAK,EAAE;wBACtB,MAAM,CAAC,CAAe,CAAC,GAAG,KAAyB,CAAC;wBACpD,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;wBACjD,IAAI,CAAC,oBAAoB,CAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,sDAAmE,CAAC;qBACnH;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEM,cAAc,CAAC,MAAY,EAAE,CAAkB;oBACpD,MAAM,QAAQ,GAAG,MAAM,CAAC,CAAe,CAAC,CAAC;oBACzC,IAAI,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE;wBACrC,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;4BACvB,IAAI,CAAC,uBAAuB,CAAC,SAAS,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;4BACrD,IAAI,CAAC,oBAAoB,CAAC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,sDAAmE,CAAC;yBACvH;wBACD,OAAO,IAAI,CAAC;qBACb;oBACD,OAAO,KAAK,CAAC;iBACd;gBAEM,cAAc,CAAC,MAAY,EAAE,CAAkB,EAAE,UAA8B;oBACpF,MAAM,QAAQ,GAAG,MAAM,CAAC,CAAe,CAAC,CAAC;oBACzC,IAAI,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,UAAU,CAAC,EAAE;wBACjD,IAAI,UAAU,CAAC,KAAK,KAAK,QAAQ,EAAE;4BACjC,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;4BAC5D,IAAI,CAAC,oBAAoB,CAAC,CAAC,EAAE,UAAU,CAAC,KAAK,EAAE,QAAQ,EAAE,sDAAmE,CAAC;yBAC9H;wBACD,OAAO,IAAI,CAAC;qBACb;oBACD,OAAO,KAAK,CAAC;iBACd;gBAEM,KAAK,CAAC,MAAY,EAAE,OAAgB,EAAE,WAA+B,QAAQ,CAAC,UAAU;;oBAE7F,OAAO,OAAO,CAAC,KAAK,CAAC,MAAkB,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;iBAC5D;gBAIM,SAAS,CAAC,UAA0C,EAAE,GAAqB;oBAChF,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;wBAClB,IAAI,CAAC,kBAAkB,CAAC,UAA8B,CAAC,CAAC;qBACzD;yBAAM;wBACL,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;wBACxC,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;4BAC1B,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,IAAI,yBAAyB,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;yBAChG;wBACD,WAAW,CAAC,aAAa,CAAC,UAAyB,CAAC,CAAC;qBACtD;iBACF;gBAIM,WAAW,CAAC,UAA0C,EAAE,GAAqB;oBAClF,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;wBAClB,IAAI,CAAC,qBAAqB,CAAC,UAA8B,CAAC,CAAC;qBAC5D;yBAAM;wBACL,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;wBAC1C,IAAI,WAAW,KAAK,SAAS,EAAE;4BAC7B,WAAW,CAAC,gBAAgB,CAAC,UAAyB,CAAC,CAAC;yBACzD;qBACF;iBACF;gBAEO,uBAAuB,CAAC,QAAiB,EAAE,QAAiB,EAAE,GAAoB;oBACxF,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;oBAC1C,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,WAAW,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,sDAAmE,CAAC;qBACrH;iBACF;aACF,EAAA;YAhJY,aAAa;gBADzB,yBAAyB,EAAE;eACf,aAAa,EAgJzB;;gBCnMY,cAAc,6BAA3B,MAAa,cAAc;gBAYzB,YACE,SAAqB,EACrB,KAAqB,EACrB,GAAe,EACf,WAAmB;oBAEnB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAC/B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;oBAEvB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;oBAErE,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,QAAQ;oBACb,OAAO,IAAI,CAAC,YAAY,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,QAAiB,EAAE,KAAqB;oBACtD,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;wBACvC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;wBAC7B,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE;4BACpC,IAAI,CAAC,KAAK,4BAAgC,CAAC,EAAE;gCAC3C,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;6BAC5E;yBACF;6BAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;4BACxB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;4BACpB,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC;4BAC7B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBAChC;qBACF;yBAAM;;;;;;;wBAOL,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;qBACvC;iBACF;gBAEM,UAAU,CAAC,KAAqB;oBACrC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;oBACvC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAC/B,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC;oBAC7B,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,QAAQ,EAAE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;iBAC5E;gBAEM,SAAS,CAAC,UAAuB;oBACtC,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;wBAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBAC/C,IACE,CAAC,OAAO,CAAC,cAAc,CACrB,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,WAAW,EAChB;4BACE,UAAU,EAAE,IAAI;4BAChB,YAAY,EAAE,IAAI;4BAClB,GAAG,EAAE;gCACH,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;6BACxB;4BACD,GAAG,EAAE,KAAK;gCACR,IAAI,CAAC,QAAQ,CAAC,KAAK,eAAsB,CAAC;6BAC3C;yBACF,CACF,EACD;4BACA,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;yBAC/C;qBACF;oBAED,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;iBAChC;aACF,EAAA;YA/FY,cAAc;gBAD1B,oBAAoB,EAAE;eACV,cAAc,EA+F1B;;YC1FD,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;YAEpC,IAAW,YAIV;YAJD,WAAW,YAAY;gBACrB,yDAAc,CAAA;gBACd,6EAAwB,CAAA;gBACxB,qEAAoB,CAAA;YACtB,CAAC,EAJU,YAAY,KAAZ,YAAY,QAItB;YAED;AACA,kBAAa,uBAAuB;gBAC3B,WAAW,CAEhB,SAAqB,EACrB,KAAqB,EACrB,GAAuC,EACvC,GAAW;oBAEX,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,yBAAyB,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACtG,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,cAAc,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;qBAC5D;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;iBAClB;aACF;AAID,kBAAa,cAAc;gBASzB,YAAoB,QAA8B,EAAE,KAAe;oBACjE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;oBAEvB,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;;4BAEpB,IAAI,CAAC,QAAkB,CAAC,GAAG,KAAK,CAAC;yBAClC;6BAAM;;4BAEL,KAAK,MAAM,IAAI,IAAI,QAAsB,EAAE;gCACzC,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;oCACjC,IAAI,CAAC,IAAI,CAAC,GAAI,QAAuB,CAAC,IAAI,CAAC,CAAC;iCAC7C;6BACF;yBACF;qBACF;iBACF;gBAoBM,OAAO,MAAM,CAAC,KAAqB,EAAE,QAA8B,EAAE,KAAe;oBACzF,MAAM,EAAE,GAAG,IAAI,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;oBAC/C,IAAI,KAAK,0BAAiC;wBACxC,OAAO,aAAa,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;qBAC5C;oBACD,OAAO,EAAE,CAAC;iBACX;gBAEM,OAAO,GAAG,CAAC,KAAa,EAAE,IAAY,EAAE,QAAgB,EAAE,KAAqB;oBACpF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,gBAAgB,EAAE,KAAK,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACrF,IAAI,KAAK,IAAI,IAAI,EAAE;wBACjB,MAAM,QAAQ,CAAC,KAAK,oBAAuB,CAAC;qBAC7C;oBACD,IAAI,eAAe,GAAG,KAAK,CAAC,eAAe,CAAC;oBAE5C,IAAI,QAAQ,GAAG,CAAC,EAAE;;wBAEhB,OAAO,QAAQ,GAAG,CAAC,EAAE;4BACnB,IAAI,eAAe,CAAC,qBAAqB,IAAI,IAAI,EAAE;gCACjD,IAAI,MAAM,CAAC,OAAO,EAAE;oCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;iCAAE;gCACvC,OAAO,KAAK,CAAC,CAAC;6BACf;4BACD,QAAQ,EAAE,CAAC;4BACX,eAAe,GAAG,eAAe,CAAC,qBAAqB,CAAC;yBACzD;wBAED,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;qBACnF;;oBAGD,OAAO,eAAe,IAAI,EAAE,IAAI,IAAI,eAAe,CAAC,IAAI,EAAE,eAAe,CAAC,cAAc,IAAI,IAAI,IAAI,eAAe,CAAC,cAAc,CAAC,EAAE;wBACnI,eAAe,GAAG,eAAe,CAAC,qBAAsB,CAAC;qBAC1D;oBAED,IAAI,eAAe,EAAE;wBACnB,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;;wBAEvC,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;qBACnF;;oBAGD,IAAI,CAAC,KAAK,gDAA+C,CAAC,EAAE;wBAC1D,MAAM,SAAS,GAAG,KAAK,CAAC,UAAW,CAAC,cAAc,CAAC,QAAS,CAAE,CAAC;wBAC/D,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK;;8BAEpD;;qEAEuC,CAAC;wBAC5C,IAAI,MAAM,KAAK,IAAI,EAAE;4BACnB,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO,MAAM,CAAC;yBACf;qBACF;;;;oBAKD,IAAI,KAAK,2CAA2C;wBAClD,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO,IAAI,CAAC;qBACb;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,eAAe,CAAC;iBACtD;gBAEM,YAAY,CAAC,KAAqB;oBACvC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,gBAAgB,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC9F,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;wBAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,uBAAuB,EAAuC,CAAC;qBACtF;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,CAAC,UAAU,CAAC;iBACxB;;YArHa,uBAAQ,GAAkB,IAAI,CAAC;AAwH/C,kBAAa,KAAK;gBAMhB,YAAoB,cAAsB,EAAE,eAAiC;oBAC3E,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;oBACrC,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC;iBAC1B;gBA8BM,OAAO,MAAM,CAAC,KAAqB,EAAE,EAAU,EAAE,EAA4B;oBAClF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC/E,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,EAAE,IAAI,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,EAAE,EAAG,CAAC,GAAG,EAAE,CAAC,CAAC;iBAChF;gBAEM,OAAO,YAAY,CAAC,KAAqB,EAAE,EAAoB;oBACpE,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACrF,IAAI,EAAE,IAAI,IAAI,EAAE;wBACd,MAAM,QAAQ,CAAC,KAAK,8BAAiC,CAAC;qBACvD;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,KAAK,CAAC,EAAE,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;iBACzC;gBAEM,OAAO,UAAU,CAAC,KAAqB,EAAE,EAAiB,EAAE,EAAU;oBAC3E,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,YAAY,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACnF,IAAI,EAAE,IAAI,IAAI,EAAE;wBACd,MAAM,QAAQ,CAAC,KAAK,0BAA6B,CAAC;qBACnD;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,eAAe,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;iBAC7E;sCACF;AAED,kBAAa,eAAe;gBAO1B,YAAoB,cAAsB,EAAE,qBAA8C;oBACxF,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;oBACvB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;oBACrC,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;iBACpD;gBAEM,OAAO,MAAM,CAAC,KAAqB,EAAE,EAAU,EAAE,GAA4B;oBAClF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,iBAAiB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACzF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,eAAe,CAAC,EAAE,EAAE,GAAG,KAAK,KAAK,CAAC,GAAG,IAAI,GAAG,GAAG,CAAC,CAAC;iBAC7D;gBAEM,YAAY;oBACjB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,iBAAiB,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC/F,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,EAAE;wBAC9B,IAAI,CAAC,UAAU,GAAG,IAAI,uBAAuB,EAAE,CAAC;qBACjD;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,CAAC,UAA+C,CAAC;iBAC7D;aACF;;kBClPY,SAAS,wBAAG,EAAE,CAAC,eAAe,CAAY,WAAW,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAC;YAE5G;AACA,kBAAa,QAAQ;gBAGnB;oBACE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iBACpC;gBAEM,cAAc,CAAC,IAAY,EAAE,KAAsB;oBACxD,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBACrC,IAAI,SAAS,KAAK,SAAS,EAAE;wBAC3B,OAAO;qBACR;oBACD,KAAK,MAAM,QAAQ,IAAI,SAAS,CAAC,IAAI,EAAE,EAAE;wBACvC,QAAQ,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,EAAE,KAAM,iCAAuC,CAAC;qBAC3F;iBACF;gBAEM,iBAAiB,CAAC,IAAY,EAAE,QAAqB;oBAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;oBAChC,IAAI,SAAS,KAAK,SAAS,EAAE;wBAC3B,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;qBACrC;yBAAM;wBACL,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;qBACzB;iBACF;gBAEM,oBAAoB,CAAC,IAAY,EAAE,QAAqB;oBAC7D,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBACrC,IAAI,SAAS,EAAE;wBACb,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;qBAC5B;iBACF;aACF;;YCtBD,SAAS,QAAQ,CAA6B,SAAqB;gBACjE,MAAM,WAAW,GAAG,uBAAuB,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC3E,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC9D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACzD,CAAC;AAKD,qBAAgB,eAAe,CAAC,gBAAqD;gBACnF,OAAO,MAAM,IAAI,uBAAuB,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;YAC5E,CAAC;YAED,SAAS,OAAO,CAAiC,IAAY;gBAC3D,OAAO,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;YAChC,CAAC;YAED,SAAS,MAAM,CAAoC,IAAuC;gBACxF,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;YAC5B,CAAC;YAKD,SAAS,MAAM,CAA0E,gBAAqD,EAAE,IAAO;gBACrJ,MAAM,IAAI,GAAG,IAAmC,CAAC;gBACjD,MAAM,YAAY,GAAG,IAA6C,CAAC;gBACnE,MAAM,WAAW,GAAG,OAAO,gBAAgB,KAAK,QAAQ;sBACpD,EAAE,IAAI,EAAE,gBAAgB,EAAE;sBAC1B,gBAAgB,CAAC;gBAErB,YAAY,CAAC,IAAI,GAAG,uBAAmD,CAAC;gBACxE,YAAY,CAAC,WAAW,GAAG,WAAW,CAAC;gBACvC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;gBAEzB,OAAO,IAAI,CAAC;YACd,CAAC;AAED,kBAAa,uBAAuB,sCAAG;gBACrC,IAAI,EAAE,kBAAkB;gBACxB,OAAO;gBACP,MAAM;gBACN,MAAM;aACP;;YC/CD,SAASC,UAAQ,CAA4B,SAAqB;gBAChE,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC7D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC9D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACzD,CAAC;AAKD,qBAAgB,cAAc,CAAC,gBAAoD;gBACjF,OAAO,MAAM,IAAI,sBAAsB,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;YAC3E,CAAC;YAED,SAASC,SAAO,CAAgC,IAAY;gBAC1D,OAAO,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;YAChC,CAAC;YAED,SAASC,QAAM,CAAmC,IAAsC;gBACtF,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;YAC5B,CAAC;YAKD,SAASC,QAAM,CAAyE,gBAAoD,EAAE,IAAO;gBACnJ,MAAM,IAAI,GAAG,IAAyC,CAAC;gBACvD,MAAM,WAAW,GAAG,OAAO,gBAAgB,KAAK,QAAQ;sBACpD,EAAE,IAAI,EAAE,gBAAgB,EAAE;sBAC1B,gBAAgB,CAAC;gBAErB,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;gBACnC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;gBAC/B,IAAI,CAAC,QAAQ,GAAGH,UAAQ,CAAC;gBAEzB,OAAO,IAAkC,CAAC;YAC5C,CAAC;AAED,kBAAa,sBAAsB,qCAAG;gBACpC,IAAI,EAAE,iBAAiB;yBACvBC,SAAO;wBACPC,QAAM;wBACNC,QAAM;aACP;;qBCgBe,QAAQ,CAAC,IAA6B;gBACpD,OAAO,CAAC,IAAI,CAAC,KAAK,4CAAwD;YAC5E,CAAC;AACD,qBAAgB,QAAQ,CAAC,IAA6B;gBACpD,OAAO,CAAC,IAAI,CAAC,KAAK,4CAAwD;YAC5E,CAAC;AACD,qBAAgB,aAAa,CAAC,IAA6B;gBACzD,OAAO,CAAC,IAAI,CAAC,KAAK,wDAAkE;YACtF,CAAC;AACD,qBAAgB,WAAW,CAAC,IAA6B;gBACvD,OAAO,CAAC,IAAI,CAAC,KAAK,oDAA8D;YAClF,CAAC;AACD,qBAAgB,YAAY,CAAC,IAA6B;gBACxD,OAAO,CAAC,IAAI,CAAC,KAAK,wDAAgE;YACpF,CAAC;AACD,qBAAgB,cAAc,CAAC,IAA6B;gBAC1D,OAAO,CAAC,IAAI,CAAC,KAAK,4DAAoE;YACxF,CAAC;AACD,qBAAgB,SAAS,CAAC,IAA6B;gBACrD,OAAO,CAAC,IAAI,CAAC,KAAK,gDAA0D;YAC9E,CAAC;AACD,qBAAgB,UAAU,CAAC,IAA6B;gBACtD,OAAO,CAAC,IAAI,CAAC,KAAK,sDAA4D;YAChF,CAAC;AACD,qBAAgB,OAAO,CAAC,IAA6B;gBACnD,OAAO,CAAC,IAAI,CAAC,KAAK,8CAAsD;YAC1E,CAAC;AACD,qBAAgB,SAAS,CAAC,IAA6B;gBACrD,OAAO,CAAC,IAAI,CAAC,KAAK,kDAA0D;YAC9E,CAAC;AACD,qBAAgB,SAAS,CAAC,IAA6B;gBACrD,OAAO,CAAC,IAAI,CAAC,KAAK,oDAA0D;YAC9E,CAAC;AACD,qBAAgB,eAAe,CAAC,WAA+D;gBAC7F,IAAI,WAAW,KAAK,KAAK,CAAC,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;oBACtD,OAAO,IAAI,CAAC;iBACb;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;oBAC3C,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;wBAClC,OAAO,KAAK,CAAC;qBACd;iBACF;gBACD,OAAO,IAAI,CAAC;YACd,CAAC;AACD,qBAAgB,aAAa,CAAC,IAA6B;gBACzD,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;oBACnB,QAAQ,IAAI,CAAC,KAAK;wBAChB;4BACE,OAAO,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBACxC;4BACE,OAAO,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACtC;4BACE,OAAO,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBAC3C;4BACE,OAAO,IAAI,CAAC;qBACf;iBACF;gBACD,OAAO,KAAK,CAAC;YACf,CAAC;YAED,IAAWC,cASV;YATD,WAAW,YAAY;gBACrB,2DAAe,CAAA;gBACf,uEAAqB,CAAA;gBACrB,qFAA4B,CAAA;gBAC5B,yEAAsB,CAAA;gBACtB,2DAAe,CAAA;gBACf,iEAAkB,CAAA;gBAClB,uEAAqB,CAAA;gBACrB,yDAAc,CAAA;YAChB,CAAC,EATUA,cAAY,KAAZA,cAAY,QAStB;AAED,kBAAa,eAAe;gBAO1B,YAAY,UAA6B,EAAE,IAAY,EAAE,IAA6B;oBACpF,IAAI,CAAC,KAAK,+BAAkC;oBAC5C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,WAAW,GAAG,uBAAuB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC/D;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACxD;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,OAAO,IAAI,CAAC,UAAU,CAAC,MAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;iBAC9D;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAChD;gBAEM,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA8E;oBAC9H,IAAI,KAAK,IAAI,IAAI,EAAE;wBACjB,MAAM,QAAQ,CAAC,KAAK,qBAAwB,IAAI,CAAC,CAAC;qBACnD;oBACD,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;oBAChC,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,IAAI,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;wBAC5B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC7C;oBACD,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAmB,WAAW,CAAC,CAAC;oBAC5D,IAAI,CAAC,QAAQ,EAAE;wBACb,MAAM,QAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;qBAC1D;oBACD,IAAI,OAAO,CAAC,WAAW,CAAC,KAAK,KAAK,CAAC,EAAE;wBACnC,OAAO,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;wBAC/B,QAAQ,CAAC,IAAI,CAAC,IAAqC,CAAC,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;qBACtI;yBAAM;wBACL,QAAQ,CAAC,KAAK,mCAAsC,IAAI,CAAC,CAAC;qBAC3D;iBACF;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA8E;oBAChI,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,IAAI,OAAO,CAAC,WAAW,CAAC,KAAK,KAAK,CAAC,EAAE;wBACnC,OAAO,CAAC,WAAW,CAAE,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBACpD,OAAO,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC,CAAC;qBAC/B;yBAAM;;;wBAGL,QAAQ,CAAC,KAAK,mCAAsC,IAAI,CAAC,CAAC;qBAC3D;oBACD,IAAI,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;wBAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC/C;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;iBAC3C;0DACF;AAED,kBAAa,cAAc;gBAOzB,YAAY,UAA4B,EAAE,IAAY,EAAE,IAA6B;oBACnF,IAAI,CAAC,KAAK,8BAAiC;oBAC3C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,YAAY,GAAG,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC/D;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAmC,IAAI,CAAC,YAAY,CAAC,CAAC;oBACnF,IAAI,CAAC,SAAS,EAAE;wBACd,MAAM,QAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;qBAC3D;oBACD,IAAI,QAAQ,IAAI,SAAS,EAAE;wBACzB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;wBACvB,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;wBACxB,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;wBAC9B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;4BAC5B,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;yBACzD;wBACD,OAAQ,SAAS,CAAC,MAAM,CAAC,IAAqC,CAAC,SAAS,EAAE,GAAG,MAAM,CAAC,CAAC;qBACtF;oBACD,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACxD;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAmC,IAAI,CAAC,YAAY,CAAC,CAAC;oBACnF,IAAI,CAAC,SAAS,EAAE;wBACd,MAAM,QAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;qBAC3D;oBACD,IAAI,UAAU,IAAI,SAAS,EAAE;wBAC3B,KAAK,GAAI,SAAS,CAAC,QAAS,CAAC,IAAqC,CAAC,SAAS,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACvI;oBACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;iBAC9D;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,IAAI,KAAK,IAAI,IAAI,EAAE;wBACjB,MAAM,QAAQ,CAAC,KAAK,qBAAwB,IAAI,CAAC,CAAC;qBACnD;oBACD,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;oBAChC,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,QAAQ,CAAC,KAAK,sBAAyB,IAAI,CAAC,CAAC;qBACpD;oBACD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBACxC;oBACD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAA2B,CAAC;oBAC3E,IAAI,CAAC,SAAS,EAAE;wBACd,MAAM,QAAQ,CAAC,KAAK,6BAAgC,IAAI,CAAC,CAAC;qBAC3D;oBACD,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;oBAClC,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;wBACtB,OAAO;qBACR;oBACD,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAChD,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;qBACjD;iBACF;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC9E,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;oBAChC,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAA2B,CAAC;oBAC3E,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;oBAClC,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;wBACtB,OAAO;qBACR;oBACD,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAChD,QAAQ,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;qBACpD;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;iBAC1C;wDACF;AAED,kBAAa,MAAM;gBAKjB,YAAY,MAAoB,EAAE,KAAe;oBAC/C,IAAI,CAAC,KAAK,qBAAyB;oBACnC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;iBACpB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;iBAC9F;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,OAAO;iBACR;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,IAAI,CAAC,KAAK,CAAC,MAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;oBACjD,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;iBACzD;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;iBAClC;wCACF;AAED,kBAAa,WAAW;gBAOtB,YAAY,SAAmB,EAAE,GAAa,EAAE,EAAY;oBAC1D,IAAI,CAAC,KAAK,wBAA8B;oBACxC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC;0BACpD,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC;0BACxC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAC7C;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;oBACjC,IAAI,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;wBAC1C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBAC9C,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBACzC;yBAAM;wBACL,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBAC9C,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBACxC;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;iBACvC;kDACF;AAED,kBAAa,UAAU;gBAQrB,YAAY,WAAmB,CAAC;oBAC9B,IAAI,CAAC,KAAK,yBAA6B;oBACvC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC;oBAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,IAAI,KAAK,IAAI,IAAI,EAAE;wBACjB,MAAM,QAAQ,CAAC,KAAK,qBAAwB,IAAI,CAAC,CAAC;qBACnD;oBACD,IAAI,EAAE,GAA4B,KAAK,CAAC,eAAe,CAAC;oBACxD,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;oBACtB,OAAO,CAAC,EAAE,IAAI,EAAE,EAAE;wBAChB,EAAE,GAAG,EAAE,CAAC,qBAAqB,CAAC;qBAC/B;oBACD,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC;iBACjD;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;iBACtC;;YA5BsB,gBAAK,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;YACtC,kBAAO,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;AA8BjE,kBAAa,WAAW;gBAKtB,YAAY,IAAY,EAAE,WAAmB,CAAC;oBAC5C,IAAI,CAAC,KAAK,2BAA8B;oBACxC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAQ,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAqB,CAAC,IAAI,CAAC,IAAI,CAAkD,CAAC;iBACpJ;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,MAAM,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAoB,CAAC;oBAC1F,IAAI,GAAG,YAAY,MAAM,EAAE;wBACzB,IAAI,GAAG,CAAC,UAAU,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;4BACrE,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;4BACjD,OAAO,KAAK,CAAC;yBACd;6BAAM;4BACL,OAAO,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;yBAC/B;qBACF;oBACD,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAE,CAAC;oBAC5E,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;iBACpD;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;iBACvC;kDACF;AAED,kBAAa,YAAY;gBAKvB,YAAY,MAAsB,EAAE,IAAY;oBAC9C,IAAI,CAAC,KAAK,2BAA+B;oBACzC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAe,CAAC;oBAC3E,OAAO,QAAQ,IAAI,IAAI,GAAG,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC1D;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAoB,CAAC;oBAC3E,IAAI,GAAG,YAAY,MAAM,EAAE;wBACzB,IAAI,GAAG,CAAC,UAAU,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;4BACrE,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;yBAClD;6BAAM;4BACL,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;yBACxB;qBACF;yBAAM;wBACL,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,EAAE,CAAC,CAAC;qBACpE;oBACD,OAAO,KAAK,CAAC;iBACd;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAe,CAAC;oBACnE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBAC3C,IAAI,GAAG,YAAY,MAAM,EAAE;wBACzB,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;qBAChD;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;iBACxC;oDACF;AAED,kBAAa,WAAW;gBAKtB,YAAY,MAAsB,EAAE,GAAa;oBAC/C,IAAI,CAAC,KAAK,0BAA8B;oBACxC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;iBAChB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAe,CAAC;oBAC3E,IAAI,QAAQ,YAAY,MAAM,EAAE;wBAC9B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAW,CAAC;wBAC/D,OAAQ,QAAuB,CAAC,GAAG,CAAC,CAAC;qBACtC;oBACD,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,KAAc;oBAC1F,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAe,CAAC;oBAC3E,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAW,CAAC;oBAC/D,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;iBAC9B;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACrD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBAC3C,IAAI,GAAG,YAAY,MAAM,EAAE;wBACzB,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBACxC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;wBAElD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;;4BAExC,IAAI,KAAK,0BAAiC;gCACxC,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,GAAwB,CAAC,CAAC;6BAC/D;yBACF;6BAAM;;;4BAGL,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,GAAa,CAAC,CAAC;yBACpD;qBACF;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;iBACvC;kDACF;AAED,kBAAa,SAAS;gBAOpB,YAAY,IAAY,EAAE,IAA6B,EAAE,WAAmB,CAAC;oBAC3E,IAAI,CAAC,KAAK,wBAA4B;oBACtC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA+B;oBACnF,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBACxD,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAE,CAAC;oBAC5E,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBACpD,IAAI,IAAI,EAAE;wBACR,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAiB,CAAC,CAAC;qBAC/C;oBACD,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBACxC;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;iBACrC;8CACF;AAED,kBAAa,UAAU;gBAOrB,YAAY,MAAsB,EAAE,IAAY,EAAE,IAA6B;oBAC7E,IAAI,CAAC,KAAK,yBAA6B;oBACvC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAe,CAAC;oBAC3E,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBACxD,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBACrD,IAAI,IAAI,EAAE;wBACR,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAiB,CAAC,CAAC;qBAChD;oBACD,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAe,CAAC;oBACnE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBAC3C,IAAI,WAAW,CAAC,KAAK,GAAG,6BAA8B,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE;wBACrE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;wBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;yBACxC;qBACF;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;iBACtC;gDACF;AAED,kBAAa,YAAY;gBAMvB,YAAY,IAAoB,EAAE,IAA6B;oBAC7D,IAAI,CAAC,KAAK,2BAA+B;oBACzC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBACvD,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;wBAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;qBACrE;oBACD,IAAI,EAAE,KAAK,8BAA+B,KAAK,IAAI,IAAI,IAAI,CAAC,EAAE;wBAC5D,OAAO,KAAK,CAAC,CAAC;qBACf;oBACD,MAAM,QAAQ,CAAC,KAAK,yBAA4B,IAAI,CAAC,CAAC;iBACvD;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACpD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBACzC,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;wBAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;wBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;yBACxC;qBACF;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;iBACxC;oDACF;AAED,kBAAa,MAAM;gBAOjB,YAAY,SAAyB,EAAE,IAAc,EAAE,KAAe;oBACpE,IAAI,CAAC,KAAK,mBAAyB;oBACnC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;;;;oBAKnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAA4B,CAAC;iBAC5D;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;iBAC1D;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACpD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBACzC,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,EAAE;wBACvE,OAAO;qBACR;oBACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAC3C;gBAEO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACpE;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACpE;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;oBAE7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACpE;gBACO,CAAC,KAAK,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC9D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACrE;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;;oBAE7D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACpE;gBACO,CAAC,KAAK,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC9D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACrE;gBACO,CAAC,YAAY,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBACrE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3C,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;wBAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,YAAY,KAAK,CAAC;qBACrD;oBACD,OAAO,KAAK,CAAC;iBACd;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3C,IAAI,KAAK,YAAY,MAAM,EAAE;wBAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAW,IAAI,KAAK,CAAC;qBACvD;oBACD,OAAO,KAAK,CAAC;iBACd;;;;;gBAKO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC5D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC3F;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC7D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,IAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC5F;gBACO,CAAC,IAAI,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC7D,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,IAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBAC5F;;gBAGM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;iBAClC;wCACF;AAED,kBAAa,KAAK;gBAMhB,YAAY,SAAwB,EAAE,UAA0B;oBAC9D,IAAI,CAAC,KAAK,kBAAwB;oBAClC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;;oBAG7B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAA4B,CAAC;iBAC5D;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,CAAC,KAAK,4BAA+B,IAAI,CAAC,CAAC;iBAC1D;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAChD;gBAEM,CAAC,MAAM,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC9D,OAAO,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBAC/C;gBACM,CAAC,QAAQ,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAChE,OAAO,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACjD;gBACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC3D,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBAC3C;gBACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC3D,OAAO,CAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBACvD;gBACM,CAAC,GAAG,CAAC,CAAC,CAAiB,EAAE,CAAS,EAAE,CAAkB;oBAC3D,OAAO,CAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;iBACvD;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;iBACjC;sCACF;AACD,kBAAa,gBAAgB;gBAW3B,YAAY,KAAa;oBACvB,IAAI,CAAC,KAAK,gCAAmC;oBAC7C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC;oBAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;iBACpB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAO,IAAI,CAAC,KAAK,CAAC;iBACnB;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;iBAC5C;;YAvBsB,2BAAU,GAAgC,IAAI,gBAAgB,CAAY,KAAK,CAAC,CAAC,CAAC;YAClF,sBAAK,GAA2B,IAAI,gBAAgB,CAAO,IAAI,CAAC,CAAC;YACjE,sBAAK,GAA2B,IAAI,gBAAgB,CAAO,IAAI,CAAC,CAAC;YACjE,uBAAM,GAA4B,IAAI,gBAAgB,CAAQ,KAAK,CAAC,CAAC;YACrE,uBAAM,GAA6B,IAAI,gBAAgB,CAAK,EAAE,CAAC,CAAC;AAsBzF,kBAAa,WAAW;gBAKtB,YAAY,KAAiC;oBAC3C,IAAI,CAAC,KAAK,wBAA8B;oBACxC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;iBACpB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;oBAC5B,IAAI,MAAM,GAAG,EAAE,CAAC;oBAChB,IAAI,KAAK,CAAC;oBACV,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACjD,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBACpD,IAAI,KAAK,IAAI,IAAI,EAAE;4BACjB,SAAS;yBACV;wBACD,MAAM,IAAI,KAAK,CAAC;qBACjB;oBACD,OAAO,MAAM,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACnD,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC9C;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;iBACvC;kDACF;AAED,kBAAa,YAAY;gBAMvB,YAAY,QAAiC;oBAC3C,IAAI,CAAC,KAAK,4BAA+B;oBACzC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAC/B,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;oBAC/B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBACzD;oBACD,OAAO,MAAM,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACjD,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC5C;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;iBACxC;;YA9BsB,mBAAM,GAAiB,IAAI,YAAY,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AAiCtF,kBAAa,aAAa;gBAOxB,YAAY,IAAoC,EAAE,MAA+B;oBAC/E,IAAI,CAAC,KAAK,6BAAgC;oBAC1C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;iBACtB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,QAAQ,GAA4B,EAAE,CAAC;oBAC7C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC7C,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC/D;oBACD,OAAO,QAAQ,CAAC;iBACjB;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC7C,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC1C;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;iBACzC;;YAjCsB,oBAAM,GAAkB,IAAI,aAAa,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;AAoC7G,kBAAa,QAAQ;gBAOnB,YAAY,MAA6B,EAAE,WAAqC;oBAC9E,IAAI,CAAC,KAAK,wBAA2B;oBACrC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,WAAW,GAAG,WAAW,KAAK,KAAK,CAAC,GAAG,QAAQ,CAAC,UAAU,GAAG,WAAW,CAAC;iBAC/E;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC3B,IAAI,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;oBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBACzD,MAAM,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;qBACzB;oBACD,OAAO,MAAM,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;wBAC9C,CAAC,EAAE,CAAC;qBACL;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;iBACpC;;YAlCsB,eAAM,GAAa,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAqC/D,kBAAa,cAAc;gBAOzB,YAAY,MAA+D,EAAE,GAA0B,EAAE,IAAoB,EAAE,WAAqC;oBAClK,IAAI,CAAC,KAAK,6BAAiC;oBAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;oBACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,WAAW,GAAG,WAAW,KAAK,KAAK,CAAC,GAAG,QAAQ,CAAC,UAAU,GAAG,WAAW,CAAC;iBAC/E;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,MAAM,GAAG,GAAG,WAAW,CAAC,MAAM,CAAC;oBAC/B,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACrC,OAAO,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC7D;oBACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBACvD,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;wBAC9B,MAAM,QAAQ,CAAC,KAAK,yBAA4B,IAAI,CAAC,CAAC;qBACvD;oBACD,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;iBACxD;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;oBACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC/C;oBACD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAC1C;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;iBAC1C;wDACF;AAED,kBAAa,mBAAmB;;gBAK9B,YAAY,QAAiC;oBAC3C,IAAI,CAAC,KAAK,mCAAsC;oBAChD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;;oBAE5E,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,GAAe;;oBAE3F,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,OAAO;iBACR;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;iBAC/C;kEACF;AAED,kBAAa,oBAAoB;;gBAM/B,YAAY,IAAoC,EAAE,MAA+B;oBAC/E,IAAI,CAAC,KAAK,oCAAuC;oBACjD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;iBACtB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;;oBAE5E,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB,EAAE,GAAe;;oBAE3F,OAAO,KAAK,CAAC,CAAC;iBACf;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,OAAO;iBACR;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;iBAChD;oEACF;AAED,kBAAa,iBAAiB;gBAI5B,YAAY,IAAY;oBACtB,IAAI,CAAC,KAAK,iCAAoC;oBAC9C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA+B;oBACnF,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBACM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,OAAO;iBACR;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;iBAC7C;8DACF;YAED,MAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAEpC,CAAC;YAEF;YACA;AACA,kBAAa,cAAc;gBAMzB,YAAY,WAAuC,EAAE,QAA2B;oBAC9E,IAAI,CAAC,KAAK,6BAAiC;oBAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAC/B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACtD;gBAEM,KAAK,CAAC,KAAqB,EAAE,MAAsD;oBACxF,OAAO,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,MAAa,CAAC,CAAC;iBACrE;gBAEM,OAAO,CAAC,KAAqB,EAAE,MAAsD,EAAE,IAA6D;oBACzJ,qBAAqB,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,mCAAmC,MAAa,EAAE,IAAI,CAAC,CAAC;iBAC9G;gBAEM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;oBAChD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBAC9C;gBAEM,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC5E,IAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;wBAC1B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC3C;iBACF;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC9E,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;wBAC5B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;qBAC7C;iBACF;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;iBAC1C;wDACF;YAED;;;;;AAKA,kBAAa,aAAa;gBAOxB,YAAY,KAA4B,EAAE,WAA8C;oBACtF,IAAI,CAAC,KAAK,0BAAgC;oBAC1C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAqB,CAAC;oBAC7C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,WAAW,GAAG,WAAW,KAAK,KAAK,CAAC,GAAG,QAAQ,CAAC,UAAU,GAAG,WAAW,CAAC;oBAC9E,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;oBAC3C,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;iBAC5C;gBAEM,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAAwB;oBAC5E,IAAI,IAAI,CAAC,OAAO,EAAE;wBAChB,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;wBACrC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;wBACzB,IAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BACpD,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;4BACzD,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;yBACxB;wBACD,OAAO,MAAM,CAAC;qBACf;yBAAM;wBACL,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;wBACzB,OAAO,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;qBACnF;iBACF;gBACM,OAAO,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;oBAC/E,OAAO;iBACR;gBAEM,MAAM,CAAI,OAAoB;oBACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;iBACzC;sDACF;YAED;YACA,SAAS,QAAQ,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA+B,EAAE,IAAgC;gBACvH,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;gBACxB,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;gBAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;oBAC5B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;iBACrD;gBACD,OAAO,MAAM,CAAC;YAChB,CAAC;YAED,SAAS,WAAW,CAAC,KAAqB,EAAE,GAAe,EAAE,IAAY;gBACvE,MAAM,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;oBAC9B,OAAO,IAAuC,CAAC;iBAChD;gBACD,IAAI,EAAE,KAAK,8BAA+B,IAAI,IAAI,IAAI,IAAI,EAAE;oBAC1D,OAAO,IAAI,CAAC;iBACb;gBACD,MAAM,QAAQ,CAAC,KAAK,yBAA4B,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YACnE,CAAC;YAED,MAAM,qBAAqB,GAAG,uDAA8D;YAE5F;AACA,YAAO,MAAM,qBAAqB,GAAG;gBACnC,CAAC,gBAAgB,CAAC,CAAC,KAAqB,EAAE,MAAiB,EAAE,IAA6D;oBACxH,IAAI,CAAC,KAAK,GAAG,qBAAqB,MAAM,qBAAqB,EAAE;;;;wBAI7D,MAAM,QAAQ,GAAG,aAAa,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;wBACrD,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;wBAC5B,IAAI,IAAa,CAAC;wBAClB,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,OAAO,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;4BACnB,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;4BACnB,IAAI,IAAI,YAAY,MAAM,EAAE;gCAC1B,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;6BAC5D;4BACD,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;yBACzB;qBACF;yBAAM;wBACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC/C,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;yBAC5B;qBACF;iBACF;gBACD,CAAC,cAAc,CAAC,CAAC,KAAqB,EAAE,MAA6B,EAAE,IAA6D;oBAClI,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oBACX,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;wBACpC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC;qBAClB;oBACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,KAAK,GAAG,iCAAiC,GAAG,EAAE,IAAI,CAAC,CAAC;iBAC7F;gBACD,CAAC,cAAc,CAAC,CAAC,KAAqB,EAAE,MAAoB,EAAE,IAA6D;oBACzH,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oBACX,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,EAAE;wBAC/B,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC;qBAChB;oBACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,KAAK,GAAG,iCAAiC,GAAG,EAAE,IAAI,CAAC,CAAC;iBAC7F;gBACD,CAAC,iBAAiB,CAAC,CAAC,KAAqB,EAAE,MAAc,EAAE,IAA6D;oBACtH,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;qBACZ;oBACD,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,KAAK,GAAG,iCAAiC,GAAG,EAAE,IAAI,CAAC,CAAC;iBAC7F;gBACD,CAAC,eAAe,CAAC,CAAC,KAAqB,EAAE,MAAY,EAAE,IAA6D;oBAClH,OAAO;iBACR;gBACD,CAAC,oBAAoB,CAAC,CAAC,KAAqB,EAAE,MAAiB,EAAE,IAA6D;oBAC5H,OAAO;iBACR;aACF,CAAC;YAEF;AACA,YAAO,MAAM,mBAAmB,GAAG;gBACjC,CAAC,gBAAgB,CAAC,CAAC,MAAiB,IAAY,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;gBACvE,CAAC,cAAc,CAAC,CAAC,MAA6B,IAAY,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE;gBAC/E,CAAC,cAAc,CAAC,CAAC,MAAoB,IAAY,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE;gBACtE,CAAC,iBAAiB,CAAC,CAAC,MAAc,IAAY,OAAO,MAAM,CAAC,EAAE;gBAC9D,CAAC,eAAe,CAAC,CAAC,MAAY,IAAY,OAAO,CAAC,CAAC,EAAE;gBACrD,CAAC,oBAAoB,CAAC,CAAC,MAAiB,IAAY,OAAO,CAAC,CAAC,EAAE;aAChE,CAAC;;YCrxCF;;;;;;;;AAQA,gBAAY,WAMX;YAND,WAAY,WAAW;gBACrB,mDAAiB,CAAA;gBACjB,iDAAiB,CAAA;gBACjB,qDAAiB,CAAA;gBACjB,iDAAiB,CAAA;gBACjB,mDAAiB,CAAA;YACnB,CAAC,EANW,WAAW,KAAX,WAAW,gCAMtB;AAED,gBAAkB,eAkBjB;YAlBD,WAAkB,eAAe;;;;;;;;gBAQ/B,qEAAmB,CAAA;;;;;;;;;gBASnB,2DAAmB,CAAA;YACrB,CAAC,EAlBiB,eAAe,KAAf,eAAe,oCAkBhC;YAED,MAAM,iBAAiB,GAAG,uCAAuD;AAEjF,qBAAgB,mBAAmB,CAAC,QAA4C;gBAC9E,IAAI,CAAC,QAAS,GAAG,iBAAiB,MAAM,CAAC,EAAE;;;oBAGzC,OAAO,QAAS,wBAAgC;iBACjD;gBACD,OAAO,QAAS,CAAC;YACnB,CAAC;AAED,gBAAkB,KA4BjB;YA5BD,WAAkB,KAAK;gBACrB,iCAAmD,CAAA;gBACnD,2CAAmD,CAAA;gBACnD,+CAAmD,CAAA;gBACnD,uCAAmD,CAAA;gBACnD,yDAAmD,CAAA;gBACnD,6DAAmD,CAAA;gBACnD,+CAAmD,CAAA;gBACnD,gDAAmD,CAAA;gBACnD,8CAAmD,CAAA;gBACnD,oEAAmD,CAAA;gBACnD,oEAAmD,CAAA;gBACnD,4CAAmD,CAAA;gBACnD,2CAAmD,CAAA;gBACnD,6CAAmD,CAAA;gBACnD,iDAAmD,CAAA;gBACnD,kDAAmD,CAAA;gBACnD,kDAAmD,CAAA;gBACnD,gDAAmD,CAAA;gBACnD,oDAAmD,CAAA;gBACnD,yDAAmD,CAAA;gBACnD,mDAAmD,CAAA;gBACnD,qDAAmD,CAAA;gBACnD,0DAAmD,CAAA;gBACnD,4DAAmD,CAAA;gBACnD,4DAAmD,CAAA;gBACnD,uDAAmD,CAAA;gBACnD,2DAAmD,CAAA;YACrD,CAAC,EA5BiB,KAAK,KAAL,KAAK,0BA4BtB;AAED,gBAAkB,KAajB;YAbD,WAAkB,KAAK;gBACrB,iCAAuC,CAAA;gBACvC,6CAAuC,CAAA;gBACvC,6CAAuC,CAAA;gBACvC,yCAAuC,CAAA;gBACvC,kDAAuC,CAAA;gBACvC,gDAAuC,CAAA;gBACvC,kDAAuC,CAAA;gBACvC,iDAAuC,CAAA;gBACvC,mDAAuC,CAAA;gBACvC,+CAAuC,CAAA;gBACvC,8CAAuC,CAAA;gBACvC,gDAAuC,CAAA;YACzC,CAAC,EAbiB,KAAK,KAAL,KAAK,0BAatB;AAED,gBAAkB,cAuCjB;YAvCD,WAAkB,cAAc;gBAC9B,mDAAgE,CAAA;;;gBAGhE,+FAAgE,CAAA;gBAChE,qGAAgE,CAAA;gBAChE,0EAAgE,CAAA;gBAChE,mFAAgE,CAAA;gBAChE,qEAAgE,CAAA;gBAChE,wDAAgE,CAAA;gBAChE,oFAAgE,CAAA;gBAChE,wFAAgE,CAAA;gBAChE,wDAAgE,CAAA;gBAChE,+DAAgE,CAAA;gBAChE,wEAAgE,CAAA;gBAChE,uEAAgE,CAAA;gBAChE,6DAAgE,CAAA;gBAChE,+DAAgE,CAAA;gBAChE,wEAAgE,CAAA;gBAChE,sEAAgE,CAAA;gBAChE,8DAAgE,CAAA;gBAChE,kEAAgE,CAAA;gBAChE,mEAAgE,CAAA;gBAChE,mEAAgE,CAAA;gBAChE,iEAAgE,CAAA;gBAChE,wEAAgE,CAAA;gBAChE,kFAAgE,CAAA;gBAChE,0FAAgE,CAAA;gBAChE,yEAAgE,CAAA;gBAChE,yEAAgE,CAAA;gBAChE,uFAAgE,CAAA;;;gBAGhE,6EAAgE,CAAA;gBAChE,gGAAgE,CAAA;gBAChE,gFAAgE,CAAA;gBAChE,0FAAgE,CAAA;gBAChE,6FAAgE,CAAA;gBAChE,2EAAgE,CAAA;YAClE,CAAC,EAvCiB,cAAc,KAAd,cAAc,mCAuC/B;AAED,gBAAkB,cAuCjB;YAvCD,WAAkB,cAAc;gBAC9B,4DAA2C,CAAA;gBAC3C,4DAA2C,CAAA;gBAC3C,uEAA2C,CAAA;gBAC3C,mEAA2C,CAAA;gBAC3C,+DAA2C,CAAA;gBAC3C,0EAA2C,CAAA;gBAC3C,4DAA2C,CAAA;gBAC3C,gEAA2C,CAAA;gBAC3C,sEAA2C,CAAA;gBAC3C,iEAA2C,CAAA;gBAC3C,mEAA2C,CAAA;gBAC3C,+EAA2C,CAAA;gBAC3C,oDAA2C,CAAA;;gBAE3C,kEAA2C,CAAA;gBAC3C,qEAA2C,CAAA;gBAC3C,uEAA2C,CAAA;gBAC3C,yEAA2C,CAAA;gBAC3C,+EAA2C,CAAA;gBAC3C,+DAA2C,CAAA;gBAC3C,sDAA2C,CAAA;gBAC3C,gEAA2C,CAAA;gBAC3C,kEAA2C,CAAA;gBAC3C,sEAA2C,CAAA;gBAC3C,sEAA2C,CAAA;gBAC3C,oEAA2C,CAAA;gBAC3C,0EAA2C,CAAA;gBAC3C,wDAA2C,CAAA;gBAC3C,kEAA2C,CAAA;gBAC3C,0DAA2C,CAAA;gBAC3C,2EAA2C,CAAA;gBAC3C,6EAA2C,CAAA;gBAC3C,kEAA2C,CAAA;gBAC3C,qFAA2C,CAAA;gBAC3C,uFAA2C,CAAA;gBAC3C,iFAA2C,CAAA;gBAC3C,0EAA2C,CAAA;gBAC3C,sEAA2C,CAAA;YAC7C,CAAC,EAvCiB,cAAc,KAAd,cAAc,mCAuC/B;;gBC1HiB,aAIjB;YAJD,WAAkB,aAAa;gBAC7B,mEAAa,CAAA;gBACb,uEAAe,CAAA;gBACf,2DAAS,CAAA;YACX,CAAC,EAJiB,aAAa,KAAb,aAAa,kCAI9B;AAqED,kBAAa,WAAW,0BAAG,EAAE,CAAC,eAAe,CAAc,aAAa,CAAC,CAAC,SAAS,EAAE,EAAC;AAsBtF,kBAAa,YAAY,2BAAG,EAAE,CAAC,eAAe,CAAe,cAAc,CAAC,CAAC,SAAS,EAAE,EAAC;YAwDzF,MAAM,cAAc;gBAWlB,IAAW,KAAK;oBACd,IAAI,GAAG,GAAmB,IAAI,CAAC;oBAC/B,OAAO,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,EAAE;wBACjE,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC;qBAChB;oBACD,OAAO,GAAG,CAAC;iBACZ;gBAED,IAAW,IAAI;oBACb,IAAI,GAAG,GAAmB,IAAI,CAAC;oBAC/B,OAAO,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,EAAE;wBACjE,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC;qBAChB;oBACD,OAAO,GAAG,CAAC;iBACZ;gBAED,YACE,EAAqD,EACrD,UAAmB,KAAK,CAAC,EACzB,+BACA,OAAgB,KAAK;oBAErB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;oBACb,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;oBACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBAEjB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBAEnB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;iBACvB;gBAEM,MAAM,CAAC,EAAoD,EAAE,OAAiB;oBACnF,OAAO,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,CAAC;iBACnD;gBAEM,IAAI,CAAC,KAAqB;oBAC/B,IAAI,IAAI,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE;wBACtB,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,EAAE;4BAC3B,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;yBACnC;6BAAM;4BACL,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;yBAChB;qBACF;oBAED,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;qBAC1B;yBAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACxB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;wBACvB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAEnB,OAAO,IAAI,CAAC;qBACb;yBAAM;wBACL,OAAO,IAAI,CAAC,IAAI,CAAC;qBAClB;iBACF;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE;wBAC9D,OAAO;qBACR;oBAED,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;oBAE7B,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;oBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;oBAE3B,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;oBACtB,IAAI,SAAS,KAAK,KAAK,CAAC,EAAE;wBACxB,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC;qBACvB;oBAED,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAClB,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;oBAElB,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC;oBACzB,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC;qBAC1B;iBACF;gBAEM,IAAI,CAAC,IAAoB;oBAC9B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBAEjB,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;qBACvB;oBAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,MAAM,CAAC,aAAsB,KAAK;oBACvC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC,CAAC;oBACjB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;oBAEtB,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;qBAC5B;oBAED,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;qBAC5B;oBAED,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBAEnB,IAAI,UAAU,EAAE;wBACd,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBACnB,OAAO,IAAI,CAAC;qBACb;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;aACF;AAED,gBAAkB,QASjB;YATD,WAAkB,QAAQ;gBACxB,iDAAkB,CAAA;gBAClB,2CAAkB,CAAA;gBAClB,2CAAkB,CAAA;gBAClB,+CAAkB,CAAA;gBAClB,+CAAkB,CAAA;gBAClB,qDAAkB,CAAA;gBAClB,gDAAkB,CAAA;gBAClB,wCAAkB,CAAA;YACpB,CAAC,EATiB,QAAQ,KAAR,QAAQ,6BASzB;AAED,kBAAa,UAAU,yBAAG,EAAE,CAAC,eAAe,CAAa,YAAY,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,EAAC;YAEhH,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;AAe1B,kBAAa,UAAU;gBAQrB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;oBAEf,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,KAAK;oBACV,EAAE,IAAI,CAAC,KAAK,CAAC;iBACd;gBAEM,GAAG,CAAC,KAAsB;oBAC/B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,KAAK,gBAAuB;qBAC7B;oBACD,IAAI,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;gBAEM,MAAM,CAAC,EAAc,EAAE,KAAsB;oBAClD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,EAAE,EAAE,CAAC;oBACL,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEjC,IAAI,CAAC,IAAK,CAAC,SAAS,GAAG,UAAU,CAAC;qBACnC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,6BAAuB;iBACxC;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;wBACnC,UAAU,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvD;oBACD,IAAI,UAAU,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;wBACnC,UAAU,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvD;oBACD,UAAU,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBAC9B,UAAU,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBAC9B,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,SAAS,CAAC;qBAClC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,SAAS,CAAC;qBAClC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,wDAA4C;iBACjF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,wDAA4C;4BAClE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;4BACjB,IAAI,GAAG,GAAG,CAAC,SAAS,CAAC;4BACrB,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;4BACvB,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;;4BAEvB,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,YAAY;gBAQvB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;oBAEf,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,KAAK;oBACV,EAAE,IAAI,CAAC,KAAK,CAAC;iBACd;gBAEM,GAAG,CAAC,KAAsB;oBAC/B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,KAAK,gBAAuB;qBAC7B;oBACD,IAAI,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;gBAEM,MAAM,CAAC,EAAc,EAAE,KAAsB;oBAClD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,EAAE,EAAE,CAAC;oBACL,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEnC,IAAI,CAAC,IAAK,CAAC,WAAW,GAAG,UAAU,CAAC;qBACrC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,gCAAyB;iBAC1C;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,WAAW,KAAK,KAAK,CAAC,EAAE;wBACrC,UAAU,CAAC,WAAW,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;qBAC7D;oBACD,IAAI,UAAU,CAAC,WAAW,KAAK,KAAK,CAAC,EAAE;wBACrC,UAAU,CAAC,WAAW,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;qBAC7D;oBACD,UAAU,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAChC,UAAU,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,WAAW,CAAC;qBACpC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,WAAW,CAAC;qBACpC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,8DAAgD;iBACrF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,8DAAgD;4BACtE,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;4BACnB,IAAI,GAAG,GAAG,CAAC,WAAW,CAAC;4BACvB,GAAG,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;4BACzB,GAAG,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;;4BAEzB,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,aAAa;gBAQxB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;oBAEf,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,KAAK;oBACV,EAAE,IAAI,CAAC,KAAK,CAAC;iBACd;gBAEM,GAAG,CAAC,KAAsB;oBAC/B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,KAAK,gBAAuB;qBAC7B;oBACD,IAAI,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;;wBAEtB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACpC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;gBAEM,MAAM,CAAC,EAAc,EAAE,KAAsB;oBAClD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,EAAE,EAAE,CAAC;oBACL,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEpC,IAAI,CAAC,IAAK,CAAC,YAAY,GAAG,UAAU,CAAC;qBACtC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,iCAA0B;iBAC3C;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;wBACtC,UAAU,CAAC,YAAY,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;qBAChE;oBACD,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;wBACtC,UAAU,CAAC,YAAY,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;qBAChE;oBACD,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBACjC,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBACjC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,YAAY,CAAC;qBACrC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,YAAY,CAAC;qBACrC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,gEAAkD;iBACvF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,gEAAkD;4BACxE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;4BACpB,IAAI,GAAG,GAAG,CAAC,YAAY,CAAC;4BACxB,GAAG,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;4BAC1B,GAAG,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;;4BAE1B,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,aAAa;gBAQxB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;oBAEf,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,KAAK;oBACV,EAAE,IAAI,CAAC,KAAK,CAAC;iBACd;gBAEM,GAAG,CAAC,KAAsB;oBAC/B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,KAAK,gBAAuB;qBAC7B;oBACD,IAAI,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;;wBAEtB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACtC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;gBAEM,MAAM,CAAC,EAAc,EAAE,KAAsB;oBAClD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,EAAE,EAAE,CAAC;oBACL,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEpC,IAAI,CAAC,IAAK,CAAC,YAAY,GAAG,UAAU,CAAC;qBACtC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,iCAA0B;iBAC3C;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;wBACtC,UAAU,CAAC,YAAY,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;qBAChE;oBACD,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;wBACtC,UAAU,CAAC,YAAY,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;qBAChE;oBACD,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBACjC,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBACjC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,YAAY,CAAC;qBACrC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,YAAY,CAAC;qBACrC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,gEAAkD;iBACvF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,gEAAkD;4BACxE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;4BACpB,IAAI,GAAG,GAAG,CAAC,YAAY,CAAC;4BACxB,GAAG,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;4BAC1B,GAAG,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;;4BAE1B,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,UAAU;gBAMrB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,CAAC,UAAU,CAAC,KAAK,mCAA2B,CAAC,EAAE;wBACjD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;wBAC1C,OAAO,CAAC,GAAG,CAAC,qDAAqD,EAAE,IAAI,CAAC,CAAC;wBACzE,OAAO;qBACR;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEjC,IAAI,CAAC,IAAK,CAAC,SAAS,GAAG,UAAU,CAAC;qBACnC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,+BAAuB;iBACxC;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;wBACnC,UAAU,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvD;oBACD,IAAI,UAAU,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;wBACnC,UAAU,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvD;oBACD,UAAU,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBAC9B,UAAU,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBAC9B,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,SAAS,CAAC;qBAClC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,SAAS,CAAC;qBAClC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,4DAA4C;iBACjF;gBAEM,OAAO,CAAC,KAAqB;oBAElC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,4DAA4C;4BAElE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;4BACjB,IAAI,GAAG,GAAG,CAAC,SAAS,CAAC;4BACrB,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;4BACvB,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;;4BAEvB,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,YAAY;gBAMvB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBACnB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,GAAG,CAAC,UAAuB;oBAChC,IAAI,CAAC,UAAU,CAAC,KAAK,iCAAyB,CAAC,EAAE;wBAC/C,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;wBACxC,OAAO;qBACR;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;qBACxB;yBAAM;wBACL,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;;wBAEnC,IAAI,CAAC,IAAK,CAAC,WAAW,GAAG,UAAU,CAAC;qBACrC;oBACD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;oBACvB,UAAU,CAAC,KAAK,iCAAyB;iBAC1C;gBAEM,MAAM,CAAC,UAAuB;oBACnC,IAAI,UAAU,CAAC,WAAW,KAAK,KAAK,CAAC,EAAE;wBACrC,UAAU,CAAC,WAAW,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;qBAC7D;oBACD,IAAI,UAAU,CAAC,WAAW,KAAK,KAAK,CAAC,EAAE;wBACrC,UAAU,CAAC,WAAW,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;qBAC7D;oBACD,UAAU,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAChC,UAAU,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,WAAW,CAAC;qBACpC;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,WAAW,CAAC;qBACpC;oBACD,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,gEAAgD;iBACrF;gBAEM,OAAO,CAAC,KAAqB;oBAElC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBAC3B,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAC/B,IAAI,IAA6B,CAAC;wBAClC,GAAG;4BACD,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,gEAAgD;4BAEtE,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;4BACnB,IAAI,GAAG,GAAG,CAAC,WAAW,CAAC;4BACvB,GAAG,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;4BACzB,GAAG,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;;4BAEzB,GAAG,GAAG,IAAK,CAAC;yBACb,QAAQ,GAAG,KAAK,KAAK,CAAC,EAAE;qBAC1B;iBACF;aACF;AAED,kBAAa,UAAU;gBAMrB,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;oBAChB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;iBAChB;gBAEM,KAAK;oBACV,EAAE,IAAI,CAAC,KAAK,CAAC;iBACd;gBAEM,GAAG,CAAC,KAAsB;oBAC/B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,KAAK,gBAAuB;qBAC7B;oBACD,IAAI,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;gBAEM,MAAM,CAAC,EAAc,EAAE,KAAsB;oBAClD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,EAAE,EAAE,CAAC;oBACL,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjB;gBAEM,GAAG,CAAC,SAAqB;oBAC9B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAC5B;gBAEM,MAAM,CAAC,SAAqB;oBACjC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;oBAC5C,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;wBACd,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;qBAC7B;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,KAAK,wBAA6B;oBAClC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;wBACjC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;wBAChB,MAAM,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;wBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;4BAC/B,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;yBAC5B;qBACF;iBACF;aACF;AAED,kBAAa,SAAS;gBAwBpB,IAAW,GAAG;oBACZ,OAAO,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC;iBACtC;gBAED,IAAW,MAAM;oBACf,OAAO,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC;iBACrC;gBAED,IAAW,MAAM,CAAC,GAAW;oBAC3B,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;iBACvE;gBAED,IAAW,MAAM;oBACf,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,EAAE;wBAC7B,OAAO,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC;qBACrC;oBACD,OAAO,EAAE,CAAC;iBACX;gBAED,IAAW,MAAM,CAAC,GAAW;oBAC3B,IAAI,GAAG,IAAI,EAAE,EAAE;wBACb,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;qBAC3B;yBAAM;wBACL,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;qBACvE;iBACF;gBAaD;oBACE,IAAI,CAAC,OAAO,GAAG,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,QAAQ,CAAC,CAAC;oBAC5D,IAAI,CAAC,OAAO,IAAI,KAAK,CAAC,CAAE,CAAC;oBAEzB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;oBAErB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;oBAC3B,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBAEvB,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;oBAElC,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;oBAClC,IAAI,CAAC,OAAO,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;oBAEtC,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;oBAClC,IAAI,CAAC,OAAO,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;oBAEtC,IAAI,CAAC,QAAQ,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,CAAC;oBACxC,IAAI,CAAC,QAAQ,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,CAAC;oBAExC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;oBAC1B,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC;oBAClC,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;;oBAG3B,IAAI,CAAC,SAAS,GAAG,IAAI,OAAO,CAAC,OAAO;wBAClC,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;qBACjC,CAAC,CAAC;oBAEH,IAAI,CAAC,IAAI,GAAG,CAAC,SAAiB;wBAC5B,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;wBACvB,IAAI,IAAI,CAAC,SAAS,EAAE;4BAClB,IAAI,CAAC,eAAe,sBAA2B,SAAS,CAAC,CAAC;4BAC1D,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;gCAC9E,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;6BAC/D;4BACD,IAAI,EAAE,IAAI,CAAC,WAAW,GAAG,CAAC,EAAE;gCAC1B,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;;gCAEjC,IAAI,CAAC,SAAS,GAAG,IAAI,OAAO,CAAC,OAAO;oCAClC,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;iCACjC,CAAC,CAAC;6BACJ;yBACF;qBACF,CAAC;oBAEF,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;oBACxB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;oBAChC,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBACjC,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;iBAC9B;gBAEM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,OAAO,YAAY,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACrE;gBAEM,YAAY;oBACjB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;wBACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;4BAC5D,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;4BACnC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAC/D;qBACF;yBAAM,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACnE,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;wBACnC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBAC/D;iBACF;gBAEM,WAAW;oBAChB,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;wBACvB,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,EAAE;4BAC5B,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;4BACjD,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;yBACxB;qBACF;yBAAM,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,EAAE;wBACnC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;wBACjD,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;qBACxB;iBACF;gBAIM,UAAU,CACf,EAAoD,EACpD,UAAmB,KAAK,CAAC,EACzB,+BACA,OAAgB,KAAK;oBAErB,MAAM,IAAI,GAAG,IAAI,cAAc,CAAC,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;oBAE7D,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;oBACxB,IAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;oBACxB,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;wBACtB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBACjB;yBAAM;wBACL,GAAG;4BACD,IAAI,QAAQ,GAAG,OAAO,CAAC,QAAQ,KAAK,QAAQ,KAAK,OAAO,CAAC,QAAQ,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gCAC3F,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gCAChB,MAAM;6BACP;4BAED,IAAI,GAAG,OAAO,CAAC;4BACf,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;yBACxB,QAAQ,OAAO,KAAK,KAAK,CAAC,EAAE;wBAE7B,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;4BACxB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBACjB;qBACF;oBAED,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;qBACrB;oBAED,IAAI,CAAC,YAAY,EAAE,CAAC;iBACrB;gBAIM,UAAU,CACf,EAAoD,EACpD,UAAmB,KAAK,CAAC;oBAEzB,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;oBAChC,OAAO,OAAO,KAAK,KAAK,CAAC,EAAE;wBACzB,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE;4BAC/B,OAAO,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;yBAC5B;6BAAM;4BACL,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;yBACxB;qBACF;iBACF;gBAEM,eAAe,CAAC,KAAqB,EAAE,YAAoB,QAAQ,CAAC,GAAG,EAAE;oBAC9E,IAAI,IAAI,CAAC,aAAa,EAAE;wBACtB,OAAO;qBACR;oBAED,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;oBAE1B,IAAI,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE;wBACjC,MAAM,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,GAAG,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC;wBACjF,IAAI,iBAAiB,GAAG,CAAC,GAAG,IAAI,CAAC,gBAAgB,EAAE;4BACjD,OAAO;yBACR;wBAED,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,IAAI,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,EAAE;;4BAEzD,IAAI,CAAC,mBAAmB,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;yBACtH;6BAAM;4BACL,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;yBAC9B;wBAED,MAAM,WAAW,GAAG,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC,CAAC;wBACzF,MAAM,cAAc,GAAG,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;wBAChG,MAAM,YAAY,GAAG,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,GAAG,EAAE,EAAE,EAAE,CAAC,CAAC;wBAChG,KAAK,uBAA4B;wBACjC,GAAG;4BACD,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;4BAExB,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;4BAChC,OAAO,OAAO,KAAK,KAAK,CAAC,EAAE;;gCAEzB,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE;oCACd,CAAC,GAAG,CAAC,CAAC;oCACN,IAAI,IAAI,CAAC,kBAAkB,EAAE;wCAC3B,MAAM,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;wCAC7B,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;wCAC3B,IAAI,QAAQ,oBAAkB;4CAC5B,IAAI,GAAG,IAAI,WAAW,EAAE;gDACtB,OAAO,CAAC,MAAM,EAAE,CAAC;gDACjB,IAAI,OAAO,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;oDACzD,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;iDAC7B;qDAAM;oDACL,MAAM;iDACP;6CACF;yCACF;6CAAM,IAAI,QAAQ,qBAAkB;4CACnC,IAAI,GAAG,IAAI,cAAc,EAAE;gDACzB,OAAO,CAAC,MAAM,EAAE,CAAC;gDACjB,IAAI,OAAO,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;oDACzD,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;iDAC7B;qDAAM;oDACL,MAAM;iDACP;6CACF;yCACF;6CAAM;4CACL,IAAI,GAAG,IAAI,YAAY,EAAE;gDACvB,OAAO,CAAC,MAAM,EAAE,CAAC;gDACjB,IAAI,OAAO,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;oDACzD,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;iDAC7B;qDAAM;oDACL,MAAM;iDACP;6CACF;yCACF;qCACF;iCACF;gCAED,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;6BAC/B;yBACF,QAAQ,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;wBAElC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;4BAChC,IAAI,CAAC,WAAW,EAAE,CAAC;yBACpB;qBACF;oBAED,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;oBAC9B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;iBAC5B;gBAEM,iBAAiB,CAAC,WAAoB,IAAI;oBAC/C,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;oBAC/B,IAAI,CAAC,mBAAmB,GAAG,QAAQ,KAAK,IAAI,CAAC;iBAC9C;gBAEM,kBAAkB;oBACvB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;iBACjC;aACF;;YCxoCD;YAEA,MAAML,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;YAEpC,MAAM,SAAS,GAAa,EAAE,CAAC;YAC/B,MAAM,gBAAgB,GAAa,EAAE,CAAC;YACtC,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;YAClB,SAAS,qBAAqB,CAAC,WAAmB;gBAChD,IAAI,WAAW,KAAK,QAAQ,EAAE;oBAC5B,QAAQ,IAAI,CAAC,CAAC;oBACd,MAAM,EAAE,GAAG,SAAS,CAAC,MAAM,GAAG,gBAAgB,CAAC,MAAM,GAAG,QAAQ,GAAG,CAAC,CAAC;oBACrE,KAAK,IAAI,CAAC,GAAG,WAAW,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACzC,SAAS,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,EAAE,CAAC;wBAC/B,gBAAgB,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,EAAE,CAAC;qBAC9C;iBACF;YACH,CAAC;YACD,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC;YAc1B;AACA,qBAAgB,WAAW,CAEzB,QAAkD;;gBAGlD,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,IAAI,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC;gBAC1E,IAAI,CAAC,GAAG,aAAa,CAAC;gBAEtB,OAAO,CAAC,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ;oBAAC,CAAC;;gBAG/C,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;oBACZ,CAAC,GAAG,CAAC,CAAC;oBACN,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;wBACzB,CAAC,EAAE,CAAC;qBACL;oBACD,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;oBAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBACzB,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,kCAAwC;;oBAEzD,IAAI,CAAC,KAAK,aAAa,EAAE;wBACvB,IAAI,CAAC,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;qBAC5B;iBACF;;gBAED,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,EAAE;oBACxB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;iBAClB;gBACD,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;gBACzC,qBAAqB,CAAC,CAAC,CAAC,CAAC;YAC3B,CAAC;YAED;AACA,qBAAgB,eAAe,CAA4B,KAAqB,EAAE,GAAe,EAAE,YAAoB;gBACrH,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,EAAE,iBAAiB,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;iBAAE;gBACzG,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,CAA2B,CAAC;;;;;;;;gBAQtG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC3B,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;iBAAE;YACzC,CAAC;YAED;AACA,qBAAgB,SAAS,CAAyD,GAAa;gBAC7F,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;gBACjC,IAAI,QAAgB,CAAC;gBACrB,IAAI,QAA4D,CAAC;gBACjE,IAAI,GAAG,KAAK,IAAI,EAAE;oBAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;wBAC9B,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;wBACxB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAuD,CAAC;wBAChF,IAAI,QAAQ,IAAI,IAAI,EAAE;4BACpB,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,CAAC;4BACxB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;4BAC3B,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,+BAAqC;yBAC3D;qBACF;iBACF;qBAAM;oBACL,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;wBAC9B,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;4BACzC,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;4BACxB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAuD,CAAC;4BAChF,IAAI,QAAQ,IAAI,IAAI,EAAE;gCACpB,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,CAAC;gCACxB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gCAC3B,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,+BAAqC;6BAC3D;yBACF;qBACF;iBACF;YACH,CAAC;YAKD,SAAS,oBAAoB,CAAiB,MAA8C;gBAC1F,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;gBAC/B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,iBAAiB,CAAC;oBAAE,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;gBACtF,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,WAAW,CAAC;oBAAE,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;gBACpE,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,aAAa,CAAC;oBAAE,KAAK,CAAC,WAAW,GAAG,WAAW,CAAC;gBAC1E,OAAO,MAA8C,CAAC;YACxD,CAAC;AAID,qBAAgB,WAAW,CAAiB,MAA+C;gBACzF,OAAO,MAAM,IAAI,IAAI,GAAG,oBAAoB,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAC9E,CAAC;YAED,IAAI,KAAK,GAAG,CAAC,CAAC;YAEd,WAAW,CAAC,UAAU,GAAG,CAAC,QAA6B;gBACrD,QAAQ,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC;YACxB,CAAC,CAAC;;YClHF,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;YAEpC;YACA,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,WAAW,CAAC;YAElD;YACA,MAAM,eAAe,GAAG,MAAM,GAAG,OAAO,CAAC;AAKzC,gBAAa,OAAO,sBAApB,MAAa,OAAO;gBAiBlB,YACE,gBAAqD,EACrD,MAAmB,EACnB,cAAsB,EACtB,IAAiB,EACjB,eAAiC,EACjC,OAAwB;oBAExB,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAC7B,IAAI,CAAC,MAAM,gBAAc;oBACzB,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC1C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAErB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBACzC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;oBACrC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC;oBAC7B,IAAI,CAAC,eAAe,gBAAuB;iBAC5C;gBAEM,YAAY,CAAC,KAAc,EAAE,KAAqB;oBACvD,KAAK,IAAI,IAAI,CAAC,eAAe,CAAC;oBAC9B,IAAI,CAAC,cAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;iBAC7C;gBAEM,YAAY,CAAC,KAAc,EAAE,KAAqB;oBACvD,KAAK,IAAI,IAAI,CAAC,eAAe,CAAC;oBAC9B,IAAI,CAAC,gBAAgB,CAAC,MAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;iBACzE;gBAEM,YAAY,CAAC,QAAiB,EAAE,cAAuB,EAAE,KAAqB;oBACnF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACvF,IAAI,CAAC,IAAI,CAAC,MAAM,wBAAsB,CAAC,EAAE;wBACvC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;oBAED,KAAK,IAAI,IAAI,CAAC,eAAe,CAAC;oBAE9B,IAAI,CAAC,KAAK,oCAA0C,CAAC,EAAE;wBACrD,MAAM,aAAa,GAAG,IAAI,CAAC,cAAe,CAAC,QAAQ,EAAE,CAAC;;wBAEtD,IAAI,IAAI,CAAC,gBAAgB,CAAC,KAAK,gCAAmC,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE;4BACxF,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;yBAC9E;wBACD,IAAI,QAAQ,KAAK,aAAa,EAAE;4BAC9B,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;yBACpC;wBACD,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,OAAO,MAAM,CAAC,EAAE;4BAC/B,IAAI,CAAC,OAAO,EAAE,CAAC;4BACf,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;4BACzD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;yBACvB;wBACD,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;oBAED,IAAI,CAAC,KAAK,sCAA4C,CAAC,EAAE;wBACvD,IAAI,QAAQ,KAAK,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE;4BAClF,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;yBACpC;wBACD,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;oBAED,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;iBACjC;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,OAAO,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAChF,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO;yBACR;wBACD,IAAI,CAAC,OAAO,CAAC,KAAK,uBAA2B,CAAC;qBAC/C;;oBAED,IAAI,CAAC,MAAM,sBAAoB;;;oBAI/B,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;oBAErE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBAEpB,IAAI,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC7C,IAAI,OAAO,CAAC,gBAAgB,CAAC,EAAE;wBAC7B,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC3C;oBAED,IAAI,cAAc,GAAG,IAAI,CAAC,cAAoD,CAAC;oBAC/E,IAAI,CAAC,cAAc,EAAE;wBACnB,IAAI,IAAI,CAAC,IAAI,GAAG,QAAQ,EAAE;4BACxB,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAA2B,CAAC;yBAC5I;6BAAM;4BACL,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAA2B,CAAC;yBAC5I;qBACF;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,OAAO,IAAI,cAAc,CAAC,IAAI,EAAE;wBAC5D,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC5B;;oBAGD,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACzC,IAAI,IAAI,CAAC,IAAI,GAAG,eAAe,EAAE;wBAC/B,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;qBACjF;oBACD,IAAI,IAAI,CAAC,IAAI,GAAG,MAAM,EAAE;wBACtB,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC9C;oBACD,IAAI,IAAI,CAAC,IAAI,GAAG,QAAQ,EAAE;wBACxB,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;wBAC9B,cAAoE,CAAC,IAAI,CAAC,EAAE,CAAC,oCAA0C;qBACzH;;oBAGD,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,SAAS,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAClF,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;;oBAED,IAAI,CAAC,MAAM,wBAAsB;;oBAGjC,IAAI,CAAC,eAAe,gBAAuB;oBAE3C,IAAI,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE;wBACpC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;qBACzD;oBACD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAErB,IAAK,IAAI,CAAC,cAAyC,CAAC,MAAM,EAAE;wBACzD,IAAI,CAAC,cAAyC,CAAC,MAAO,CAAC,KAAK,CAAC,CAAC;qBAChE;oBACD,IAAK,IAAI,CAAC,cAAyC,CAAC,WAAW,EAAE;wBAC9D,IAAI,CAAC,cAAyC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;wBACjE,IAAI,CAAC,cAAqE,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,iCAAuC;qBAChI;oBACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;oBAGrB,IAAI,CAAC,MAAM,IAAI,EAAE,sCAAkC,CAAC;oBACpD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,EAAA;YA7KY,OAAO;gBADnB,WAAW,EAAE;eACD,OAAO,EA6KnB;;YClMD,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAGpC,kBAAa,IAAI;gBAQf,YACE,gBAAmC,EACnC,MAAqC,EACrC,cAAsB,EACtB,eAAiC,EACjC,OAAwB;oBAExB,IAAI,CAAC,MAAM,gBAAc;oBAEzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBACzC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,WAAW,eAAsB,MAAM,EAAE,cAAc,CAAC,CAAC;iBAChG;gBAEM,UAAU,CAAC,IAAY;oBAC5B,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,YAAY,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAClF,MAAM,eAAe,GAAG,IAAI,CAAC,MAAO,CAAC,eAAe,CAAC;oBACrD,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;oBACrC,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,6BAA8B,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;oBAEvG,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE;wBACvB,OAAO,CAAC,cAAc,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;qBAC/C;oBAED,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,MAAM,CAAC;iBACf;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC7E,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO;yBACR;wBAED,IAAI,CAAC,OAAO,CAAC,KAAK,uBAA2B,CAAC;qBAC/C;;oBAED,IAAI,CAAC,MAAM,sBAAoB;oBAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBAEpB,IAAI,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE;wBAClC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAChD;oBAED,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,KAAa,KAAK,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;;oBAG/E,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC/E,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;;oBAED,IAAI,CAAC,MAAM,wBAAsB;oBAEjC,IAAI,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE;wBACpC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;qBACzD;oBAED,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBACrB,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;;oBAG1C,IAAI,CAAC,MAAM,IAAI,EAAE,sCAAkC,CAAC;oBACpD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,eAAe,CAAC,KAAqB,EAAE,GAAW,EAAE,YAAoB;oBAC7E,OAAO;iBACR;gBAEM,YAAY,CAAC,QAAiB,EAAE,aAAsB,EAAE,KAAqB;oBAClF,OAAO;iBACR;aACF;;kBCvFY,iBAAiB,gCAAG,EAAE,CAAC,eAAe,CAAoB,mBAAmB,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,EAAC;YAE5I;AACA,kBAAa,gBAAgB;gBAK3B;oBACE,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC5C,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBACvC,IAAI,CAAC,mBAAmB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iBAChD;gBAKM,KAAK,CAAC,UAAkB,EAAE,WAAwB;oBACvD,QAAQ,WAAW;wBACjB,+BAAgC;4BAC9B,IAAI,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;4BACjD,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;gCACpB,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;6BACxF;4BACD,OAAO,KAAK,CAAC;yBACd;wBACD,2BAA6B;4BAC3B,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;4BACzC,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;gCACpB,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;6BAChF;4BACD,OAAO,KAAK,CAAC;yBACd;wBACD,SAAS;;;4BAGP,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,KAAK,WAAW,IAAI,wEAAiF,CAAC,EAAE;gCACjI,OAAO,gBAAgB,CAAC,MAAM,CAAC;6BAChC;4BACD,IAAI,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;4BAC9C,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;gCACpB,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;6BACrF;4BACD,OAAO,KAAK,CAAC;yBACd;qBACF;iBACF;gBAEM,KAAK,CAAC,WAAiD;oBAC5D,MAAM,EAAE,WAAW,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,GAAG,IAAI,CAAC;oBACpE,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;wBACpC,MAAM,IAAI,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;wBACrC,QAAQ,IAAI,CAAC,KAAK;4BAChB;gCACE,mBAAmB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;gCACvC,MAAM;4BACR;gCACE,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;gCAC/B,MAAM;4BACR;gCACE,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;yBACvC;qBACF;iBACF;gBAKO,SAAS,CAAC,UAAkB,EAAE,WAAwB;oBAC5D,IAAI;wBACF,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;wBACpC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBAC3B,IAAI,OAA6B,CAAC;wBAElC,IAAI,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;4BAC5B,OAAO,GAAG,IAAI,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;yBAC3E;6BAAM;4BACL,OAAO,GAAG,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;yBACrC;wBAED,IAAI,KAAK,GAAG,CAAC,CAAC;wBAEd,OAAO,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE;4BAC3B,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;4BAEjC,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gCAC9B,OAAO,GAAG,IAAI,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;6BACvF;iCAAM;gCACL,OAAO,GAAG,IAAI,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;6BACnD;4BAED,KAAK,EAAE,CAAC;yBACT;wBAED,OAAO,OAAO,CAAC;qBAChB;oBAAC,OAAO,CAAC,EAAE;wBACV,MAAM,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;qBAC5B;iBACF;aACF;AAED,gBAAkB,WA0BjB;YA1BD,WAAkB,WAAW;gBACf,6CAAQ,CAAA;gBACjB,kEAA+B,CAAA;gBAC5B,kDAA4B,CAAA;gBAC5B,2DAA4B,CAAA;gBAC5B,uDAA4B,CAAA;gBAC5B,2DAA4B,CAAA;gBAC5B,oDAA4B,CAAA;gBAC5B,0DAA4B,CAAA;gBAC5B,wDAA4B,CAAA;gBACpC,wEAAoC,CAAA;gBACjC,kEAAiC,CAAA;gBACpC,mFAAoC,CAAA;gBACzB,oDAAyB,CAAA;gBAChC,kEAAgC,CAAA;gBAC/B,gEAA+B,CAAA;gBACjC,oEAAiC,CAAA;gBAC/B,gEAA+B,CAAA;gBAC7B,4DAA6B,CAAA;gBAChC,kEAAgC,CAAA;gBAChC,kEAAgC,CAAA;gBACjC,oEAAiC,CAAA;gBAC7B,6DAA6B,CAAA;gBAChC,kEAAgC,CAAA;gBAC5B,2DAA4B,CAAA;gBAC/B,iEAA+B,CAAA;YACpC,CAAC,EA1BiB,WAAW,KAAX,WAAW,gCA0B5B;;YCtID,MAAM,UAAEM,QAAM,WAAEC,SAAO,EAAE,GAAG,WAAW,CAAC;AAExC,kBAAa,yBAAyB;gBAYpC,YACE,eAAiC,EACjC,aAAuC,EACvC,MAAmB,EACnB,cAAsB,EACtB,IAAiB,EACjB,OAAwB;oBAExB,IAAI,CAAC,MAAM,gBAAc;oBACzB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAErB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;oBACnC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;;;;;oBAMrC,MAAM,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC;oBAC9C,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;oBACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBACpD,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,oBAAoB,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;qBACrI;iBACF;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,OAAO;yBACR;wBACD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;oBACD,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBAEpB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC9C,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAC9B;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,OAAO;qBACR;oBACD,IAAI,CAAC,MAAM,IAAI,iBAAe;oBAC9B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBACrB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC9C,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACzB;iBACF;8EACF;AAKD,gBAAa,oBAAoB,mCAAjC,MAAa,oBAAoB;;gBAiB/B,YACE,gBAA6B,EAC7B,aAAuC,EACvC,MAAmB,EACnB,cAAsB,EACtB,IAAiB,EACjB,eAAiC,EACjC,OAAwB,EACxB,OAAgB;oBAEhB,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAC7B,IAAI,CAAC,MAAM,gBAAc;oBAEzB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;oBACnC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBACzC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;oBAErC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,WAAW,eAAsB,MAAM,EAAE,cAAc,CAAC,CAAC;iBAChG;gBAEM,YAAY,CAAC,KAAc,EAAE,KAAqB;oBACvD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,iCAAuC,CAAC;iBAClF;gBAEM,YAAY,CAAC,SAAkB,EAAE,cAAuB,EAAE,KAAqB;oBACpF,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,OAAO;qBACR;oBAED,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;oBACrD,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;oBAChF,IAAI,QAAQ,KAAK,aAAa,EAAE;wBAC9B,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;qBACpC;oBAED,IAAI,CAAC,IAAI,CAAC,IAAI,GAAGA,SAAO,MAAM,CAAC,EAAE;wBAC/B,IAAI,CAAC,OAAO,EAAE,CAAC;wBACf,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;wBACzD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBACvB;iBACF;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,OAAO;yBACR;wBACD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;oBAED,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBAEpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC/C,IAAI,gBAAgB,CAAC,IAAI,EAAE;wBACzB,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC3C;oBACD,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,OAAO,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE;wBACjE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBACjC;;;oBAID,IAAI,IAAI,CAAC,OAAO,EAAE;wBAChB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;qBACnF;oBACD,IAAI,IAAI,CAAC,IAAI,GAAGD,QAAM,EAAE;wBACtB,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC9C;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,OAAO;qBACR;oBACD,IAAI,CAAC,MAAM,IAAI,iBAAe;oBAE9B,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC/C,IAAI,gBAAgB,CAAC,MAAM,EAAE;wBAC3B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;qBACpD;oBACD,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE;wBAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBACnC;oBAED,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBACrB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;iBACtB;aACF,EAAA;YA9GY,oBAAoB;gBADhC,WAAW,EAAE;eACD,oBAAoB,EA8GhC;;YCtLD,MAAMN,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAKpC,gBAAa,UAAU,yBAAvB,MAAa,UAAU;gBAcrB,YACE,gBAA6B,EAC7B,cAAsB,EACtB,eAAiC,EACjC,OAAwB,EACxB,cAAuB,KAAK;oBAE5B,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAC7B,IAAI,CAAC,MAAM,gBAAc;oBACzB,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC1C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAErB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBACzC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;oBACnB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;oBAErC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;iBAChC;gBAEM,YAAY,CAAC,SAAkB,EAAE,cAAuB,EAAE,KAAqB;oBACpF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC1F,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;oBAED,IAAI,KAAK,kCAAwC;wBAC/C,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,IAAoD,CAAC;wBACxF,MAAM,aAAa,GAAY,MAAM,CAAC,cAAc,CAAC,CAAC;wBACtD,MAAM,QAAQ,GAAY,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;wBAC5F,IAAI,QAAQ,KAAK,aAAa,EAAE;4BAC9B,MAAM,CAAC,cAAc,CAAC,GAAG,QAAQ,CAAC;yBACnC;wBACD,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;oBAED,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;iBACjC;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,OAAO,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACnF,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO;yBACR;wBACD,IAAI,CAAC,OAAO,CAAC,KAAK,uBAA2B,CAAC;qBAC/C;;oBAED,IAAI,CAAC,MAAM,sBAAoB;oBAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBACpB,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,cAAc,GAAG,KAAK,CAAC,eAAe,CAAe,CAAC;oBAE9F,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC/C,IAAI,gBAAgB,CAAC,IAAI,EAAE;wBACzB,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC3C;;oBAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,sBAA0B,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;oBAChH,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;;oBAGlD,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,SAAS,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACrF,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;;oBAED,IAAI,CAAC,MAAM,wBAAsB;oBAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC/C,IAAI,gBAAgB,CAAC,MAAM,EAAE;wBAC3B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;qBACpD;oBACD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBACrB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;oBAGrB,IAAI,CAAC,MAAM,IAAI,EAAE,sCAAkC,CAAC;oBACpD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,EAAA;YAzGY,UAAU;gBADtB,WAAW,EAAE;eACD,UAAU,EAyGtB;;YCnHD,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAGpC,kBAAa,GAAG;gBAQd,YACE,gBAAmC,EACnC,MAAmB,EACnB,OAAwB;oBAExB,IAAI,CAAC,MAAM,gBAAc;oBACzB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAErB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;oBACzC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;iBACtB;gBAEM,KAAK,CAAC,KAAqB,EAAE,KAAa;oBAC/C,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC5E,IAAI,IAAI,CAAC,MAAM,oBAAkB;wBAC/B,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;4BACzB,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO;yBACR;wBAED,IAAI,CAAC,OAAO,CAAC,KAAK,uBAA2B,CAAC;qBAC/C;;oBAED,IAAI,CAAC,MAAM,sBAAoB;oBAE/B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;oBAEpB,IAAI,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE;wBAClC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAChD;oBAED,IAAI,CAAC,gBAAgB,CAAC,MAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;;oBAG7E,IAAI,CAAC,MAAM,oBAAkB;oBAC7B,IAAI,CAAC,MAAM,IAAI,mBAAiB;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC9E,IAAI,EAAE,IAAI,CAAC,MAAM,mBAAiB,EAAE;wBAClC,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO;qBACR;;oBAED,IAAI,CAAC,MAAM,wBAAsB;oBAEjC,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE;wBACrF,IAAI,CAAC,gBAAgB,CAAC,MAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;qBACxE;oBAED,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBAC/C,IAAI,SAAS,CAAC,gBAAgB,CAAC,EAAE;wBAC/B,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,MAAO,EAAE,IAAI,CAAC,CAAC;qBACpD;oBAED,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;;oBAGrB,IAAI,CAAC,MAAM,IAAI,EAAE,sCAAkC,CAAC;oBACpD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,eAAe,CAAC,KAAqB,EAAE,GAAe,EAAE,YAAoB;oBACjF,OAAO;iBACR;gBAEM,YAAY,CAAC,QAAiB,EAAE,aAAsB,EAAE,KAAqB;oBAClF,OAAO;iBACR;aACF;;YCrGD;AACA,YAAA,IAAkB,eAOjB;YAPD,WAAkB,eAAe;gBAC/B,qDAAmB,CAAA;gBACnB,mEAAwB,CAAA;gBACxB,mEAAwB,CAAA;gBACxB,mEAAwB,CAAA;gBACxB,2EAAwB,CAAA;gBACxB,oDAAwB,CAAA;YAC1B,CAAC,EAPiB,eAAe,KAAf,eAAe,QAOhC;AAED,gBAAY,kBAIX;YAJD,WAAY,kBAAkB;gBAC5B,2DAAQ,CAAA;gBACR,qEAAa,CAAA;gBACb,mEAAY,CAAA;YACd,CAAC,EAJW,kBAAkB,KAAlB,kBAAkB,uCAI7B;AA8HD,gBAAkB,cAMjB;YAND,WAAkB,cAAc;gBAC9B,yDAAgB,CAAA;gBAChB,qDAAgB,CAAA;gBAChB,qDAAgB,CAAA;gBAChB,iDAAgB,CAAA;gBAChB,iDAAgB,CAAA;YAClB,CAAC,EANiB,cAAc,KAAd,cAAc,mCAM/B;AAoFD,qBAAgB,YAAY,CAC1B,QAAgD,EAChD,YAAuB;gBAEvB,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;gBAC5B,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAa,CAAC;gBACtC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACV,OAAO,CAAC,GAAG,MAAM,EAAE;oBACjB,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACrB,EAAE,CAAC,CAAC;iBACL;gBACD,IAAI,YAAY,KAAK,KAAK,CAAC,EAAE;oBAC3B,GAAG,CAAC,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBAC1C;qBAAM,IAAI,QAAQ,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;oBAC3C,GAAG,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBACnD;qBAAM;oBACL,GAAG,CAAC,YAAY,GAAG,EAAE,CAAC;iBACvB;gBACD,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC;gBACtB,OAAO,GAAG,CAAC;YACb,CAAC;AAED,qBAAgB,cAAc,CAAC,SAAiB,CAAC;gBAC/C,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAa,CAAC;gBACtC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACV,OAAO,CAAC,GAAG,MAAM,EAAE;oBACjB,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;iBACd;gBACD,GAAG,CAAC,YAAY,GAAG,EAAE,CAAC;gBACtB,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC;gBACtB,OAAO,GAAG,CAAC;YACb,CAAC;AAED,qBAAgB,aAAa,CAAC,QAAkB;gBAC9C,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAc,CAAC;gBAC3C,KAAK,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;gBACnD,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;gBACxB,OAAO,KAAK,CAAC;YACf,CAAC;AAED,qBAAgB,UAAU,CAAC,KAAc;gBACvC,OAAO,KAAK,YAAY,KAAK,IAAK,KAAkB,CAAC,UAAU,KAAK,IAAI,CAAC;YAC3E,CAAC;;gBC7QY,wBAAwB,uCAArC,MAAa,wBAAwB;gBAGnC,YAAY,GAAc;oBACxB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,MAAM,CAAC;iBAChC;gBACM,QAAQ;oBACb,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;iBACxB;gBACM,QAAQ,CAAC,QAAgB,EAAE,KAAqB;oBACrD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC;oBAC9B,IAAI,QAAQ,KAAK,YAAY,EAAE;wBAC7B,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;wBAC7B,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,iCAAuC,CAAC;qBAC3F;iBACF;aACF,EAAA;YAjBY,wBAAwB;gBADpC,oBAAoB,EAAE;eACV,wBAAwB,EAiBpC;;YCXD;YACA,SAAS,WAAW,CAAC,CAAU,EAAE,CAAU;gBACzC,IAAI,CAAC,KAAK,CAAC,EAAE;oBACX,OAAO,CAAC,CAAC;iBACV;gBACD,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAI,CAAQ,CAAC,QAAQ,EAAE,CAAC;gBAC/C,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAI,CAAQ,CAAC,QAAQ,EAAE,CAAC;gBAC/C,OAAQ,CAAQ,GAAI,CAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;YACxC,CAAC;YAED,SAAS,cAAc,CAAC,CAAU,EAAE,CAAU;gBAC5C,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;oBAChB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,CAAC,CAAC;qBACV;yBAAM;wBACL,OAAO,CAAC,CAAC;qBACV;iBACF;gBACD,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;oBAChB,OAAO,CAAC,CAAC,CAAC;iBACX;gBACD,OAAO,CAAC,CAAC;YACX,CAAC;YAED,SAAS,aAAa,CAAC,GAAmB,EAAE,QAAkB,EAAE,IAAY,EAAE,EAAU,EAAE,SAA6C;gBACrI,IAAI,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;gBAC1C,IAAI,CAAC,EAAE,CAAC,CAAC;gBACT,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;oBAC9B,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClB,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACvB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;wBAC9B,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;wBACd,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACnB,KAAK,GAAG,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;wBAClC,IAAI,KAAK,GAAG,CAAC,EAAE;4BACb,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;4BAClB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;yBACxB;6BAAM;4BACL,MAAM;yBACP;qBACF;oBACD,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;oBACtB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;iBAC5B;YACH,CAAC;YAED;YACA,SAAS,SAAS,CAAC,GAAmB,EAAE,QAAkB,EAAE,IAAY,EAAE,EAAU,EAAE,SAA6C;gBACjI,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;gBAC1B,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;gBACf,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;gBACf,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;gBAClB,IAAI,IAAI,EAAE,IAAI,CAAC;gBACf,IAAI,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC;gBACtC,IAAI,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,CAAC;;gBAG3C,OAAO,IAAI,EAAE;oBACX,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,EAAE;wBACnB,aAAa,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,CAAC,CAAC;wBAClD,OAAO;qBACR;;oBAGD,UAAU,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;oBACvC,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;oBAAgB,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;oBACnD,EAAE,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;oBAAc,EAAE,GAAG,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;oBACrD,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;oBAAU,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;oBACzD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;oBACxB,IAAI,GAAG,GAAG,CAAC,EAAE;wBACX,IAAI,GAAG,EAAE,CAAC;wBAAmB,IAAI,GAAG,EAAE,CAAC;wBACvC,EAAE,GAAG,EAAE,CAAC;wBAAqB,EAAE,GAAG,EAAE,CAAC;wBACrC,EAAE,GAAG,IAAI,CAAC;wBAAmB,EAAE,GAAG,IAAI,CAAC;qBACxC;oBACD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;oBACxB,IAAI,GAAG,IAAI,CAAC,EAAE;wBACZ,IAAI,GAAG,EAAE,CAAC;wBAAmB,IAAI,GAAG,EAAE,CAAC;wBACvC,EAAE,GAAG,EAAE,CAAC;wBAAqB,EAAE,GAAG,EAAE,CAAC;wBACrC,EAAE,GAAG,EAAE,CAAC;wBAAqB,EAAE,GAAG,EAAE,CAAC;wBACrC,EAAE,GAAG,IAAI,CAAC;wBAAmB,EAAE,GAAG,IAAI,CAAC;qBACxC;yBAAM;wBACL,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;wBACxB,IAAI,GAAG,GAAG,CAAC,EAAE;4BACX,IAAI,GAAG,EAAE,CAAC;4BAAiB,IAAI,GAAG,EAAE,CAAC;4BACrC,EAAE,GAAG,EAAE,CAAC;4BAAmB,EAAE,GAAG,EAAE,CAAC;4BACnC,EAAE,GAAG,IAAI,CAAC;4BAAiB,EAAE,GAAG,IAAI,CAAC;yBACtC;qBACF;oBACD,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;oBAAgB,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;oBACnD,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;oBAAc,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;oBACrD,MAAM,GAAG,EAAE,CAAC;oBAAmB,MAAM,GAAG,EAAE,CAAC;oBAC3C,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC;oBAClB,SAAS,GAAG,EAAE,GAAG,CAAC,CAAC;oBACnB,GAAG,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;oBAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACvE,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;oBAAU,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;oBAEzD,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;wBAClD,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;wBAAW,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACpD,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;wBACpC,IAAI,KAAK,GAAG,CAAC,EAAE;4BACb,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;4BAAM,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;4BAC1D,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;4BAAI,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;4BACvD,MAAM,EAAE,CAAC;yBACV;6BAAM,IAAI,KAAK,GAAG,CAAC,EAAE;4BACpB,GAAG;gCACD,SAAS,EAAE,CAAC;;gCAEZ,IAAI,SAAS,IAAI,CAAC,EAAE;oCAClB,MAAM,SAAS,CAAC;iCACjB;gCACD,WAAW,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;gCAAC,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;6BACtE,QAAQ,KAAK,GAAG,CAAC,EAAE;4BACpB,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;4BAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;4BAC7D,GAAG,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;4BAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;4BAC1D,IAAI,KAAK,GAAG,CAAC,EAAE;gCACb,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gCAAO,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gCAChD,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;gCAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gCACxD,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;gCAAE,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;gCACrD,MAAM,EAAE,CAAC;6BACV;yBACF;qBACF;;oBAGD,IAAI,EAAE,GAAG,SAAS,GAAG,MAAM,GAAG,IAAI,EAAE;wBAClC,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,EAAE,EAAE,SAAS,CAAC,CAAC;wBACnD,EAAE,GAAG,MAAM,CAAC;qBACb;yBAAM;wBACL,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;wBAClD,IAAI,GAAG,SAAS,CAAC;qBAClB;iBACF;YACH,CAAC;YAED,MAAM,KAAK,GAAG,KAAK,CAAC,SAAiF,CAAC;YAEtG,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;YACzB,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC;YAC/B,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC;YACvB,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;YAC3B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC;YAC7B,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC;YAC/B,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;YAEzB,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;YAC7H,MAAM,OAAO,GAAqE,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;YAEnJ,MAAM,OAAO,GAAG;;gBAEd,IAAI,EAAE;oBACJ,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,SAAmC,CAAC,CAAC;qBAChE;oBACD,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;oBACzB,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;oBAClC,IAAI,QAAQ,KAAK,CAAC,EAAE;wBAClB,OAAO,GAAG,CAAC;qBACZ;oBACD,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,CAAC;oBAClD,IAAI,CAAC,GAAG,GAAG,CAAC;oBACZ,OAAO,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE;wBACvB,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;wBAC9B,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAE,CAAC,CAAC;wBACpB,CAAC,EAAE,CAAC;qBACL;oBACD,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,KAAK,CAAC,MAAM,CAAC;iBACrB;;gBAED,OAAO,EAAE;oBACP,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,SAAmC,CAAC,CAAC;qBACnE;oBACD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;oBAClC,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;oBACpC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO,CAAC,GAAG,QAAQ,EAAE;wBACnB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;qBACpB;oBACD,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;oBACpC,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,SAAmC,CAAC,CAAC;oBACvE,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,GAAG,CAAC;iBACZ;;gBAED,GAAG,EAAE;oBACH,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBACzB;oBACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;oBAC5B,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;;oBAEjC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;oBAClC,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;wBACxB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;qBAC9C;oBACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACpB,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,OAAO,CAAC;iBAChB;;gBAED,KAAK,EAAE;oBACL,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC3B;oBACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;oBAC5B,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;;oBAEnC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;wBACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC1C;oBACD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACtB,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,OAAO,CAAC;iBAChB;;gBAED,MAAM,EAAE,UAA+B,KAAa,EAAE,WAAoB;oBACxE,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,OAAO,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,SAAoD,CAAC,CAAC;qBACnF;oBACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;oBAC5B,IAAI,WAAY,GAAG,CAAC,EAAE;wBACpB,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;wBACjC,MAAM,EAAE,GAAG,CAAC,GAAG,WAAY,CAAC;wBAC5B,OAAO,CAAC,GAAG,EAAE,EAAE;4BACb,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gCACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1C;4BACD,CAAC,EAAE,CAAC;yBACL;qBACF;oBACD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;oBAClC,IAAI,QAAQ,GAAG,CAAC,EAAE;wBAChB,MAAM,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;wBAC/B,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;wBACrC,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,OAAO,CAAC,GAAG,SAAS,EAAE;4BACpB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;yBACpB;wBACD,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAY,EAAE,GAAG,OAAO,CAAC,CAAC;qBACzD;yBAAM,IAAI,QAAQ,KAAK,CAAC,EAAE;wBACzB,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAY,CAAC,CAAC;qBAC7C;oBACD,MAAM,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,SAAoD,CAAC,CAAC;oBAC3F,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,OAAO,CAAC;iBAChB;;gBAED,OAAO,EAAE;oBACP,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACrB,OAAO,IAAI,CAAC;qBACb;oBACD,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;oBACzB,MAAM,MAAM,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC7B,IAAI,KAAK,GAAG,CAAC,CAAC;;oBAEd,OAAO,KAAK,KAAK,MAAM,EAAE;wBACvB,MAAM,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;wBAC9B,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;wBAAE,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;wBACvE,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;wBAAE,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;wBACvE,KAAK,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;wBAAQ,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;wBACjE,KAAK,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;wBAAQ,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;wBACjE,KAAK,EAAE,CAAC;qBACT;;oBAED,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,IAAI,CAAC;iBACb;;;gBAGD,IAAI,EAAE,UAA+B,SAA8C;oBACjF,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;wBAChB,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;wBAC7B,OAAO,IAAI,CAAC;qBACb;oBACD,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;oBACzB,IAAI,GAAG,GAAG,CAAC,EAAE;wBACX,OAAO,IAAI,CAAC;qBACb;oBACD,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC;oBACrD,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO,CAAC,GAAG,GAAG,EAAE;wBACd,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;4BACvB,MAAM;yBACP;wBACD,CAAC,EAAE,CAAC;qBACL;oBACD,IAAI,SAAS,KAAK,KAAK,CAAC,IAAI,OAAO,SAAS,KAAK,UAAU,0DAAyD;wBAClH,SAAS,GAAG,WAAW,CAAC;qBACzB;oBACD,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;oBAC9C,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,IAAI,CAAC;iBACb;aACF,CAAC;YAEF,MAAM,eAAe,GAAG;gBACtB,QAAQ,EAAE,IAAI;gBACd,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACnB,CAAC;YAEF,MAAM,GAAG,GAAG,OAAO,CAAC,cAAc,CAAC;YAEnC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;aAC7G;YAED,IAAI,4BAA4B,GAAG,KAAK,CAAC;AAEzC,qBAAgB,sBAAsB;gBACpC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,eAAe,EAAE,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACpE;iBACF;YACH,CAAC;AAED,qBAAgB,uBAAuB;gBACrC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,eAAe,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACnE;iBACF;YACH,CAAC;YAED,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAKpC,gBAAa,aAAa,4BAA1B,MAAa,aAAa;gBAGxB,YAAY,KAAqB,EAAE,SAAqB,EAAE,KAAqB;oBAC7E,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,eAAe,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAE5F,IAAI,CAAC,4BAA4B,EAAE;wBACjC,4BAA4B,GAAG,IAAI,CAAC;wBACpC,sBAAsB,EAAE,CAAC;qBAC1B;oBAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;oBACrE,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,CAAE,CAAC;oBAEhC,OAAO,CAAC,cAAc,CACpB,KAAK,EACL,WAAW,EACX;wBACE,KAAK,EAAE,IAAI;wBACX,UAAU,EAAE,KAAK;wBACjB,QAAQ,EAAE,IAAI;wBACd,YAAY,EAAE,IAAI;qBACnB,CACF,CAAC;oBAEF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;wBAClC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;4BACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;4BACpB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBAChC;qBACF;yBAAM;wBACL,IAAI,CAAC,UAAU,cAAqB,CAAC;qBACtC;iBACF;gBAEM,iBAAiB;oBACtB,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,GAAG,IAAI,wBAAwB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACrE;oBACD,OAAO,IAAI,CAAC,cAAc,CAAC;iBAC5B;gBAEM,UAAU,CAAC,KAAqB;oBACrC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;oBACtC,MAAM,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC;oBAC9B,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;oBACvC,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE,gCAAsC,IAAI,CAAC,eAAe,CAAC,CAAC;oBACrG,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,gCAAsC,CAAC;qBAC3E;iBACF;aACF,EAAA;YA7DY,aAAa;gBADzB,8BAA8B,EAAE;eACpB,aAAa,EA6DzB;qBAEe,gBAAgB,CAAC,KAAqB,EAAE,SAAqB,EAAE,KAAqB;gBAClG,IAAI,KAAK,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;oBAC9B,KAAK,CAAC,SAAS,GAAG,IAAI,aAAa,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;iBAC9D;gBACD,OAAO,KAAK,CAAC,SAAS,CAAC;YACzB,CAAC;;gBCzbY,sBAAsB,qCAAnC,MAAa,sBAAsB;gBAGjC,YAAY,GAAyC;oBACnD,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,IAAI,CAAC;iBAC9B;gBACM,QAAQ;oBACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;iBACtB;gBACM,QAAQ,CAAC,QAAgB,EAAE,KAAqB;oBACrD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC;oBAC9B,IAAI,QAAQ,KAAK,YAAY,EAAE;wBAC7B,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;wBAC7B,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,iCAAuC,CAAC;qBAC3F;iBACF;aACF,EAAA;YAjBY,sBAAsB;gBADlC,oBAAoB,EAAE;eACV,sBAAsB,EAiBlC;;YCZD,MAAMQ,OAAK,GAAG,GAAG,CAAC,SAAuF,CAAC;YAE1G,MAAM,IAAI,GAAGA,OAAK,CAAC,GAAG,CAAC;YACvB,MAAM,MAAM,GAAGA,OAAK,CAAC,KAAK,CAAC;YAC3B,MAAM,OAAO,GAAGA,OAAK,CAAC,MAAM,CAAC;YAE7B,MAAMC,QAAM,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC;YAC7D,MAAMC,SAAO,GAA+B,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YAEvE;YACA;YAEA,MAAMC,SAAO,GAAG;;gBAEd,GAAG,EAAE,UAA6B,GAAY,EAAE,KAAc;oBAC5D,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;wBAC7B,OAAO,IAAI,CAAC;qBACb;oBACD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC3B,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;oBAC7B,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC3B,IAAI,OAAO,KAAK,OAAO,EAAE;wBACvB,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,OAAO,EAAE,EAAE;4BACnC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gCACpB,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;oCACtB,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;iCACpB;gCACD,OAAO,IAAI,CAAC;6BACb;4BACD,CAAC,EAAE,CAAC;yBACL;wBACD,OAAO,IAAI,CAAC;qBACb;oBACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;oBACzB,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,IAAI,CAAC;iBACb;;gBAED,KAAK,EAAE;oBACL,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC3B;oBACD,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;oBACxB,IAAI,IAAI,GAAG,CAAC,EAAE;wBACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;wBAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE;4BAChC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gCACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1C;4BACD,CAAC,EAAE,CAAC;yBACL;wBACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACnB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;wBACpB,CAAC,CAAC,MAAM,EAAE,CAAC;qBACZ;oBACD,OAAO,SAAS,CAAC;iBAClB;;gBAED,MAAM,EAAE,UAA6B,KAAc;oBACjD,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBACnC;oBACD,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;oBACxB,IAAI,IAAI,KAAK,CAAC,EAAE;wBACd,OAAO,KAAK,CAAC;qBACd;oBACD,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;oBAC5B,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE;wBAChC,IAAI,KAAK,KAAK,KAAK,EAAE;4BACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gCACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1C;4BACD,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;4BACtB,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;yBACnC;wBACD,CAAC,EAAE,CAAC;qBACL;oBACD,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,KAAK,CAAC;iBACd;aACF,CAAC;YAEF,MAAMC,iBAAe,GAAG;gBACtB,QAAQ,EAAE,IAAI;gBACd,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACnB,CAAC;YAEF,MAAMC,KAAG,GAAG,OAAO,CAAC,cAAc,CAAC;YAEnC,KAAK,MAAM,MAAM,IAAIH,SAAO,EAAE;gBAC5BG,KAAG,CAACF,SAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;aAC7G;YAED,IAAI,0BAA0B,GAAG,KAAK,CAAC;AAEvC,qBAAgB,oBAAoB;gBAClC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;oBAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpCK,KAAG,CAACL,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGI,iBAAe,EAAE,KAAK,EAAED,SAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACpE;iBACF;YACH,CAAC;AAED,qBAAgB,qBAAqB;gBACnC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;oBAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpCK,KAAG,CAACL,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGI,iBAAe,EAAE,KAAK,EAAEH,QAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACnE;iBACF;YACH,CAAC;YAED,MAAMT,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAKpC,gBAAa,WAAW,0BAAxB,MAAa,WAAW;gBAGtB,YAAY,KAAqB,EAAE,SAAqB,EAAE,GAAiB;oBACzE,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,aAAa,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAE1F,IAAI,CAAC,0BAA0B,EAAE;wBAC/B,0BAA0B,GAAG,IAAI,CAAC;wBAClC,oBAAoB,EAAE,CAAC;qBACxB;oBAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;oBACtB,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;oBACrE,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBACzC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,CAAE,CAAC;oBAEhC,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;oBAErB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;wBAClC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;4BACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;4BACpB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBAChC;qBACF;yBAAM;wBACL,IAAI,CAAC,UAAU,cAAqB,CAAC;qBACtC;iBACF;gBAEM,iBAAiB;oBACtB,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACnE;oBACD,OAAO,IAAI,CAAC,cAAc,CAAC;iBAC5B;gBAEM,UAAU,CAAC,KAAqB;oBACrC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;oBACtC,MAAM,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC;oBAC5B,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;oBACrC,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE,gCAAsC,IAAI,CAAC,eAAe,CAAC,CAAC;oBACrG,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,gCAAsC,CAAC;qBACzE;iBACF;aACF,EAAA;YApDY,WAAW;gBADvB,8BAA8B,EAAE;eACpB,WAAW,EAoDvB;qBAEe,cAAc,CAAC,KAAqB,EAAE,SAAqB,EAAE,GAAiB;gBAC5F,IAAI,GAAG,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;oBAC5B,GAAG,CAAC,SAAS,GAAG,IAAI,WAAW,CAAC,KAAK,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;iBACxD;gBACD,OAAO,GAAG,CAAC,SAAS,CAAC;YACvB,CAAC;;YCxMD,MAAMQ,OAAK,GAAG,GAAG,CAAC,SAA6E,CAAC;YAEhG,MAAM,IAAI,GAAGA,OAAK,CAAC,GAAG,CAAC;YACvB,MAAMM,QAAM,GAAGN,OAAK,CAAC,KAAK,CAAC;YAC3B,MAAMO,SAAO,GAAGP,OAAK,CAAC,MAAM,CAAC;YAE7B,MAAMC,QAAM,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAEK,QAAM,EAAE,MAAM,EAAEC,SAAO,EAAE,CAAC;YAC7D,MAAML,SAAO,GAA+B,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YAEvE;YACA;YAEA,MAAMC,SAAO,GAAG;;gBAEd,GAAG,EAAE,UAA6B,KAAc;oBAC9C,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBACxB,OAAO,IAAI,CAAC;qBACb;oBACD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC3B,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;oBACxB,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC3B,IAAI,OAAO,KAAK,OAAO,EAAE;wBACvB,OAAO,IAAI,CAAC;qBACb;oBACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;oBACzB,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,IAAI,CAAC;iBACb;;gBAED,KAAK,EAAE;oBACL,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,OAAOG,QAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC3B;oBACD,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;oBACxB,IAAI,IAAI,GAAG,CAAC,EAAE;wBACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;wBAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE;4BAChC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gCACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1C;4BACD,CAAC,EAAE,CAAC;yBACL;wBACDA,QAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACnB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;wBACpB,CAAC,CAAC,MAAM,EAAE,CAAC;qBACZ;oBACD,OAAO,SAAS,CAAC;iBAClB;;gBAED,MAAM,EAAE,UAA6B,KAAc;oBACjD,IAAI,KAAK,GAAG,IAAI,CAAC;oBACjB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;wBAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;qBACpB;oBACD,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAC1B,IAAI,CAAC,KAAK,SAAS,EAAE;wBACnB,OAAOC,SAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBACnC;oBACD,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;oBACxB,IAAI,IAAI,KAAK,CAAC,EAAE;wBACd,OAAO,KAAK,CAAC;qBACd;oBACD,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;oBAC5B,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE;wBAChC,IAAI,KAAK,KAAK,KAAK,EAAE;4BACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gCACpB,QAAQ,CAAC,YAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1C;4BACD,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;4BACtB,OAAOA,SAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;yBACnC;wBACD,CAAC,EAAE,CAAC;qBACL;oBACD,CAAC,CAAC,MAAM,EAAE,CAAC;oBACX,OAAO,KAAK,CAAC;iBACd;aACF,CAAC;YAEF,MAAMH,iBAAe,GAAG;gBACtB,QAAQ,EAAE,IAAI;gBACd,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACnB,CAAC;YAEF,MAAMC,KAAG,GAAG,OAAO,CAAC,cAAc,CAAC;YAEnC,KAAK,MAAM,MAAM,IAAIH,SAAO,EAAE;gBAC5BG,KAAG,CAACF,SAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;aAC7G;YAED,IAAI,0BAA0B,GAAG,KAAK,CAAC;AAEvC,qBAAgB,oBAAoB;gBAClC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;oBAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpCK,KAAG,CAACL,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGI,iBAAe,EAAE,KAAK,EAAED,SAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACpE;iBACF;YACH,CAAC;AAED,qBAAgB,qBAAqB;gBACnC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;oBAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;wBACpCK,KAAG,CAACL,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGI,iBAAe,EAAE,KAAK,EAAEH,QAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;qBACnE;iBACF;YACH,CAAC;YAED,MAAMT,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAKpC,gBAAa,WAAW,0BAAxB,MAAa,WAAW;gBAGtB,YAAY,KAAqB,EAAE,SAAqB,EAAE,WAAyB;oBACjF,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,aAAa,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAE1F,IAAI,CAAC,0BAA0B,EAAE;wBAC/B,0BAA0B,GAAG,IAAI,CAAC;wBAClC,oBAAoB,EAAE,CAAC;qBACxB;oBAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC;oBAC9B,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;oBACrE,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;oBACjD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,CAAE,CAAC;oBAEhC,WAAW,CAAC,SAAS,GAAG,IAAI,CAAC;oBAE7B,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;wBAClC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;4BACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;4BACpB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBAChC;qBACF;yBAAM;wBACL,IAAI,CAAC,UAAU,cAAqB,CAAC;qBACtC;iBACF;gBAEM,iBAAiB;oBACtB,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACnE;oBACD,OAAO,IAAI,CAAC,cAAc,CAAC;iBAC5B;gBAEM,UAAU,CAAC,KAAqB;oBACrC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;oBACtC,MAAM,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC;oBAC5B,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;oBACrC,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE,gCAAsC,IAAI,CAAC,eAAe,CAAC,CAAC;oBACrG,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,gCAAsC,CAAC;qBACzE;iBACF;aACF,EAAA;YApDY,WAAW;gBADvB,8BAA8B,EAAE;eACpB,WAAW,EAoDvB;qBAEe,cAAc,CAAC,KAAqB,EAAE,SAAqB,EAAE,WAAyB;gBACpG,IAAI,WAAW,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;oBACpC,WAAW,CAAC,SAAS,GAAG,IAAI,WAAW,CAAC,KAAK,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;iBACxE;gBACD,OAAO,WAAW,CAAC,SAAS,CAAC;YAC/B,CAAC;;YClLD,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAYpC,qBAAgB,QAAQ,CAAC,MAAyB;gBAChD,OAAO,UAAU,MAAsC,EAAE,GAAW;oBAClE,CAAC,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;iBACtC,CAAC;YACzB,CAAC;YAED,MAAM,wBAAwB,GAAsB,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;YAEvF;AACA,qBAAgB,sBAAsB,CACpC,KAAqB,EACrB,eAAiC,EACjC,YAA2B,EAC3B,SAAqB,EACrB,QAAqE,EACrE,YAAoB,EACpB,UAA8B;gBAE9B,IAAI,UAAU,CAAC,YAAY,KAAK,KAAK,EAAE;oBACrC,OAAO,YAAY,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;iBAC5D;gBAED,IAAI,UAAU,CAAC,GAAG,EAAE;oBAClB,MAAM,SAAS,GAAG,QAAQ,CAAC,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,wBAAwB,CAAC;oBAE3H,IAAI,UAAU,CAAC,GAAG,EAAE;wBAClB,IAAI,SAAS,CAAC,QAAQ,EAAE;4BACtB,OAAO,IAAI,cAAc,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;yBAC7G;wBACD,OAAO,IAAI,oBAAoB,CAAC,QAAQ,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;qBACrE;oBACD,OAAO,IAAI,cAAc,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;iBAC7G;gBACD,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;YACzC,CAAC;YAID;AAEA,gBAAa,oBAAoB,mCAAjC,MAAa,oBAAoB;gBAS/B,YAAY,GAAgB,EAAE,WAAmB,EAAE,UAA8B;oBAC/E,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAC/B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;oBAC9C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;iBACxB;gBAEM,QAAQ,CAAC,QAAiB;oBAC/B,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,UAAU,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;;oBAEhG,IAAI,CAAC,UAAU,CAAC,GAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;oBAC9C,IAAI,IAAI,CAAC,YAAY,KAAK,QAAQ,EAAE;wBAClC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;wBAClC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;wBAC7B,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,gCAAsC,CAAC;qBACpF;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,SAAS,CAAC,UAAuB;oBACtC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;wBACnB,IAAI,CAAC,eAAe,EAAE,CAAC;qBACxB;oBACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;iBAChC;gBAEM,WAAW,CAAC,UAAuB;oBACxC,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;iBACnC;gBAEM,eAAe;oBACpB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,iBAAiB,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACvG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;oBACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBAE/C,MAAM,GAAG,GAAG,CAAC,QAAiB,OAAa,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC;oBACtE,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;oBAC5D,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,EAAA;YAjDY,oBAAoB;gBADhC,oBAAoB,EAAE;eACV,oBAAoB,EAiDhC;YAID;YACA;YACA;AAEA,gBAAa,cAAc,6BAA3B,MAAa,cAAc;gBAczB,YAAY,KAAqB,EAAE,SAA4B,EAAE,GAAgB,EAAE,WAAmB,EAAE,UAA8B,EAAE,eAAiC,EAAE,SAAqB;oBAC9L,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAC/B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;oBAC1B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;oBAE9C,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;oBACvB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;oBACzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;oBACzB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,GAAG,EAAE,iBAAiB,CAAC,KAAK,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC,CAAC;oBAE7E,MAAM,GAAG,GAAG,MAAe,IAAI,CAAC,QAAQ,EAAE,CAAC;oBAC3C,OAAO,CAAC,cAAc,CAAC,GAAG,EAAE,WAAW,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;iBACnD;gBAEM,cAAc,CAAC,YAA2B;oBAC/C,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;wBAClD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;qBACtC;iBACF;gBAEM,gBAAgB,CAAC,YAAqC;oBAC3D,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;wBACpD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;qBACxC;iBACF;gBAEM,QAAQ;oBACb,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,gBAAgB,EAAE,UAAU,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC1F,IAAI,IAAI,CAAC,eAAe,KAAK,CAAC,IAAI,IAAI,CAAC,YAAY,EAAE;;wBAEnD,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,GAAI,EAAE,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;qBAC1F;yBAAM;;wBAEL,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,GAAI,EAAE,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;qBACxF;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,CAAC,YAAY,CAAC;iBAC1B;gBAEM,SAAS,CAAC,UAAuB;oBACtC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;oBAC/B,IAAI,EAAE,IAAI,CAAC,eAAe,KAAK,CAAC,EAAE;wBAChC,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,CAAC;qBAC3C;iBACF;gBAEM,WAAW,CAAC,UAAuB;oBACxC,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;oBAClC,IAAI,EAAE,IAAI,CAAC,eAAe,KAAK,CAAC,EAAE;wBAChC,IAAI,CAAC,0BAA0B,EAAE,CAAC;qBACnC;iBACF;gBAEM,YAAY;oBACjB,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;oBACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,8BAA8B,CAAC,KAAK,CAAC,CAAC;oBAC5D,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,gCAAsC,CAAC;qBAC/E;iBACF;gBAEM,sBAAsB;oBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;oBACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,8BAA8B,CAAC,KAAK,CAAC,CAAC;oBAC5D,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,gCAAsC,CAAC;qBAC/E;iBACF;gBAEM,8BAA8B,CAAC,cAAuB;oBAC3D,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,gBAAgB,EAAE,gCAAgC,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAChH,MAAM,mBAAmB,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,cAAc,CAAC;oBAErE,IAAI,mBAAmB,EAAE;wBACvB,IAAI,CAAC,0BAA0B,EAAE,CAAC;wBAClC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;qBAC1B;oBAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;oBAEpC,IAAI,mBAAmB,EAAE;wBACvB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;wBACvD,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;wBACrE,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;qBAC3B;oBAED,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;oBACvC,OAAO,IAAI,CAAC,YAAY,CAAC;iBAC1B;gBAEM,YAAY,CAAC,GAAgB;oBAClC,OAAO,CAAC,IAAI,CAAC,YAAY,IAAI,GAAG,KAAK,YAAY,CAAC;iBACnD;gBAEO,0BAA0B;oBAChC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;oBACzD,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;oBAC7B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;oBACzE,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;iBAChC;aACF,EAAA;YArHY,cAAc;gBAD1B,oBAAoB,EAAE;eACV,cAAc,EAqH1B;YAED,MAAMgB,aAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;YAE9C,SAAS,iBAAiB,CAAC,KAAqB,EAAE,eAAiC,EAAE,QAAwB;gBAC3G,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,mBAAmB,EAAEhB,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;iBAAE;gBAC7F,MAAM,KAAK,GAAG;oBACZ,GAAG,EAAE,UAAS,MAAc,EAAE,GAAgB,EAAE,QAAkB;wBAChE,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;yBAAE;wBAC/E,IAAI,QAAQ,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;4BAC9B,IAAI,MAAM,CAAC,OAAO,EAAE;gCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;6BAAE;4BACvC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;yBAC3C;;;wBAID,QAAQgB,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC;4BAC9B,KAAK,gBAAgB;gCACnB,QAAQ,CAAC,gBAAgB,CAAC,eAAe,CAAC,gBAAgB,CAAC,KAAK,EAAE,MAAmB,CAAC,CAAC,CAAC;gCACxF,IAAI,GAAG,KAAK,QAAQ,EAAE;oCACpB,IAAI,MAAM,CAAC,OAAO,EAAE;wCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qCAAE;oCACvC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;iCACzC;4BACH,KAAK,cAAc;gCACjB,QAAQ,CAAC,gBAAgB,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,EAAE,MAA+B,CAAC,CAAC,CAAC;gCAClG,IAAI,GAAG,KAAK,MAAM,EAAE;oCAClB,IAAI,MAAM,CAAC,OAAO,EAAE;wCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qCAAE;oCACvC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;iCACzC;4BACH,KAAK,cAAc;gCACjB,QAAQ,CAAC,gBAAgB,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,EAAE,MAAsB,CAAC,CAAC,CAAC;gCACzF,IAAI,GAAG,KAAK,MAAM,EAAE;oCAClB,IAAI,MAAM,CAAC,OAAO,EAAE;wCAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qCAAE;oCACvC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;iCACzC;4BACH;gCACE,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,EAAE,GAAa,CAA2B,CAAC,CAAC;yBAChH;wBAED,IAAI,MAAM,CAAC,OAAO,EAAE;4BAAE,MAAM,CAAC,KAAK,EAAE,CAAC;yBAAE;wBACvC,OAAO,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAC;qBACpE;iBACF,CAAC;gBACF,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;iBAAE;gBACvC,OAAO,KAAK,CAAC;YACf,CAAC;YAED,SAAS,YAAY,CAAC,KAAqB,EAAE,MAAc,EAAE,GAAgB,EAAE,eAAiC,EAAE,QAAwB;gBACxI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;gBAC/C,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;;oBAE/B,OAAQ,MAAsC,CAAC,GAAa,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBAC5E;gBACD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;oBAC/C,OAAO,KAAK,CAAC;iBACd;gBACD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,iBAAiB,CAAC,KAAK,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAC,CAAC;YAC/E,CAAC;;kBC7RY,aAAa,4BAAG,EAAE,CAAC,eAAe,CAAgB,eAAe,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,EAAC;AAE5H,kBAAa,kBAAkB,iCAAG;;;;;;;;;gBAShC,cAAc,EAAE,CAAC;;;;;;;gBAOjB,QAAQ,EAAE,KAAK;;;;;;gBAMf,IAAI,EAAE,IAAI;;;;;;gBAMV,KAAK,EAAE,KAAK;;;;gBAIZ,cAAc;oBACZ,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;oBACxB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;oBACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;iBACpB;aACF,EAAC;YAEF;AACA,kBAAa,YAAY;gBAQvB,YAAmB,SAAqB;oBACtC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;oBACvB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;oBAClB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;iBAC5B;gBAEM,cAAc,CAAC,GAAgB,EAAE,YAAoB;oBAC1D,IAAI,kBAAkB,CAAC,KAAK,EAAE;wBAC5B,MAAM,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;qBACzC;oBACD,IAAI,kBAAkB,CAAC,IAAI,EAAE;wBAC3B,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;qBACnC;oBACD,OAAO,IAAI,kBAAkB,CAAC,IAAI,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACxD;gBAEM,WAAW,CAAC,QAA4B;oBAC7C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAE5B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;wBAC7B,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,iBAAe,CAAC;qBAC3D;iBACF;gBAEM,cAAc,CAAC,QAA4B;oBAChD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;oBACvD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;wBAC7B,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC7C;iBACF;gBAEM,KAAK,CAAC,KAAc;oBACzB,IAAI,kBAAkB,CAAC,QAAQ,EAAE;wBAC/B,OAAO;qBACR;oBACD,IAAI,EAAE,IAAI,CAAC,aAAa,GAAG,kBAAkB,CAAC,cAAc,EAAE;wBAC5D,OAAO;qBACR;oBACD,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;oBACvB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;oBAC3B,IAAI,OAA2B,CAAC;oBAChC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;wBACnB,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;wBACrB,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;4BACrB,OAAO,CAAC,KAAK,oBAAyB,CAAC;yBACxC;qBACF;iBACF;;YAxDsB,mBAAM,GAAgB,CAAC,UAAU,CAAC,CAAC;YA2D5D,MAAMhB,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAKpC,gBAAa,kBAAkB,iCAA/B,MAAa,kBAAkB;gBAO7B,YAAY,YAA2B,EAAE,GAAgB,EAAE,WAAmB;oBAC5E,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,oBAAoB,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACjG,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAE/B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,OAAO;oBACZ,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACrD;gBAEM,KAAK,CAAC,KAAqB;oBAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBAE5C,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,iCAAuC,CAAC;oBAEtF,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,SAAS,CAAC,UAAuB;oBACtC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;wBAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBAC3C,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;qBACrC;oBACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;iBAChC;gBAEM,WAAW,CAAC,UAAuB;oBACxC,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;wBAC/D,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;qBACxC;iBACF;aACF,EAAA;YA1CY,kBAAkB;gBAD9B,oBAAoB,EAAE;eACV,kBAAkB,EA0C9B;;YC/JD,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;YAEpC,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;YAE3B;YACA;YACA;AACA,kBAAa,iBAAiB;gBAa5B,YAAY,GAAc,EAAE,WAAwB;oBAH7C,eAAU,GAAY,IAAI,CAAC;oBAIhC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,mBAAmB,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;;oBAEhG,IAAI,WAAW,KAAK,QAAQ,EAAE;;wBAE5B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;wBACf,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;qBACtC;yBAAM;wBACL,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;qBACtC;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEO,eAAe;oBACrB,OAAQ,IAAI,CAAC,GAAc,CAAC,MAAM,CAAC;iBACpC;gBACO,eAAe;oBACrB,OAAO,SAAS,CAAC;iBAClB;8DACF;YACD,iBAAiB,CAAC,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;YAC5C,iBAAiB,CAAC,SAAS,CAAC,SAAS,GAAG,IAAI,CAAC;YAC7C,iBAAiB,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;YAC/C,iBAAiB,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC;;YC1C3C,MAAMA,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAEpC,kBAAa,gBAAgB;gBAI3B,YAAY,GAA4B,EAAE,WAAmB;oBAC3D,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,kBAAkB,EAAE,aAAa,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC/F,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;oBAC/B,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;gBAEM,QAAQ;oBACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACnC;gBAEM,QAAQ,CAAC,KAAc;oBAC5B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC;iBACpC;aACF;;YCaD,MAAMgB,aAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAe9C,kBAAa,gBAAgB,+BAAG,EAAE,CAAC,eAAe,CAAmB,kBAAkB,CAAC,CAAC,SAAS,EAAE,EAAC;AAOrG,kBAAa,sBAAsB,qCAAG,EAAE,CAAC,eAAe,CAAyB,wBAAwB,CAAC,CAAC,SAAS,EAAE,EAAC;AAMvH,kBAAa,sBAAsB,qCAAG,EAAE,CAAC,eAAe,CAAyB,wBAAwB,CAAC,CAAC,SAAS,EAAE,EAAC;YAEvH,SAAS,qBAAqB,CAAC,OAAe,EAAE,IAAY;gBAC1D,IAAI,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBACxD,IAAI,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;gBAE3C,OAAO,EAAE,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;oBAClC,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;oBAClD,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;iBACtC;gBAED,OAAO,EAAG,CAAC;YACb,CAAC;YAED;AACA,kBAAa,eAAe;gBAS1B,YACE,SAAqB,EACrB,YAA2B,EAC3B,qBAA6C,EAC7C,qBAA6C;oBAE7C,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;oBACnB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;oBACnD,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;iBACpD;gBAEM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,OAAO,YAAY,CAAC,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBAC3E;gBAEM,WAAW,CAAC,KAAqB,EAAE,GAAgC,EAAE,YAAoB;oBAC9F,IAAI,KAAK,4BAAmC,OAAO,GAAG,KAAK,QAAQ,EAAE;wBACnE,OAAO,aAAa,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAAkC,CAAC;qBACtF;oBACD,IAAI,gBAAgB,CAAC,GAAG,CAAC,EAAE;wBACzB,OAAO,GAAG,CAAC,YAAa,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;qBACvF;oBACD,IAAI,eAAe,GAAG,GAAG,CAAC,UAA6B,CAAC;oBACxD,IAAI,QAAuD,CAAC;oBAE5D,IAAI,eAAe,IAAI,YAAY,IAAI,eAAe,EAAE;wBACtD,OAAO,eAAe,CAAC,YAAY,CAAC,CAAC;qBACtC;oBAED,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;oBAEjE,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;wBACxB,IAAI,eAAe,KAAK,KAAK,CAAC,EAAE;4BAC9B,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAoB,CAAC;yBAC3E;wBAED,eAAe,CAAC,YAAY,CAAC,GAAG,QAA4B,CAAC;qBAC9D;oBAED,OAAO,QAAQ,CAAC;iBACjB;gBAEM,UAAU,CAAC,OAAkC;oBAClD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAC7B;gBAEM,WAAW,CAAC,KAAqB,EAAE,GAAgB,EAAE,YAAoB;oBAC9E,IAAI,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;wBAClD,IAAI,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,EAAE;4BAC1E,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;yBACnD;wBACD,OAAO,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;qBACzF;oBAED,IAAI,KAAK,0BAAiC;wBACxC,OAAO,aAAa,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAAkC,CAAC;qBACtF;oBACD,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;iBAChD;gBAEM,gBAAgB,CAAC,KAAqB,EAAE,aAA6B;oBAC1E,OAAO,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;iBAC/D;gBAEM,cAAc,CAAC,KAAqB,EAAE,WAAyB;oBACpE,OAAO,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;iBAC3D;gBAEM,cAAc,CAAC,KAAqB,EAAE,WAAyB;oBACpE,OAAO,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;iBAC3D;gBAEO,0BAA0B,CAAC,GAAgB;oBACjD,OAAO,GAAG,CAAC,UAA6B,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC;iBAC7E;gBAEO,qBAAqB,CAAC,GAAgB;oBAC5C,MAAM,KAAK,GAA2C,EAAE,CAAC;oBACzD,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,EAAE;wBAC7C,UAAU,EAAE,KAAK;wBACjB,YAAY,EAAE,KAAK;wBACnB,QAAQ,EAAE,KAAK;wBACf,KAAK,EAAE,KAAK;qBACb,CAAC,EAAE;wBACF,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;qBACxB;oBACD,OAAO,KAAK,CAAC;iBACd;gBAEO,kBAAkB,CAAC,KAAqB,EAAE,GAAgB,EAAE,YAAoB,EAAE,UAA8B;oBACtH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;wBACtD,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACjC,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;wBAC3E,IAAI,QAAQ,IAAI,IAAI,EAAE;4BACpB,OAAO,QAAQ,CAAC;yBACjB;qBACF;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEO,sBAAsB,CAAC,KAAqB,EAAE,GAAgB,EAAE,YAAoB;oBAC1F,IAAI,EAAE,GAAG,YAAY,MAAM,CAAC,EAAE;wBAC5B,OAAO,IAAI,iBAAiB,CAAC,GAA2B,EAAE,YAAY,CAA2B,CAAC;qBACnG;oBAED,IAAI,MAAM,GAAG,KAAK,CAAC;oBACnB,IAAI,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;wBAClD,MAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;wBACxG,IAAI,QAAQ,IAAI,IAAI,EAAE;4BACpB,OAAO,QAAQ,CAAC;yBACjB;wBACD,MAAM,GAAG,IAAI,CAAC;qBACf;oBAED,MAAM,GAAG,GAAGA,aAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBAClC,QAAQ,GAAG;wBACT,KAAK,gBAAgB;4BACnB,IAAI,YAAY,KAAK,QAAQ,EAAE;gCAC7B,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,GAAqB,CAAC,CAAC,iBAAiB,EAAE,CAAC;6BAChF;4BACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;wBAC7D,KAAK,cAAc;4BACjB,IAAI,YAAY,KAAK,MAAM,EAAE;gCAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,GAAmB,CAAC,CAAC,iBAAiB,EAAE,CAAC;6BAC5E;4BACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;wBAC7D,KAAK,cAAc;4BACjB,IAAI,YAAY,KAAK,MAAM,EAAE;gCAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,GAAmB,CAAC,CAAC,iBAAiB,EAAE,CAAC;6BAC5E;4BACD,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;qBAC9D;oBAED,MAAM,UAAU,GAAG,qBAAqB,CAAC,GAAG,EAAE,YAAY,CAEzD,CAAC;oBAEF,IAAI,UAAU,KAAK,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,EAAE;wBACpD,IAAI,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,WAAW,EAAE;4BAChD,OAAO,UAAU,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;yBACxC;;wBAGD,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;wBACtF,IAAI,eAAe,EAAE;4BACnB,OAAO,eAAe,CAAC;yBACxB;wBACD,IAAI,MAAM,EAAE;;4BAEV,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;yBAC5D;wBAED,OAAO,sBAAsB,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;qBAC9G;oBACD,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACrE;;YArKsB,sBAAM,GAAgB,CAAC,UAAU,EAAE,aAAa,EAAE,sBAAsB,EAAE,sBAAsB,CAAC,CAAC;AA0K3H,qBAAgB,qBAAqB,CAAC,KAAqB,EAAE,SAAqB,EAAE,UAAgC;;;gBAGlH,MAAM,aAAa,GAAG,UAAU,YAAY,MAAM,GAAG,aAAa,CAAC,aAAa,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC;gBAC1G,QAAQA,aAAW,CAAC,IAAI,CAAC,UAAU,CAAC;oBAClC,KAAK,gBAAgB;wBACnB,OAAO,gBAAgB,CAAC,KAAK,EAAE,SAAS,EAAE,aAA+B,CAAC,CAAC;oBAC7E,KAAK,cAAc;wBACjB,OAAO,cAAc,CAAC,KAAK,EAAE,SAAS,EAAE,aAA6B,CAAC,CAAC;oBACzE,KAAK,cAAc;wBACjB,OAAO,cAAc,CAAC,KAAK,EAAE,SAAS,EAAE,aAA6B,CAAC,CAAC;iBAC1E;gBACD,OAAO,KAAK,CAAC,CAAC;YAChB,CAAC;YAED,SAAS,gBAAgB,CAAC,GAAY;gBACpC,OAAQ,GAAuB,CAAC,UAAU,KAAK,IAAI,CAAC;YACtD,CAAC;;;AC5QD,gBAUa,YAAY,4CAAzB,MAAa,YAAY;gBAcvB,YACE,SAAqB,EACrB,KAAqB,EACrB,GAAe,EACf,YAAoB,EACpB,MAAc;oBAEd,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,OAAO,GAAG,KAAK,CAAC;oBACpB,IAAI,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;wBAC9B,OAAO,GAAG,IAAI,CAAC;wBACf,GAAG,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;wBAC5C,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC;qBACrB;yBAAM;wBACL,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;qBAChB;oBACD,IAAI,CAAC,WAAW,GAAG,YAAY,CAAC;oBAChC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;oBAEvB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBAErB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAA2C,CAAC;oBAE3E,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,EAAE;wBAC5B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;qBACxB;yBAAM;wBACL,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBAC/C,IAAI,CAAC,OAAO,EAAE;4BACZ,IAAI,CAAC,kBAAkB,EAAE,CAAC;yBAC3B;qBACF;oBACD,IAAI,CAAC,eAAe,GAAG,KAAK,0CAAyC;iBACtE;gBAEM,YAAY,CAAC,QAAiB,EAAE,QAAiB,EAAE,KAAqB;oBAC7E,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBAChC;gBAEM,QAAQ;oBACb,OAAO,IAAI,CAAC,YAAY,CAAC;iBAC1B;gBAEM,QAAQ,CAAC,QAAiB,EAAE,KAAqB;oBACtD,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;wBACvC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;wBAC7B,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE;4BACpC,IAAI,CAAC,KAAK,4BAAgC,CAAC,EAAE;gCAC3C,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;gCAC3E,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,EAAE;oCAC5B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;iCACpF;6BACF;yBACF;6BAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;4BACxB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;4BACpB,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC;4BAC7B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBAChC;qBACF;yBAAM;;wBAEL,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;qBACvC;iBACF;gBAEM,SAAS,CAAC,UAAuB;oBACtC,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;wBAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBAC/C,IAAI,CAAC,kBAAkB,EAAE,CAAC;qBAC3B;oBAED,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;iBAChC;gBAEO,kBAAkB;oBACxB,IACE,CAAC,OAAO,CAAC,cAAc,CACrB,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,WAAW,EAChB;wBACE,UAAU,EAAE,IAAI;wBAChB,YAAY,EAAE,IAAI;wBAClB,GAAG,EAAE;4BACH,OAAO,IAAI,CAAC,YAAY,CAAC;yBAC1B;wBACD,GAAG,EAAE,KAAK;4BACR,IAAI,CAAC,QAAQ,CAAC,KAAK,eAAsB,CAAC;yBAC3C;qBACF,CACF,EACD;wBACA,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;qBAC/C;iBACF;aACF,EAAA;YA/GY,YAAY;gBADxB,oBAAoB,EAAE;eACV,YAAY,EA+GxB;;YCnHD,MAAM,WAAET,SAAO,UAAED,QAAM,YAAEW,UAAQ,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;AAI1D,kBAAsB,mBAAmB;gBAGvC,YAAY,IAAiB;oBAC3B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;gBAEM,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA2B;oBAC3E,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC;oBACpC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;iBAC1B;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA2B;oBAC7E,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,YAAa,CAAC;oBACrC,OAAO,CAAC,YAAY,GAAG,IAAK,CAAC;iBAC9B;kEACF;AAED,kBAAa,sBAAuB,SAAQ,mBAAmB;gBAG7D;oBACE,KAAK,CAACV,SAAO,CAAC,CAAC;iBAChB;wEACF;YACD,uBAAuB,CAAC,MAAM,CAAC,SAAS,EAAE,sBAAsB,CAAC,CAAC;AAElE,kBAAa,qBAAsB,SAAQ,mBAAmB;gBAG5D;oBACE,KAAK,CAACD,QAAM,CAAC,CAAC;iBACf;sEACF;YACD,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,qBAAqB,CAAC,CAAC;AAEhE,kBAAa,uBAAwB,SAAQ,mBAAmB;gBAG9D;oBACE,KAAK,CAACW,UAAQ,CAAC,CAAC;iBACjB;0EACF;YACD,uBAAuB,CAAC,MAAM,CAAC,UAAU,EAAE,uBAAuB,CAAC,CAAC;AAEpE,kBAAa,qBAAsB,SAAQ,mBAAmB;gBAG5D;oBACE,KAAK,CAAC,MAAM,CAAC,CAAC;iBACf;sEACF;YACD,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,qBAAqB,CAAC,CAAC;;YC7ChE,MAAM,KAAK,GAAG,EAAE,CAAC;YAEjB;AACA,qBAAgB,kBAAkB,CAA4B,QAAiB,EAAE,QAAiB,EAAE,KAAqB;gBACvH,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;gBACjC,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBAC9C,KAAK,CAAC,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;YACxH,CAAC;YAED;AACA,qBAAgB,YAAY,CAA4B,QAAiB,EAAE,QAAiB,EAAE,KAAqB;gBACjH,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;gBACjC,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBAC9C,IAAI,EAAE,KAAK,GAAG,KAAK,CAAC,qBAAqB,CAAC,EAAE;oBAC1C,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;oBAChD,OAAO;iBACR;gBACD,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,EAAE;oBAC5B,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC3B;gBACD,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAU,CAC1C;oBACE,MAAM,EAAE,GAAG,KAAK,CAAC,QAAQ,CAAC;oBAC1B,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;iBAC3C,EACD,KAAK,CAAC,KAAK,CACZ,CAAC;gBACF,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;YAC9B,CAAC;YAED,MAAMA,UAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC;AAEtC,kBAAa,uBAAuB;gBAG3B,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B,EAAE,QAAgB,GAAG;oBACjG,IAAI,gBAAgB,CAAC;oBACrB,IAAI,qBAAqB,CAAC;oBAC1B,IAAI,SAA0D,CAAC;oBAE/D,IAAI,OAAO,YAAY,OAAO,EAAE;wBAC9B,gBAAgB,GAAG,cAAc,CAAC;wBAClC,SAAS,GAAG,YAAY,CAAC;wBACzB,qBAAqB,GAAG,OAAO,CAAC,IAAI,GAAGA,UAAQ,mEAA+E;qBAC/H;yBAAM;wBACL,gBAAgB,GAAG,YAAY,CAAC;wBAChC,SAAS,GAAG,kBAAkB,CAAC;wBAC/B,qBAAqB,iCAAuC;qBAC7D;;;;oBAKD,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,gBAA6C,CAA4C,CAAC;oBAC5H,OAAO,CAAC,eAAe,CAAC,YAAY,GAAG,gBAAgB,CAAC;;oBAGvD,OAAgE,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;;oBAGhG,OAAO,CAAC,aAAa,GAAG;wBACtB,qBAAqB;wBACrB,KAAK;wBACL,SAAS,EAAE,CAAC;wBACZ,QAAQ,EAAE,KAAK;qBAChB,CAAC;iBACH;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;;oBAE9E,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC;oBAC5D,OAAsF,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC;oBACnI,OAAO,CAAC,eAAe,GAAG,IAAK,CAAC;oBAChC,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;oBAC9D,OAAO,CAAC,aAAa,GAAG,IAAK,CAAC;iBAC/B;0EACF;YACD,uBAAuB,CAAC,MAAM,CAAC,UAAU,EAAE,uBAAuB,CAAC,CAAC;;kBC/EvD,uBAAuB;gBAQ3B,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC,CAAC;oBAC9E,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxD;gBAEM,IAAI,CAAC,OAAgB,EAAE;oBAC5B,MAAM,EAAE,cAAc,EAAE,GAAG,OAAO,CAAC;oBACnC,IAAI,cAAc,IAAI,KAAK,CAAC,EAAE;wBAC5B,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,QAAQ,CAAC;wBAC3C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;4BAChC,cAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC;yBACpC;6BAAM;4BACL,QAAQ,QAAQ;gCACd,KAAK,SAAS;oCACZ,cAAc,CAAC,QAAQ,yBAAuB;oCAC9C,MAAM;gCACR,KAAK,MAAM;oCACT,cAAc,CAAC,QAAQ,sBAAoB;oCAC3C,MAAM;gCACR,KAAK,MAAM;oCACT,cAAc,CAAC,QAAQ,sBAAoB;oCAC3C,MAAM;gCACR,KAAK,QAAQ;oCACX,cAAc,CAAC,QAAQ,wBAAsB;oCAC7C,MAAM;gCACR,KAAK,QAAQ;oCACX,cAAc,CAAC,QAAQ,wBAAsB;oCAC7C,MAAM;gCACR,KAAK,WAAW;oCACd,cAAc,CAAC,QAAQ,2BAAyB;oCAChD,MAAM;gCACR,KAAK,SAAS;oCACZ,cAAc,CAAC,QAAQ,wBAAuB;oCAC9C,MAAM;gCACR,KAAK,KAAK;oCACR,cAAc,CAAC,QAAQ,oBAAmB;6BAC7C;yBACF;qBACF;iBACF;gBAEM,MAAM,CAAC,OAAgB;oBAC5B,IAAI,OAAO,CAAC,cAAc,IAAI,KAAK,CAAC,EAAE;wBACpC,OAAO,CAAC,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;qBACpD;iBACF;;YAlDsB,4BAAI,GAA6B,uBAAuB,CAAC;YACzD,mCAAW,GAAyC,MAAM,CAAC,MAAM,CAAC;gBACvF,IAAI,EAAE,UAAU;aACjB,CAAC,CAAC;;kBCZQ,qBAAqB;gBAOhC,YAAY,QAAmB;oBAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA0B,EAAE,GAAG,IAAc;oBAC7F,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;wBACzB,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;qBAC1B;oBAED,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;wBAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;wBACrB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;wBAC/C,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;qBACvB;yBAAM,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC/B,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;wBACvD,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;wBAErB,OAAO,CAAC,EAAE,EAAE;4BACV,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;4BACtB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;yBAChD;wBAED,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC;qBACxB;yBAAM;wBACL,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;qBAC1B;iBACF;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA0B;oBAC5E,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC;oBAC5B,OAAO,CAAC,MAAM,GAAG,IAA0B,CAAC;oBAE5C,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;wBACvB,MAAM,KAAK,GAAG,IAAI,CAAC;wBACnB,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;wBAErB,OAAO,CAAC,EAAE,EAAE;4BACV,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;yBACvD;qBACF;yBAAM;wBACL,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;qBACnD;iBACF;;YAhDsB,4BAAM,GAAgB,CAAC,SAAS,CAAC,CAAC;YAkD3D,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,qBAAqB,CAAC,CAAC;;YC7ChE;AACA,qBAAgB,QAAQ,CAA4B,QAAiB;gBACnE,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;gBACjC,MAAM,OAAO,GAAG,CAAC,IAAI,IAAI,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC;gBAEzC,IAAI,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE;oBAC1B,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC9C,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;oBACrB,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;oBACzB,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;oBAC/B,OAAO;iBACR;gBAED,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;gBAE1B,IAAI,KAAK,CAAC,SAAS,KAAK,CAAC,CAAC,EAAE;oBAC1B,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAU,CAC1C;wBACE,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;wBACrB,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;wBACzB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;qBACtC,EACD,KAAK,CAAC,KAAK,GAAG,OAAO,CACtB,CAAC;oBACF,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;iBAC7B;YACH,CAAC;AAED,kBAAa,uBAAuB;gBAG3B,IAAI,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B,EAAE,QAAgB,GAAG;oBACjG,IAAI,gBAAwB,CAAC;oBAE7B,IAAI,OAAO,YAAY,OAAO,EAAE;wBAC9B,IAAI,OAAO,CAAC,IAAI,KAAK,WAAW,CAAC,MAAM,EAAE;4BACvC,gBAAgB,GAAG,cAAc,CAAC;yBACnC;6BAAM;4BACL,gBAAgB,GAAG,cAAc,CAAC;yBACnC;qBACF;yBAAM;wBACL,gBAAgB,GAAG,YAAY,CAAC;qBACjC;;;;oBAKD,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,gBAA6C,CAA2C,CAAC;oBAC3H,OAAO,CAAC,eAAe,CAAC,YAAY,GAAG,gBAAgB,CAAC;;oBAGvD,OAA8D,CAAC,gBAAgB,CAAC,GAAG,QAAkD,CAAC;;oBAGvI,OAAO,CAAC,aAAa,GAAG;wBACtB,KAAK,EAAE,KAAK;wBACZ,IAAI,EAAE,CAAC;wBACP,SAAS,EAAE,CAAC,CAAC;qBACd,CAAC;iBACH;gBAEM,MAAM,CAAC,KAAqB,EAAE,KAAa,EAAE,OAA4B;;oBAE9E,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC;oBAC5D,OAAsF,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC;oBACnI,OAAO,CAAC,eAAe,GAAG,IAAK,CAAC;oBAChC,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;oBAC9D,OAAO,CAAC,aAAa,GAAG,IAAK,CAAC;iBAC/B;0EACF;YACD,uBAAuB,CAAC,MAAM,CAAC,UAAU,EAAE,uBAAuB,CAAC,CAAC;;qBCzDpD,QAAQ,CAAiE,cAAmC,EAAE,IAAa;gBACzI,IAAI,MAA4B,CAAC;gBAEjC,MAAM,SAAS,GAAG,SAAS,QAAQ,CAAC,OAAU,EAAE,KAAa;oBAC3D,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;;;;;;wBAMxB,MAAM,CAAC,QAAQ,GAAG,KAAK,CAAC;qBACzB;oBACD,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,WAAqC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;iBACzE,CAAC;gBACF,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;;;oBAGxB,MAAM,GAAG,EAAE,CAAC;oBACZ,SAAS,CAAC,cAAmB,EAAE,IAAK,CAAC,CAAC;oBACtC,OAAO;iBACR;qBAAM,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;;;;;oBAK7C,MAAM,GAAG,EAAE,CAAC;oBACZ,OAAO,SAA8B,CAAC;iBACvC;;;;gBAKD,MAAM,IAAI,cAAc,IAAI,EAAE,CAAyB,CAAC;gBACxD,OAAO,SAA8B,CAAC;YACxC,CAAC;AAQD,kBAAa,QAAQ,uBAAG;gBACtB,GAAG,CAAmC,GAAM;oBAC1C,MAAM,OAAO,GAA2B;wBACtC,GAAG,CAAC,YAA2C;4BAC7C,IAAI,WAAW,IAA0B,KAAK,CAAC,CAAE,CAAC;4BAClD,IAAI,YAAY,YAAY,MAAM,EAAE;gCAClC,WAAW,GAAG,YAAY,CAAC;6BAC5B;iCAAM,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;gCAC3C,WAAW,GAAG;oCACZ,QAAQ,EAAE,YAAY;iCACvB,CAAC;6BACH;4BACD,MAAM,IAAI,GAAG,WAAW,CAAC,QAAQ,CAAC;4BAClC,IAAI,CAAC,IAAI,EAAE;gCACT,MAAM,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;6BACzB;4BACD,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE;gCAC1B,WAAW,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;6BACzC;4BACD,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;gCACzB,WAAW,CAAC,QAAQ,GAAG,GAAG,IAAI,SAAS,CAAC;6BACzC;4BACD,IAAI,WAAW,CAAC,IAAI,KAAK,SAAS,EAAE;gCAClC,WAAW,CAAC,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC;6BACvC;4BACA,GAAG,CAAC,SAAkD,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC;4BAC5E,OAAO,IAAI,CAAC;yBACb;wBACD,GAAG;4BACD,OAAO,GAAG,CAAC,SAAiD,CAAC;yBAC9D;qBACF,CAAC;oBACF,IAAI,GAAG,CAAC,SAAS,KAAK,SAAS,EAAE;wBAC/B,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC;qBACpB;yBAAM,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;wBACvC,MAAM,KAAK,GAAG,GAAG,CAAC,SAAS,CAAC;wBAC5B,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC;wBACnB,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;qBAC5B;oBACD,OAAO,OAAO,CAAC;iBAChB;aACF;;YCnFD;AACA,YAAO,MAAM,iBAAiB,GAAG,gBAAgB,CAAC;YAClD;AACA,qBAAgB,gBAAgB,CAAC,IAAY;gBAC3C,OAAO,GAAG,iBAAiB,IAAI,IAAI,EAAE,CAAC;YACxC,CAAC;YACD;AACA,qBAAgB,qBAAqB,CAA0B,IAAO;gBACpE,OAAQ,IAA6B,CAAC,WAAW,CAAC;YACpD,CAAC;YAED;AACA,YAAO,MAAM,mBAAmB,GAAG,kBAAkB,CAAC;YACtD;AACA,qBAAgB,kBAAkB,CAAC,IAAY;gBAC7C,OAAO,GAAG,mBAAmB,IAAI,IAAI,EAAE,CAAC;YAC1C,CAAC;YAaD;;;;;;;;;AASA,gBAAkB,uBAYjB;YAZD,WAAkB,uBAAuB;gBACvC,gDAAqB,CAAA;gBACrB,kDAAuB,CAAA;gBACvB,2DAAgC,CAAA;gBAChC,mDAAwB,CAAA;gBACxB,6CAAkB,CAAA;gBAClB,+CAAoB,CAAA;gBACpB,iDAAsB,CAAA;gBACtB,6CAAkB,CAAA;gBAClB,4CAAiB,CAAA;gBACjB,4CAAiB,CAAA;gBACjB,iDAAsB,CAAA;YACxB,CAAC,EAZiB,uBAAuB,KAAvB,uBAAuB,4CAYxC;AAyCD,kBAAa,oBAAoB,mCAAG,EAAE,CAAC,eAAe,CAAuB,iBAAiB,CAAC,CAAC,SAAS,EAAE,EAAC;AAyB5G,qBAAgB,qBAAqB,CAAC,KAAc;gBAClD,MAAM,IAAI,GAAI,KAA2B,CAAC,IAAI,CAAC;gBAC/C,OAAO,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;YACvD,CAAC;YAyED;AACA,YAAO,MAAM,aAAa,GAAsB,MAAM,CAAC,MAAM,CAAC;gBAC5D,QAAQ,EAAE,IAAI;gBACd,QAAQ,EAAE,SAAS;aACpB,CAAC,CAAC;YAEH,MAAM,gBAAgB,GAAsB,MAAM,CAAC,MAAM,CAAC;gBACxD,QAAQ,EAAE,KAAK;gBACf,QAAQ,EAAE,SAAS;aACpB,CAAC,CAAC;AAEH,kBAAa,eAAe;gBAmB1B,YAAY,MAAc;oBACxB,IAAI,CAAC,SAAS,GAAG,QAAQ,IAAI,MAAM,CAAC;oBACpC,IAAI,CAAC,UAAU,GAAG,SAAS,IAAI,MAAM,CAAC;oBACtC,IAAI,CAAC,UAAU,GAAG,SAAS,IAAI,MAAM,CAAC;oBACtC,IAAI,CAAC,QAAQ,GAAG,OAAO,IAAI,MAAM,CAAC;oBAClC,IAAI,CAAC,YAAY,GAAG,WAAW,IAAI,MAAM,CAAC;oBAC1C,IAAI,CAAC,UAAU,GAAG,SAAS,IAAI,MAAM,CAAC;oBACtC,IAAI,CAAC,YAAY,GAAG,WAAW,IAAI,MAAM,CAAC;oBAC1C,IAAI,CAAC,WAAW,GAAG,UAAU,IAAI,MAAM,CAAC;oBACxC,IAAI,CAAC,YAAY,GAAG,WAAW,IAAI,MAAM,CAAC;oBAC1C,IAAI,CAAC,WAAW,GAAG,UAAU,IAAI,MAAM,CAAC;oBACxC,IAAI,CAAC,UAAU,GAAG,SAAS,IAAI,MAAM,CAAC;iBACvC;;YA9BsB,oBAAI,GAA8B,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,EAAE,CAAC,CAAC,CAAC;YAiClG;YACA;YACA;YACA,MAAM,yBAAyB;gBAe7B;oBACE,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;oBACtB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;oBACf,IAAI,CAAC,KAAK,GAAG,gBAAgB,CAAC;oBAC9B,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,WAAW,CAAC;oBACtC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,UAA+D,CAAC;oBAC7F,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,UAA+D,CAAC;oBAC7F,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,UAA6D,CAAC;oBACzF,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;oBAC3B,IAAI,CAAC,aAAa,GAAG,IAAK,CAAC;oBAC3B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;oBACtB,IAAI,CAAC,QAAQ,wBAAgC;oBAC7C,IAAI,CAAC,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC;iBACnC;aACF;YAED,MAAM,6BAA6B,GAAG;gBACpC,MAAM;gBACN,UAAU;gBACV,OAAO;gBACP,OAAO;gBACP,eAAe;gBACf,eAAe;gBACf,UAAU;aACX,CAAC;YAEF,MAAM,wBAAwB,GAAG;gBAC/B,cAAc;gBACd,cAAc;gBACd,YAAY;aACb,CAAC;YAiCF;AACA,qBAAgB,uBAAuB,CACrC,IAAqC,EACrC,SAA8C,EAC9C,QAAyB,EACzB,KAA2B,EAC3B,KAA0C,EAC1C,SAAuD,EACvD,YAAwE,EACxE,YAA8C,EAC9C,UAAuD,EACvD,aAA8B,EAC9B,aAAkD,EAClD,QAAyB,EACzB,QAAiC;gBAEjC,MAAM,GAAG,GAAG,IAAI,yBAAyB,EAAE,CAAC;;gBAG5C,MAAM,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;gBAChC,QAAQ,MAAM;oBACZ,KAAK,EAAE,EAAE,IAAI,QAAQ,IAAI,IAAI;wBAAE,GAAG,CAAC,QAAQ,GAAG,mBAAmB,CAAC,QAAQ,CAAC,CAAC;oBAC5E,KAAK,EAAE,EAAE,IAAI,QAAQ,IAAI,IAAI;wBAAE,GAAG,CAAC,QAAQ,GAAG,QAAS,CAAC;oBACxD,KAAK,EAAE,EAAE,IAAI,aAAa,IAAI,IAAI;wBAAE,GAAG,CAAC,aAAa,GAAG,aAAc,CAAC;oBACvE,KAAK,EAAE,EAAE,IAAI,aAAa,IAAI,IAAI;wBAAE,GAAG,CAAC,aAAa,GAAG,aAAc,CAAC;oBACvE,KAAK,CAAC,EAAE,IAAI,UAAU,IAAI,IAAI;wBAAE,GAAG,CAAC,UAAU,GAAG,OAAO,CAAC,UAAW,CAAC,CAAC;oBACtE,KAAK,CAAC,EAAE,IAAI,YAAY,IAAI,IAAI;wBAAE,GAAG,CAAC,YAAY,GAAG,OAAO,CAAC,YAAa,CAAC,CAAC;oBAC5E,KAAK,CAAC,EAAE,IAAI,YAAY,IAAI,IAAI;wBAAE,GAAG,CAAC,YAAY,GAAG,OAAO,CAAC,YAAa,CAA6B,CAAC;oBACxG,KAAK,CAAC,EAAE,IAAI,SAAS,IAAI,IAAI;wBAAE,GAAG,CAAC,SAAS,GAAG,EAAE,GAAG,SAAS,EAAE,CAAC;oBAChE,KAAK,CAAC,EAAE,IAAI,KAAK,IAAI,IAAI;wBAAE,GAAG,CAAC,KAAK,GAAG,KAAK,KAAK,IAAI,GAAG,aAAa,GAAG,KAAK,KAAK,KAAK,GAAG,gBAAgB,GAAG,EAAE,GAAG,KAAM,EAAE,CAAC;oBAC3H,KAAK,CAAC,EAAE,IAAI,KAAK,IAAI,IAAI;wBAAE,GAAG,CAAC,KAAK,GAAG,KAAM,CAAC;oBAC9C,KAAK,CAAC,EAAE,IAAI,QAAQ,IAAI,IAAI;wBAAE,GAAG,CAAC,QAAQ,GAAG,QAAQ,CAAC;oBACtD,KAAK,CAAC;wBACJ,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,IAAI,CAAC,SAAS,EAAE;gCAClB,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAqB,CAAC,CAAC,GAAG,EAAE,CAAC;6BAC3D;4BACD,IAAI,IAAI,CAAC,aAAa,EAAE;gCACtB,GAAG,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;6BACxC;4BACD,IAAI,IAAI,CAAC,aAAa,EAAE;gCACtB,GAAG,CAAC,aAAa,GAAG,IAAI,CAAC,aAAuD,CAAC;6BAClF;4BACD,IAAI,IAAI,CAAC,SAAS,EAAE;gCAClB,GAAG,CAAC,KAAK,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;6BACjD;yBACF;wBACD,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;4BACjC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;gCACxB,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC;6BACtB;yBACF;6BAAM,IAAI,SAAS,IAAI,IAAI,EAAE;4BAC5B,GAAG,CAAC,QAAQ,GAAG,mBAAmB,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;4BACvD,6BAA6B,CAAC,OAAO,CAAC,IAAI;gCACxC,IAAI,SAAS,CAAC,IAA8B,CAAC,EAAE;oCAC7C,GAAG,CAAC,IAAwB,CAAC,GAAG,SAAS,CAAC,IAA8B,CAAC,CAAC;iCAC3E;6BACF,CAAC,CAAC;4BACH,wBAAwB,CAAC,OAAO,CAAC,IAAI;gCACnC,IAAI,SAAS,CAAC,IAA8B,CAAC,EAAE;oCAC7C,GAAG,CAAC,IAAwB,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,IAA8B,CAAc,CAAC,CAAC;iCACjG;6BACF,CAAC,CAAC;4BACH,IAAI,SAAS,CAAC,WAAW,CAAC,EAAE;gCAC1B,IAAI,GAAG,CAAC,SAAS,KAAK,QAAQ,CAAC,WAAW,EAAE;oCAC1C,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,SAA0B,CAAC,CAAC,GAAG,EAAE,CAAC;iCAChE;qCAAM;oCACL,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC;iCACnD;6BACF;yBACF;iBACJ;;gBAGD,IAAI,MAAM,KAAK,CAAC,IAAI,IAAI,KAAK,IAAI,KAAK,OAAO,SAAS,KAAK,QAAQ,IAAI,EAAE,OAAO,IAAI,SAAU,CAAC,CAAC,EAAE;oBAChG,GAAG,CAAC,KAAK,GAAG,aAAa,CAAC;iBAC3B;gBAED,OAAO,GAAG,CAAC;YACb,CAAC;;YCrYD;AACA,qBAAgB,iBAAiB,CAA6B,SAAqB;gBACjF,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;gBACrC,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBACxD,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;gBAEpC,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC9D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;gBAEvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAChD,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC;iBAC/D;YACH,CAAC;AAQD,qBAAgB,eAAe,CAAC,gBAA+C;gBAC7E,OAAO,MAAM,IAAI,uBAAuB,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;YAC5E,CAAC;AAUD,qBAAgB,kBAAkB,CAAC,gBAA6E;gBAC9G,OAAO,MAAM,IAAI,uBAAuB,CAAC,MAAM,CAC7C,OAAO,gBAAgB,KAAK,QAAQ;sBAClC,EAAE,oBAAoB,EAAE,IAAI,EAAG,IAAI,EAAE,gBAAgB,EAAE;sBACvD,EAAE,oBAAoB,EAAE,IAAI,EAAE,GAAG,gBAAgB,EAAE,EACrD,MAAM,CAAC,CAAC;YACZ,CAAC;YAID,SAAS,uBAAuB,CAA0B,MAA6B;gBACrF,MAAM,CAAC,iBAAiB,GAAG,IAAI,CAAC;gBAChC,OAAO,MAAyC,CAAC;YACnD,CAAC;AAUD,qBAAgB,cAAc,CAA0B,MAA8B;gBACpF,OAAO,MAAM,KAAK,SAAS,GAAG,uBAAuB,GAAG,uBAAuB,CAAI,MAAM,CAAC,CAAC;YAC7F,CAAC;YAED,SAASd,QAAM,CAAoC,IAAuC;gBACxF,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;YAC5B,CAAC;YAKD,SAASC,QAAM,CAA0E,gBAA+C,EAAE,IAAO;gBAC/I,MAAM,IAAI,GAAG,IAAmC,CAAC;gBACjD,MAAM,YAAY,GAAG,IAA6C,CAAC;gBACnE,MAAM,WAAW,GAAG,gCAAgC,CAAC,OAAO,gBAAgB,KAAK,QAAQ,GAAG,EAAE,IAAI,EAAE,gBAAgB,EAAE,GAAG,gBAAgB,EAAE,IAAI,CAAC,CAAC;gBAEjJ,YAAY,CAAC,IAAI,GAAG,uBAAmD,CAAC;gBACxE,YAAY,CAAC,WAAW,GAAG,WAAW,CAAC;gBACvC,IAAI,CAAC,QAAQ,GAAG,iBAAiB,CAAC;gBAElC,OAAO,IAAI,CAAC;YACd,CAAC;AAED,kBAAa,uBAAuB,sCAAG;gBACrC,IAAI,EAAE,mBAAmB;gBACzB,OAAO,EAAE,kBAAkB;wBAC3BD,QAAM;wBACNC,QAAM;aACP,EAAC;YAEF;AACA,qBAAgB,gCAAgC,CAAC,GAAyB,EAAE,IAA0B;gBACpG,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;gBAC5B,MAAM,kBAAkB,GAAG,GAAG,CAAC,kBAAkB,CAAC;gBAClD,OAAO;oBACL,IAAI,EAAE,GAAG,CAAC,IAAI;oBACd,OAAO,EAAE,OAAO,IAAI,IAAI,GAAG,QAAQ,CAAC,UAAmD,GAAG,OAAO;oBACjG,kBAAkB,EAAE,kBAAkB,IAAI,IAAI,GAAG,WAAW,CAAC,MAAM,GAAG,kBAAkB;oBACxF,iBAAiB,EAAE,GAAG,CAAC,iBAAiB,KAAK,SAAS,GAAG,KAAK,GAAG,GAAG,CAAC,iBAAiB;oBACtF,oBAAoB,EAAE,GAAG,CAAC,oBAAoB,KAAK,SAAS,GAAG,KAAK,GAAG,GAAG,CAAC,oBAAoB;oBAC/F,SAAS,EAAE,EAAE,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAqB,CAAC,CAAC,GAAG,EAAE,EAAE,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;oBACvF,QAAQ,EAAE,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC;oBAC3C,KAAK,EAAE,IAAI,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC;iBAC3C,CAAC;YACJ,CAAC;;kBCjIY,KAAK,oBAAG,EAAE,CAAC,eAAe,CAAQ,OAAO,CAAC,CAAC,SAAS,EAAE,EAAC;AAEpE,kBAAa,eAAe,8BAAG,EAAE,CAAC,eAAe,CAAkB,iBAAiB,CAAC,CAAC,SAAS,EAAE,EAAC;AAmDlG,kBAAa,IAAI,mBAAG,EAAE,CAAC,eAAe,CAAO,MAAM,CAAC,CAAC,SAAS,EAAE,EAAC;YAyBjE,MAAM,EAAE,GAAG,UAAS,GAAG,IAAe;gBACpC,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;;YAE7B,CAAQ,CAAC;YAET,MAAM,KAAK,GAAS;gBAClB,gBAAgB,EAAE,EAAE;gBACpB,WAAW,EAAE,EAAE;gBACf,SAAS,EAAE,EAAE;gBACb,uBAAuB,EAAE,EAAE;gBAC3B,sBAAsB,EAAE,EAAE;gBAC1B,aAAa,EAAE,EAAE;gBACjB,iBAAiB,EAAE,EAAE;gBACrB,aAAa,EAAE,EAAE;gBACjB,kBAAkB,EAAE,EAAE;gBACtB,cAAc,EAAE,EAAE;gBAClB,cAAc,EAAE,EAAE;gBAClB,YAAY,EAAE,EAAE;gBAChB,QAAQ,EAAE,EAAE;gBACZ,cAAc,EAAE,EAAE;gBAClB,gBAAgB,EAAE,EAAE;gBACpB,UAAU,EAAE,EAAE;gBACd,uBAAuB,EAAE,EAAE;gBAC3B,MAAM,EAAE,EAAE;gBACV,mBAAmB,EAAE,EAAE;gBACvB,YAAY,EAAE,EAAE;aACjB,CAAC;AAEF,kBAAa,GAAG,kBAIZ;gBACF,GAAG,KAAK;gBACR,IAAI,aAAa;oBACf,OAAO,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,cAAc,CAAC,KAAK,IAAI,CAAC;iBACnD;gBACD,UAAU,CAAC,GAAS;oBAClB,IAAI,IAAI,CAAC,aAAa,EAAE;wBACtB,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;qBAC5B;oBACD,MAAM,WAAW,GAA0B,EAAE,CAAC;oBAC9C,MAAM,MAAM,GAAW,CAAC,GAAG,CAAC,CAAC;oBAC7B,IAAI,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;oBACvC,OAAO,KAAK,IAAI,KAAK,KAAK,MAAM,CAAC,SAAS,EAAE;wBAC1C,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACtB,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;qBACtC;oBACD,KAAK,KAAK,IAAI,MAAM,EAAE;wBACpB,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,CAAC;qBACrE;oBACD,MAAM,IAAI,GAAa,EAAE,CAAC;oBAC1B,IAAI,GAAW,CAAC;oBAChB,IAAI,UAA8B,CAAC;oBACnC,KAAK,GAAG,IAAI,WAAW,EAAE;wBACvB,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;wBAC9B,IAAI,UAAU,CAAC,YAAY,IAAI,UAAU,CAAC,QAAQ,EAAE;4BAClD,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC;4BAC9C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;yBAChB;qBACF;oBACD,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;oBACpC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;iBACzC;gBACD,OAAO;oBACL,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;wBACvB,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;qBAC5B;oBACD,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAa,CAAC;oBACvD,IAAI,CAAC,OAAO,CAAC,GAAG;wBACd,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;qBACnC,CAAC,CAAC;oBACH,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBAC3B,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC;oBACnD,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;iBAC1C;aACF,EAAC;YAEF;YACA;YACA;YACA,MAAM,aAAa,GAAkB;gBACnC,SAAS,EAAE,KAAK;gBAChB,QAAQ,EAAE,KAAK;gBACf,IAAI,EAAE,KAAK,CAAC;gBACZ,UAAU,EAAE,QAAQ,CAAC,UAAU;gBAC/B,UAAU,EAAE,IAAK;gBACjB,SAAS,EAAE,IAAK;gBAChB,WAAW,KAAuB,OAAO,QAAQ,CAAC,UAAU,CAAC,EAAE;gBAC/D,YAAY,CAAC,OAAc,KAA0B;gBACrD,QAAQ,CAAC,MAAa,KAA0B;gBAChD,MAAM,MAA2B;gBACjC,WAAW,MAA2B;gBACtC,MAAM,MAA2B;gBACjC,IAAI,CAAC,IAAiD,KAA0B;aACjF,CAAC;AAEF,kBAAa,YAAY,2BAAG;gBAC1B,KAAK,EAAE,aAAa;aACrB;;kBCvLY,aAAa,4BAAG;gBAC3B,IAAI,EAAE;oBACJ,IAAI,EAAE,IAAI;oBACV,SAAS,KAAc,OAAO,KAAK,CAAC,EAAE;oBACtC,MAAM,KAAW,OAAO,EAAE;oBAC1B,IAAI,KAAuB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,EAAE;iBACvD;aACF,EAAC;AASF,kBAAa,WAAW;gBAOtB,YACE,OAAmB,EACnB,IAAiE,EACjE,OAAgB,EAChB,GAAG,IAAW;oBAEd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAClB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK;wBAC/B,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;4BAC7B,OAAO;yBACR;wBACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;wBACvB,IAAI,IAAI,KAAK,IAAI,EAAE;;4BAEjB,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;4BACtD,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;gCACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;6BAClB;iCAAM;gCACL,MAAM,WAAW,GAAI,UAA+B,CAAC,IAAI,YAAY,QAAQ;sCACzE,UAA8B;sCAC7B,UAA6B,CAAC,IAAI,EAAE,CAAC;gCAC1C,OAAO,WAAW,CAAC,IAAI,CAAC;oCACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iCAClB,CAAC,CAAC;6BACJ;yBACF;qBACF,CAAC,CAAC;iBACJ;gBAEM,SAAS;oBACd,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;iBACzB;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;wBACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;qBACzB;iBACF;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,OAAO,CAAC;iBACrB;kDACF;AAED,kBAAa,gBAAgB;gBAO3B,YACE,UAA6C,EAC7C,IAA4C,EAC5C,OAAgB,EAChB,GAAG,IAAW;oBAEd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAClB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBAEzB,MAAM,OAAO,GAAI,UAA+B,CAAC,IAAI,YAAY,QAAQ;0BACrE,UAA8B;0BAC7B,UAA6B,CAAC,IAAI,EAAE,CAAC;oBAE1C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;wBAC1B,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;4BAC7B,OAAO;yBACR;wBACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;wBACvB,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAuB,CAAC;wBACrE,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;4BACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;yBAClB;6BAAM;4BACL,MAAM,WAAW,GAAI,UAA+B,CAAC,IAAI,YAAY,QAAQ;kCACzE,UAA8B;kCAC7B,UAA6B,CAAC,IAAI,EAAE,CAAC;4BAC1C,OAAO,WAAW,CAAC,IAAI,CAAC;gCACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;6BAClB,CAAC,CAAC;yBACJ;qBACF,CAAC,CAAC;iBACJ;gBAEM,SAAS;oBACd,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;iBACzB;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;wBACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;qBACzB;iBACF;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,OAAO,CAAC;iBACrB;4DACF;AAED,kBAAa,YAAY;gBAKvB,YAAY,UAA6C;oBACvD,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAElB,IAAI,CAAC,OAAO,GAAI,UAA+B,CAAC,IAAI,YAAY,QAAQ;0BACpE,UAA8B;0BAC7B,UAA6B,CAAC,IAAI,EAAE,CAAC;oBAE1C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;wBAChB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;qBAClB,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;iBAC7B;gBAEM,SAAS;oBACd,OAAO,KAAK,CAAC;iBACd;gBAEM,MAAM;oBACX,OAAO;iBACR;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,OAAO,CAAC;iBACrB;oDACF;AAED,kBAAa,yBAAyB;gBAOpC,YACE,WAA6B,EAC7B,IAA+C,EAC/C,OAAgB,EAChB,GAAG,IAAW;oBAEd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAClB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;wBAC9D,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;4BAC7B,OAAO;yBACR;wBACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;wBACvB,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAA+B,CAAC;wBAC7E,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;4BACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;yBAClB;6BAAM;4BACL,OAAO,UAAU,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC;gCAC5B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;6BAClB,CAAC,CAAC;yBACJ;qBACF,CAAC,CAAC;iBACJ;gBAEM,SAAS;oBACd,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;iBACzB;gBAEM,MAAM;oBACX,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;wBACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;qBACzB;iBACF;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,OAAO,CAAC;iBACrB;8EACF;AAED,kBAAa,qBAAqB;gBAKhC,YAAY,WAA6B;oBACvC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;oBAClB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;wBAC9D,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;qBAClB,CAAC,CAAC;iBACJ;gBAEM,SAAS;oBACd,OAAO,KAAK,CAAC;iBACd;gBAEM,MAAM;oBACX,OAAO;iBACR;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,OAAO,CAAC;iBACrB;sEACF;AAED,qBAAgB,YAAY,CAAC,KAAyB;gBACpD,OAAO,EAAE,KAAK,KAAK,KAAK,CAAC,IAAK,KAAwB,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;YACxE,CAAC;;kBC9LY,EAAE;gBA8Cb,YACE,SAA0B,EAC1B,QAA4B;oBApBd,eAAU,GAAqB;wBAC7C,KAAK,EAAE,IAA6B;qBACrC,CAAC;oBAoBA,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEjC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAC1B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;oBACvB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBACrB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;oBACzB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;oBAEpB,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;oBAC/B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;oBAEnB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;iBACrB;gBA9CD,IAAW,KAAK;oBACd,OAAO,IAAI,CAAC,MAAM,CAAC;iBACpB;gBACD,IAAW,KAAK,CAAC,QAAiB;oBAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC7B,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;wBACvB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBAC/D;iBACF;gBAuCM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC,CAAC;oBACxE,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxD;gBAEM,QAAQ;oBACb,OAAO,IAAI,CAAC,MAAM,CAAC;iBACpB;gBAEM,QAAQ,CAAC,QAAiB,EAAE,KAAqB;oBACtD,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC7B,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;wBACvB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBACvE;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAC1C;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBACjF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;qBACxB;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;qBAC3E;iBACF;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BAClB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACzB;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;yBACjF;qBACF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;wBACxB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACrC;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;yBACjF;qBACF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;wBACxD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;qBACtB;oBAED,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;wBAC5D,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;qBACxB;oBAED,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;iBACpB;gBAEM,YAAY,CAAC,QAAiB,EAAE,QAAiB,EAAE,KAAqB;oBAC7E,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,wBAAsB,CAAC,EAAE;wBAClD,OAAO;qBACR;oBACD,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAC1C;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBACjF;iBACF;;gBAGM,UAAU,CAAC,KAAc,EAAE,KAAqB;oBACrD,IAAI,IAAgC,CAAC;oBACrC,IAAI,KAAK,EAAE;wBACT,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;qBAC1E;yBAAM,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,EAAE;wBACrC,IAAI,GAAG,IAAI,CAAC,QAAQ,GAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;qBACjF;yBAAM;wBACL,IAAI,GAAG,KAAK,CAAC,CAAC;qBACf;oBACD,OAAO,IAAI,CAAC;iBACb;;gBAGM,UAAU,CAAC,IAAgC,EAAE,OAAwB,EAAE,KAAqB;oBACjG,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;wBACnB,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBAC9B;oBAED,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAEzB,OAAO,IAAI,CAAC;iBACb;gBAEO,IAAI,CAAC,KAAc,EAAE,KAAqB;oBAChD,IAAI,IAAI,GAAmB,aAAa,CAAC,IAAI,CAAC;oBAC9C,IACE,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC;4BACvC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,EAC7C;wBACA,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;qBAC/B;oBACD,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBAC3C,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;qBACnC;yBAAM;wBACL,IAAI,GAAG,IAAI,WAAW,CAA+C,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;qBACzJ;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEO,UAAU,CAAC,KAAqB;oBACtC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;oBACvB,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;wBACnB,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBACnB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAC3B;gBAEO,QAAQ,CAAC,IAAgC,EAAE,KAAqB;oBACtE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;wBACnB,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBACD,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAChC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,4BAAyB,CAAC,EAAE;wBACrD,OAAO,IAAI,CAAC;qBACb;oBAED,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;qBACxB;yBAAM;wBACL,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;qBACjE;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEO,QAAQ,CAAC,KAAqB;oBACpC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,+BAA6B,CAAC,EAAE;wBACjF,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBACtD;oBACD,OAAO,aAAa,CAAC,IAAI,CAAC;iBAC3B;gBAEO,UAAU,CAAC,KAAqB;oBACtC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,qCAAkC,CAAC,EAAE;wBACtF,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBACzB;iBACF;;YAlOsB,SAAM,GAAgB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;YAEtD,OAAI,GAA6B,uBAAuB,CAAC;YACzD,cAAW,GAAmC,MAAM,CAAC,MAAM,CAAC;gBACjF,IAAI,EAAE,IAAI;gBACV,OAAO,EAAE,QAAQ,CAAC,UAAmD;gBACrE,kBAAkB,EAAE,WAAW,CAAC,MAAM;gBACtC,iBAAiB,EAAE,KAAK;gBACxB,oBAAoB,EAAE,IAAI;gBAC1B,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;gBACtE,QAAQ;gBACR,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;aACxD,CAAC,CAAC;AAyNL,kBAAa,IAAI;gBAiBf,YAAY,OAAwB;oBAClC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;iBACxB;gBAEM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC,CAAC;iBAC3E;gBAEM,IAAI,CAAC,UAAkC;oBAC5C,IAAI,UAAU,YAAY,EAAE,EAAE;wBAC5B,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC;qBACvC;yBAAM,IAAI,UAAU,CAAC,SAAS,YAAY,EAAE,EAAE;wBAC7C,UAAU,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC;qBACjD;yBAAM;wBACL,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;qBAC3C;iBACF;;YAhCsB,WAAM,GAAgB,CAAC,YAAY,CAAC,CAAC;YAErC,SAAI,GAA6B,uBAAuB,CAAC;YACzD,gBAAW,GAAmC;gBACnE,IAAI,EAAE,MAAM;gBACZ,OAAO,EAAE,QAAQ,CAAC,UAAmD;gBACrE,kBAAkB,EAAE,WAAW,CAAC,MAAM;gBACtC,iBAAiB,EAAE,KAAK;gBACxB,oBAAoB,EAAE,IAAI;gBAC1B,SAAS,EAAE,QAAQ,CAAC,WAAW;gBAC/B,QAAQ;gBACR,KAAK,EAAE,eAAe,CAAC,IAAI;aAC5B,CAAC;;kBC5NS,MAAM;gBAkDjB,YACE,QAA4B,EAC5B,UAA0B,EAC1B,OAAwB;oBAzBV,eAAU,GAAqB;wBAC7C,KAAK,EAAE,IAA6B;qBACrC,CAAC;oBAyBA,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEjC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,0BAA0B,GAAG,KAAK,CAAC;oBACxC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;oBACzB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;oBACvB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;oBAChB,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;oBAClB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;oBAEpB,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;iBAChC;gBAlDD,IAAW,KAAK;oBACd,OAAO,IAAI,CAAC,MAAM,CAAC;iBACpB;gBACD,IAAW,KAAK,CAAC,QAAkB;oBACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC7B,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;wBACvB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBAC3C;iBACF;gBA2CM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,yBAAyB,EAAE,IAAI,CAAC,CAAC,CAAC;oBAC5E,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxD;gBAEM,OAAO,CAAC,KAAS;oBACtB,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;oBACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,QAAqB,CAAC;oBACvD,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;oBAC5B,IAAI,OAAgB,CAAC;oBACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACtB,IAAI,OAAO,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC,cAAc,KAAK,OAAO,EAAE;4BACjE,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,gBAAkC,CAAC;4BACxD,MAAM;yBACP;qBACF;oBACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAM,EAAE,IAAI,CAAW,CAAC;oBAE7F,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;oBACtC,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,SAAS,CAAC,KAAS;oBACxB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;qBACjC;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;qBACpF;iBACF;gBAEM,SAAS,CAAC,KAAS;oBACxB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,kBAAkB,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;qBACtD;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;qBACzG;iBACF;gBAEM,SAAS,CAAC,KAAS;oBACxB,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;oBAEpC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,2BAA2B,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;qBAClF;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,2BAA2B,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;qBACzH;oBACD,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;;gBAGM,YAAY,CAAC,KAAS;oBAC3B,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;oBAChC,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;oBACpC,KAAK,kCAA4B;oBACjC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;iBACvC;;gBAGM,sBAAsB,CAAC,QAA8B,EAAE,KAAS;oBACrE,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;oBAChC,KAAK,KAAK,oDAAuC,CAAC;oBAClD,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBACzC;gBAEO,iBAAiB,CAAC,QAA8B,EAAE,KAAS;oBACjE,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,+BAA6B,CAAC,EAAE;4BACzD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;4BACpC,IAAI,CAAC,kBAAkB,CAAC,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;4BAC7C,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,2BAA2B,CAAC,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;6BAC1E;iCAAM;gCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,2BAA2B,EAAE,IAAI,EAAE,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;6BACjH;4BAED,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;6BAC/C;iCAAM;gCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,qBAAqB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;6BACtF;yBACF;wBAED,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,qCAAkC,CAAC,EAAE;4BAC9D,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCAClB,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;6BAC9B;iCAAM;gCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;6BACjF;yBACF;qBACF;yBAAM;wBACL,uBAAuB,CAAC,QAAQ,CAAC,CAAC;wBAClC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,+BAA6B,CAAC,EAAE;;4BAEzD,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gCACpC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;gCAC1C,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oCAClB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iCACxC;qCAAM;oCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;iCAC3F;gCAED,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oCAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iCAC7D;qCAAM;oCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,yBAAyB,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;iCACpG;6BACF;;4BAGD,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,0BAA0B,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;6BAC9D;iCAAM;gCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,0BAA0B,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;6BACrG;yBACF;wBAED,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,qCAAkC,CAAC,EAAE;4BAC9D,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCAClB,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;6BACtC;iCAAM;gCACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;6BACzF;yBACF;qBACF;iBACF;gBAEO,uBAAuB,CAAC,KAAS;oBACvC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAClC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,+BAA6B,CAAC,EAAE;wBACzD,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,GAAG,qBAAqB,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;wBACzG,IAAI,WAAW,KAAK,WAAW,IAAI,WAAW,EAAE;4BAC9C,WAAW,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;yBAC7C;wBACD,IAAI,WAAW,EAAE;4BACf,WAAW,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;yBACzC;qBACF;yBAAM,IAAI,WAAW,EAAE;wBACtB,WAAW,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;qBAC7C;iBACF;gBAEO,kBAAkB,CAAC,MAAc,EAAE,IAAY,EAAE,KAAS;oBAChE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAC5C,IAAI,IAAoB,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,EAAE;wBAClC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBAChB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACpB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBACpB;oBACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAChD;gBAEO,2BAA2B,CAAC,MAAc,EAAE,IAAY,EAAE,KAAS,EAAE,YAAqB;oBAChG,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAoB,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;oBAC3C,IAAI,IAAoB,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,EAAE;wBAClC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BACd,IAAI,KAAK,KAAK,SAAS,EAAE;gCACvB,KAAK,GAAG,EAAE,CAAC;6BACZ;4BACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAClB;qBACF;oBAED,IAAI,YAAY,EAAE;wBAChB,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;qBAC5B;oBAED,IAAI,KAAK,KAAK,SAAS,EAAE;wBACvB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;wBAC9C,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,OAAO,IAAI,yBAAyB,CAClC,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EACtC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,EAClC,KAAK,CACN,CAAC;iBACH;gBAEO,gBAAgB,CAAC,QAAkB,EAAE,KAAS;oBACpD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAC5C,MAAM,OAAO,GAAG,QAAQ,CAAC,YAAY,CAAC;oBACtC,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;oBAClC,IAAI,IAAoB,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;wBACnC,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;wBACzB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACpB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBACpB;oBACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAChD;gBAEO,yBAAyB,CAAC,QAAkB,EAAE,KAAS;oBAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAoB,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;oBAC3C,MAAM,OAAO,GAAG,QAAQ,CAAC,YAAY,CAAC;oBACtC,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;oBAClC,IAAI,IAAoB,CAAC;oBACzB,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;wBAC1B,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;wBACzB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BACd,IAAI,KAAK,KAAK,SAAS,EAAE;gCACvB,KAAK,GAAG,EAAE,CAAC;6BACZ;4BACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAClB;qBACF;oBAED,CAAC,GAAG,CAAC,CAAC;oBACN,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;wBAC1B,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;wBACnB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;qBACzB;oBAED,IAAI,KAAK,KAAK,SAAS,EAAE;wBACvB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;wBAC9C,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,OAAO,IAAI,yBAAyB,CAClC,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EACtC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,EAClC,KAAK,CACN,CAAC;iBACH;gBAEO,qBAAqB,CAAC,KAAS;oBACrC,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAoB,CAAC;oBACzB,IAAI,IAAoB,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBACzC,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;oBAC9C,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;oBACzC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI;wBAC5C,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBACxC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;wBAEpE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BACd,IAAI,KAAK,KAAK,SAAS,EAAE;gCACvB,KAAK,GAAG,EAAE,CAAC;6BACZ;4BACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAClB;qBACF,CAAC,CAAC;oBAEH,IAAI,KAAK,KAAK,SAAS,EAAE;wBACvB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;wBAC5C,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,OAAO,IAAI,yBAAyB,CAClC,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,EACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,EAChC,KAAK,CACN,CAAC;iBACH;gBAEO,0BAA0B,CAAC,QAAkB,EAAE,KAAS;oBAC9D,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAoB,CAAC;oBACzB,IAAI,IAAoB,CAAC;oBACzB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBACzC,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;oBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;wBAC/B,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;4BACtB,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;;4BAE7B,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAG,KAAa,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;4BACjF,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;4BAEzB,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCACd,IAAI,KAAK,KAAK,SAAS,EAAE;oCACvB,KAAK,GAAG,EAAE,CAAC;iCACZ;gCACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;6BAClB;yBACF;qBACF;oBAED,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,EAAE;;wBAE3B,MAAM,IAAI,KAAK,CAAC,YAAY,KAAK,CAAC,MAAM,YAAY,MAAM,EAAE,CAAC,CAAC;qBAC/D;oBAED,IAAI,KAAK,KAAK,SAAS,EAAE;wBACvB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;wBAC5C,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,OAAO,IAAI,yBAAyB,CAClC,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,EACpC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,EAChC,KAAK,CACN,CAAC;iBACH;gBAEO,WAAW,CACjB,KAAS,EACT,KAAa,EACb,IAAa,EACb,IAAoB;oBAEpB,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC;oBACpC,MAAM,WAAW,GAAG,UAAU,CAAC,KAAM,CAAC;oBACtC,MAAM,GAAG,GAAG,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACtD,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC;oBACjB,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;oBACxD,IAAI,UAAU,CAAC,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;wBACjD,IACE,WAAW,CAAC,UAAU,KAAK,KAAK,CAAC;4BACjC,WAAW,CAAC,UAAU,KAAK,QAAQ,CAAC,WAAW,EAC/C;4BACA,KAAK,CAAC,UAAU,GAAG,EAAE,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC;yBAClD;6BAAM;4BACL,KAAK,CAAC,UAAU,GAAG,EAAE,CAAC;yBACvB;wBAED,KAAK,MAAM,QAAQ,IAAI,UAAU,CAAC,UAAU,EAAE;4BAC5C,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;yBACpC;qBACF;oBAED,OAAO,KAAK,CAAC;iBACd;gBAEO,WAAW,CAAC,QAA8B,EAAE,KAAS;oBAC3D,IAAI,IAAoB,CAAC;oBACzB,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBACjC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAC5C,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC9C,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;4BAChB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;4BACpB,IAAI,CAAC,KAAM,CAAC,MAAM,EAAE,CAAC;4BACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACpB;qBACF;yBAAM;wBACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC9C,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;gCACrB,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gCAChB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCACpB,IAAI,CAAC,KAAM,CAAC,MAAM,EAAE,CAAC;gCACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;6BACpB;yBACF;qBACF;oBACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAChD;gBAEO,gBAAgB,CAAC,KAAS;oBAChC,IAAI,IAAoB,CAAC;oBACzB,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBACjC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC9C,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBAChB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBACpB,IAAI,CAAC,KAAM,CAAC,MAAM,EAAE,CAAC;wBACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBACpB;oBACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAChD;gBAEO,cAAc,CAAC,QAAkB,EAAE,KAAS;;oBAElD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;oBAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,kBAAkB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;;;oBAIpC,MAAM,GAAG,GAAG,4BAA4B,CAAC,QAAQ,CAAC,CAAC;oBACnD,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;oBAC1B,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAE5C,KAAK,iCAAoB;oBAEzB,IAAI,IAAiB,CAAC;oBACtB,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;oBACnB,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;oBAC5B,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;wBAClB,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;4BACtB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;4BACxB,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACxB;6BAAM,IAAI,CAAC,GAAG,CAAC,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;4BAChD,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACxB;6BAAM;4BACL,EAAE,CAAC,CAAC;yBACL;wBAED,IAAI,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACpB,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;4BACnB,KAAK,CAAC,CAAC,CAAC,CAAC,KAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAM,CAAC,CAAC;yBACnC;6BAAM;4BACL,KAAK,CAAC,CAAC,CAAC,CAAC,KAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;yBAChC;qBACF;oBAED,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAChD;;YA3esB,aAAM,GAAgB,CAAC,eAAe,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;YAEnE,WAAI,GAA6B,uBAAuB,CAAC;YACzD,kBAAW,GAAmC,MAAM,CAAC,MAAM,CAAC;gBACjF,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,QAAQ,CAAC,UAAmD;gBACrE,kBAAkB,EAAE,WAAW,CAAC,MAAM;gBACtC,iBAAiB,EAAE,KAAK;gBACxB,oBAAoB,EAAE,IAAI;gBAC1B,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;gBACtE,QAAQ;gBACR,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;aAC5D,CAAC,CAAC;YAkeL,IAAI,WAAuB,CAAC;YAC5B,IAAI,WAAuB,CAAC;YAC5B,IAAI,MAAM,GAAG,CAAC,CAAC;YAEf;YACA;YACA;AACA,qBAAgB,4BAA4B,CAAC,QAAkB;gBAC7D,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;gBAE5B,IAAI,GAAG,GAAG,MAAM,EAAE;oBAChB,MAAM,GAAG,GAAG,CAAC;oBACb,WAAW,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;oBAClC,WAAW,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;iBACnC;gBAED,IAAI,MAAM,GAAG,CAAC,CAAC;gBACf,IAAI,GAAG,GAAG,CAAC,CAAC;gBACZ,IAAI,IAAI,GAAG,CAAC,CAAC;gBACb,IAAI,CAAC,GAAG,CAAC,CAAC;gBACV,IAAI,CAAC,GAAG,CAAC,CAAC;gBACV,IAAI,GAAG,GAAG,CAAC,CAAC;gBACZ,IAAI,IAAI,GAAG,CAAC,CAAC;gBACb,IAAI,GAAG,GAAG,CAAC,CAAC;gBAEZ,OAAO,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBACnB,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;oBAClB,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE;wBACd,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;wBAExB,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACnB,IAAI,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,GAAG,GAAG,EAAE;4BAC7B,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;4BACnB,WAAW,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;4BAC1B,SAAS;yBACV;wBAED,GAAG,GAAG,CAAC,CAAC;wBACR,IAAI,GAAG,MAAM,CAAC;wBAEd,OAAO,GAAG,GAAG,IAAI,EAAE;4BACjB,GAAG,GAAG,CAAC,GAAG,GAAG,IAAI,KAAK,CAAC,CAAC;4BACxB,IAAI,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;4BAClC,IAAI,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,GAAG,GAAG,EAAE;gCAC7B,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;6BACf;iCAAM;gCACL,IAAI,GAAG,GAAG,CAAC;6BACZ;yBACF;wBAED,IAAI,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;wBAClC,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,KAAK,CAAC,CAAC,EAAE;4BAC7B,IAAI,GAAG,GAAG,CAAC,EAAE;gCACX,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;6BACvC;4BACD,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;yBACtB;qBACF;iBACF;gBACD,CAAC,GAAG,EAAE,MAAM,CAAC;gBACb,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;gBACjC,GAAG,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAE9B,OAAO,MAAM,EAAE,GAAG,CAAC,EAAE;oBACnB,MAAM,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;oBACrB,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;iBACxB;gBACD,OAAO,CAAC,EAAE,GAAG,CAAC;oBAAE,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gBACnC,OAAO,MAAM,CAAC;YAChB,CAAC;YAED;;;;;;;YAOA,SAAS,uBAAuB,CAAC,QAAkB;gBACjD,IAAI,MAAM,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,GAAG,CAAC,CAAC;gBACV,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;gBAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;oBAC5B,OAAO,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,MAAM,EAAE;wBAC7C,EAAE,CAAC,CAAC;wBACJ,EAAE,MAAM,CAAC;qBACV;oBACD,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;wBACtB,EAAE,MAAM,CAAC;qBACV;yBAAM;wBACL,QAAQ,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC;qBACvB;iBACF;YACH,CAAC;YAED;;;;YAIA,SAAS,kBAAkB,CAAI,KAAU,EAAE,QAAkB;gBAC3D,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;gBAE3B,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;gBAC5B,IAAI,EAAE,GAAG,CAAC,CAAC;gBACX,IAAI,IAAI,GAAG,CAAC,CAAC;gBACb,OAAO,EAAE,GAAG,GAAG,EAAE;oBACf,IAAI,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;oBACpB,IAAI,IAAI,KAAK,CAAC,CAAC,EAAE;wBACf,KAAK,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;qBACxB;oBACD,EAAE,EAAE,CAAC;iBACN;YACH,CAAC;;kBC/nBY,WAAW;gBAuBtB,YACE,OAAwB,EACxB,QAA4B;oBAE5B,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEjC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBAEvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;oBAClC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;iBAC1B;gBAEM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,8BAA8B,EAAE,IAAI,CAAC,CAAC,CAAC;oBACjF,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxD;gBAEM,OAAO,CAAC,KAAqB;oBAClC,MAAM,QAAQ,GAAG,cAAc,CAAC,QAAQ,CAAC;oBACzC,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;oBAC5C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,8CAA6C,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;oBACtG,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,cAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC;qBACpC;yBAAM;wBACL,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC;4BACf,cAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC;yBACpC,CAAC,CAAC;qBACJ;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAChC;;YA/DsB,kBAAM,GAAgB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;YAEtD,gBAAI,GAA6B,uBAAuB,CAAC;YACzD,uBAAW,GAAmC,MAAM,CAAC,MAAM,CAAC;gBACjF,IAAI,EAAE,aAAa;gBACnB,OAAO,EAAE,QAAQ,CAAC,UAAmD;gBACrE,kBAAkB,EAAE,WAAW,CAAC,MAAM;gBACtC,iBAAiB,EAAE,KAAK;gBACxB,oBAAoB,EAAE,IAAI;gBAC1B,SAAS,EAAE,QAAQ,CAAC,WAAW;gBAC/B,QAAQ;gBACR,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;aACjE,CAAC,CAAC;;kBCXQ,IAAI;gBAuCf,YACE,OAAwB,EACxB,QAA4B;oBAbd,eAAU,GAAqB;wBAC7C,KAAK,EAAE,IAA6B;qBACrC,CAAC;oBAaA,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEjC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;oBAClC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAEzB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;iBACtB;gBAjCD,IAAW,KAAK;oBACd,OAAO,IAAI,CAAC,MAAM,CAAC;iBACpB;gBACD,IAAW,KAAK,CAAC,QAA4B;oBAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;oBAC7B,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;wBACvB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,eAAsB,CAAC;qBAC5D;iBACF;gBA0BM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC,CAAC;oBAC1E,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxD;gBAEM,YAAY,CAAC,QAAiB,EAAE,QAAiB,EAAE,KAAqB;oBAC7E,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,+BAA6B,CAAC,EAAE;wBACzD,IAAI,CAAC,SAAS,qBAAyB,CAAC;qBACzC;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBACvB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEM,SAAS,CAAC,KAAqB;oBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEO,SAAS,CAAC,KAAqB;oBACrC,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAM,EAAE,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;oBACxG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;iBAC9B;;YAjFsB,WAAM,GAAgB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;YAEtD,SAAI,GAA6B,uBAAuB,CAAC;YACzD,gBAAW,GAAmC,MAAM,CAAC,MAAM,CAAC;gBACjF,IAAI,EAAE,MAAM;gBACZ,OAAO,EAAE,QAAQ,CAAC,UAAmD;gBACrE,kBAAkB,EAAE,WAAW,CAAC,MAAM;gBACtC,iBAAiB,EAAE,KAAK;gBACxB,oBAAoB,EAAE,IAAI;gBAC1B,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;gBACtE,QAAQ;gBACR,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAC1D,CAAC,CAAC;;kBCIQ,iBAAiB,gCAAG,EAAE,CAAC,eAAe,CAAoB,mBAAmB,CAAC,CAAC,SAAS,EAAE,EAAC;YAkBxG;AACA,qBAAgB,eAAe,CAA2B,SAAqB;gBAC7E,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC7D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC9D,SAAS,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACzD,CAAC;AAQD,qBAAgB,aAAa,CAAC,gBAA8C;gBAC1E,QAAQ,MAAM,IAAI,qBAAqB,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,EAA6B;YACvG,CAAC;YAED,SAASD,QAAM,CAAkC,IAAqC;gBACpF,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;YAC5B,CAAC;YAKD,SAASC,QAAM,CAAwE,gBAA8C,EAAE,OAAiB,IAAI;gBAC1J,IAAI,CAAC,gBAAgB,EAAE;oBACrB,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;iBAC1B;gBACD,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,MAAM,eAAe;iBAAoB,GAAG,IAAI,CAA8B,CAAC;gBAC5G,MAAM,YAAY,GAAG,IAAuC,CAAC;gBAC7D,MAAM,WAAW,GAAG,uBAAuB,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;gBAEpE,YAAY,CAAC,IAAI,GAAG,qBAA+C,CAAC;gBACpE,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;gBAC/B,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC;gBAEhC,OAAO,IAAI,CAAC;YACd,CAAC;AAED,kBAAa,qBAAqB,oCAAG;gBACnC,IAAI,EAAE,iBAAiB;gBACvB,OAAO,EAAE,gBAAgB;wBACzBD,QAAM;gBACN,WAAW,EAAE,qBAA8D;wBAC3EC,QAAM;aACP,EAAC;YAmCF,MAAM,oBAAoB,GAAG;gBAC3B,IAAI,EAAE,MAA2B;aAClC,CAAC;AAUF,qBAAgB,YAAY,CAA0B,eAA4E;gBAChI,MAAM,OAAO,GAAG,OAAO,eAAe,KAAK,UAAU,IAAI,CAAC,eAAe;sBACrE,oBAAoB;sBACpB,eAAoD,CAAC;gBAEzD,SAAS,qBAAqB,CAAC,MAA4B;oBACzD,MAAM,CAAC,aAAa,GAAG,OAAO,CAAC;oBAC/B,OAAO,MAAwC,CAAC;iBACjD;gBAED,OAAO,OAAO,eAAe,KAAK,UAAU,GAAG,qBAAqB,CAAC,eAAe,CAAC,GAAG,qBAAqB,CAAC;YAChH,CAAC;YAID,SAAS,sBAAsB,CAA0B,MAA4B;gBACnF,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC;gBAC5B,OAAO,MAAwC,CAAC;YAClD,CAAC;AAUD,qBAAgB,aAAa,CAA0B,MAA6B;gBAClF,OAAO,MAAM,KAAK,SAAS,GAAG,sBAAsB,GAAG,sBAAsB,CAAI,MAAM,CAAC,CAAC;YAC3F,CAAC;;YC7LD,MAAM,YAAY,GAAG,qDAAqD,CAAC;AAU3E,kBAAa,UAAU,yBAAG,EAAE,CAAC,eAAe,CAAa,YAAY,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;gBACzF,QAAQ,CAAC,KAAa;oBAC3B,OAAO,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;iBACxC;aACF,CAAC,CACH,EAAC;YAEF;;;AAGA,kBAAa,sBAAsB;gBAOjC,YAAY,SAAqB;oBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;iBAC5B;;;;;gBAMM,MAAM,CAAC,eAAuB;oBACnC,IAAI,eAAe,IAAI,IAAI,EAAE;wBAC3B,OAAO,IAAI,CAAC;qBACb;oBAED,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;iBACjD;;YApBsB,6BAAM,GAAgB,CAAC,UAAU,CAAC,CAAC;YAsB5D,sBAAsB,CAAC,MAAM,CAAC,UAAU,EAAE,sBAAsB,CAAC,CAAC;;kBClCrD,WAAW;gBAatB,YAAY,IAAY,EAAE,QAAsB,EAAE,SAAqB;oBACrE,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBAEvB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;oBACpB,IAAI,CAAC,KAAK,GAAG,IAAK,CAAC;oBACnB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;oBACzB,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC;iBACnC;gBAEM,YAAY,CAAC,IAAkB,EAAE,yBAAkC;oBACxE,IAAI,IAAI,EAAE;wBACR,IAAI,IAAI,KAAK,GAAG,EAAE;4BAChB,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC;yBACjC;6BAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;4BACnC,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;yBAC3B;wBAED,IAAI,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,IAAI,CAAC,yBAAyB,EAAE;4BACvD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;yBACvB;qBACF;oBAED,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE;wBACtB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;qBACjB;yBAAM;wBACL,IAAI,CAAC,KAAK,GAAG,IAAK,CAAC;qBACpB;oBAED,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;iBACrC;gBAEM,gBAAgB,CAAC,UAA0B;oBAChD,OAAO,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;iBACjE;gBAEM,gBAAgB,CAAC,UAA0B;oBAChD,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE;wBACrC,UAAU,CAAC,KAAK,cAAqB,CAAC;wBACtC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAC5B,OAAO,IAAI,CAAC;qBACb;oBAED,OAAO,KAAK,CAAC;iBACd;gBAEM,MAAM,CAAC,KAAsB;oBAClC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;oBACzB,IAAI,UAA0B,CAAC;oBAE/B,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;wBACrC,UAAU,GAAG,KAAK,CAAC,GAAG,EAAG,CAAC;wBAC1B,UAAU,CAAC,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,4CAAoC;wBACxE,OAAO,UAAU,CAAC;qBACnB;oBAED,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;oBACtE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,IAAK,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;oBAC3D,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;wBACrB,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;qBAC1B;oBACD,OAAO,UAAU,CAAC;iBACnB;gBAEM,QAAQ,CAAC,KAA0C;oBACxD,IAAI,IAAI,CAAC,KAAK,KAAK,QAAQ,CAAC,WAAW,EAAE;wBACvC,IAAI,CAAC,KAAK,GAAG,EAAE,GAAG,KAAK,EAAE,CAAC;qBAC3B;yBAAM;wBACL,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAClC;iBACF;;YAnFa,wBAAY,GAAW,MAAM,CAAC;;kBCgDjC,iBAAiB,gCAAG,EAAE,CAAC,eAAe,CAAoB,mBAAmB,CAAC,CAAC,SAAS,EAAE,EAAC;AAExG,gBAAY,gBAIX;YAJD,WAAY,gBAAgB;gBAC1B,uDAAqB,CAAA;gBACrB,iEAAqB,CAAA;gBACrB,iEAAqB,CAAA;YACvB,CAAC,EAJW,gBAAgB,KAAhB,gBAAgB,qCAI3B;AAMD,kBAAa,gBAAgB,+BAAG,EAAE,CAAC,eAAe,CAAmB,kBAAkB,CAAC,CAAC,SAAS,EAAE,EAAC;YAerG;YACA;YACA;YACA;YACA;YACA;AACA,kBAAa,gBAAgB;gBAO3B,YAAY,GAAY,EAAE,UAA8B,EAAE,OAAgC,EAAE,aAAgC;oBAC1H,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;iBACpC;gBAIM,MAAM,CAAC,qBAAqD,EAAE,IAAQ,EAAE,KAA+B,EAAE;oBAC9G,MAAM,UAAU,GAAG,qBAAqB,YAAY,UAAU;0BAC1D,qBAAuC;0BACtC,qBAAuC,CAAC,WAAW,CAAC;oBACzD,IAAI,UAAU,IAAI,KAAK,CAAC,EAAE;wBACxB,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;qBAC9D;oBACD,MAAM,KAAK,GAAI,UAAoC,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE,CAAC;oBAC7F,UAAoC,CAAC,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;oBACnE,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;oBAClC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBACjG;4DACF;YAED;YACA;AACA,YAAO,MAAM,cAAc,GAAc;gBACvC,aAAa,GAAG,KAAK,CAAC,CAAE;gBACxB,GAAG,GAAG,KAAK,CAAC,CAAE;gBACd,UAAU,GAAG,KAAK,CAAC,CAAE;gBACrB,MAAM,CAAC,qBAA+C;oBACpD,MAAM,UAAU,GAAG,qBAAqB,YAAY,UAAU,GAAG,qBAAqB,GAAI,qBAAoC,CAAC,WAAW,CAAC;oBAC1I,UAAoC,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;oBAChE,UAAoC,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;iBACxD;aACF,CAAC;YAEF,MAAM,mBAAmB,GAAG,SAAS,CAAC;AAoBtC,kBAAa,oBAAoB,mCAAG,EAAE,CAAC,eAAe,CAAuB,sBAAsB,CAAC,CAAC,SAAS,EAAE,EAAC;AAgBjH,kBAAa,SAAS,wBAAG,EAAE,CAAC,eAAe,CAAY,WAAW,CAAC,CAAC,SAAS,EAAE,EAAC;AAiBhF,kBAAa,gBAAgB,+BAAG,EAAE,CAAC,eAAe,CAAmB,kBAAkB,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC,EAAC;YAExI;AACA,kBAAa,eAAe;gBAU1B,YAAY,SAAqB,EAAE,eAAiC,EAAE,SAAqB,EAAE,iBAAsC;oBACjI,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;oBACvC,IAAI,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,CAAC;oBACnC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAAE,CAAC;oBAEhC,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC,MAAM,CACvC,CAAC,GAAG,EAAE,IAAI;wBACR,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;wBACtB,OAAO,GAAG,CAAC;qBACZ,EACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CACpB,CAAC;iBACH;;gBAGM,kBAAkB,CACvB,GAAY,EACZ,UAA8B,EAC9B,aAA8C,EAC9C,aAAkC;oBAElC,IAAI,UAAU,IAAI,KAAK,CAAC,EAAE;wBACxB,OAAO,KAAK,CAAC,CAAC;qBACf;oBAED,IAAI,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAEhD,IAAI,CAAC,KAAK,EAAE;wBACV,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,UAAU,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;wBAE/E,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;qBAC5C;oBAED,OAAO,KAAqB,CAAC;iBAC9B;gBAEM,cAAc,CACnB,GAAY,EACZ,UAA+B,EAC/B,aAA8C;oBAE9C,IAAI,UAAU,IAAI,KAAK,CAAC,EAAE;wBACxB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;qBAC3C;oBAED,IAAI,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAErD,IAAI,CAAC,OAAO,EAAE;wBACZ,MAAM,WAAW,GAAG,uBAAuB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;wBAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,WAAW,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC,CAAC;wBAClF,OAAO,GAAG,IAAI,WAAW,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;wBACtE,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;wBAC9C,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;qBACjD;oBAED,OAAO,OAA0B,CAAC;iBACnC;gBAEO,kBAAkB,CACxB,GAAS,EACT,UAA8B,EAC9B,aAA2C,EAC3C,aAAkC;oBAElC,IAAI,aAAa,IAAI,KAAK,CAAC,EAAE;wBAC3B,aAAa,GAAG,IAAI,CAAC,SAA2B,CAAC;qBAClD;oBAED,IAAI,UAAU,CAAC,QAAQ,IAAI,KAAK,CAAC,EAAE;wBACjC,MAAM,aAAa,GAAG,mBAAmB,CAAC,GAAG,EAAE,aAAa,EAAE,UAAU,CAAC,YAAY,EAAE,aAAa,CAAmB,CAAC;wBAExH,IAAI,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE;4BAC7B,MAAM,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,IAAI,mBAAmB,CAAC;4BACtE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;4BAE9C,IAAI,QAAQ,KAAK,SAAS,EAAE;gCAC1B,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;6BACxC;4BAED,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,UAAiC,EAAE,IAAI,2BAA2B,CAAC,aAAa,CAAC,EAAE,gBAAgB,CAAC,SAAS,CAAC,CAAC;yBACnJ;wBAED,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;qBAC/D;oBAED,OAAO,cAAc,CAAC;iBACvB;;YAjGsB,sBAAM,GAAgB,CAAC,UAAU,EAAE,gBAAgB,EAAE,UAAU,EAAE,GAAG,CAAC,iBAAiB,CAAC,CAAC,CAAC;AAoGlH,qBAAgB,mBAAmB,CACjC,GAAS,EACT,MAAmC,EACnC,YAAyB,EACzB,aAAkC;gBAElC,MAAM,OAAO,GAAG,MAAM,CAAC,WAAW,EAAoB,CAAC;gBACvD,MAAM,kBAAkB,GAAG,IAAI,gBAAgB,EAAE,CAAC;gBAClD,MAAM,eAAe,GAAG,IAAI,gBAAgB,EAAE,CAAC;gBAC/C,MAAM,mBAAmB,GAAG,IAAI,gBAAgB,EAAwB,CAAC;gBACzE,MAAM,eAAe,GAAG,IAAI,mBAAmB,EAAE,CAAC;gBAClD,MAAM,sBAAsB,GAAG,IAAI,gBAAgB,EAAmB,CAAC;gBACvE,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAExC,GAAG,CAAC,uBAAuB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;gBAEtD,OAAO,CAAC,gBAAgB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;gBACxD,OAAO,CAAC,gBAAgB,CAAC,WAAW,EAAE,kBAAkB,CAAC,CAAC;gBAC1D,OAAO,CAAC,gBAAgB,CAAC,oBAAoB,EAAE,mBAAmB,CAAC,CAAC;gBACpE,OAAO,CAAC,gBAAgB,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC;gBAElE,IAAI,YAAY,IAAI,KAAK,CAAC,EAAE;oBAC1B,OAAO,CAAC,QAAQ,CAAC,GAAG,YAAY,CAAC,CAAC;iBACnC;;gBAGD,IAAI,aAAa,EAAE;oBACjB,aAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;iBACjC;gBAED,OAAO,CAAC,MAAM,GAAG,UAEf,KAAqB,EACrB,UAAuB,EACvB,OAAyB,EACzB,kBAAsC,EACtC,IAAY,EACZ,KAA+B;oBAE/B,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,OAAO,EAAE,kBAAkB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBACzF,CAAC;;gBAGF,OAAO,CAAC,uBAAuB,GAAG,UAChC,UAAuB,EACvB,MAAa,EACb,WAAiC,EACjC,OAA4B,EAC5B,KAA+B,EAC/B,QAA0B;oBAE1B,kBAAkB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;oBACvC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;oBAChC,mBAAmB,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;oBAEzC,IAAI,OAAO,EAAE;wBACX,eAAe,CAAC,OAAO,CAAC,OAAO,EAAE,KAAM,CAAC,CAAC;qBAC1C;oBAED,IAAI,QAAQ,EAAE;wBACZ,sBAAsB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;qBAC1C;oBAED,OAAO,OAAO,CAAC;iBAChB,CAAC;gBAEF,OAAO,CAAC,OAAO,GAAG;oBAChB,eAAe,CAAC,OAAO,EAAE,CAAC;oBAC1B,kBAAkB,CAAC,OAAO,EAAE,CAAC;oBAC7B,mBAAmB,CAAC,OAAO,EAAE,CAAC;oBAC9B,eAAe,CAAC,OAAO,EAAE,CAAC;oBAC1B,sBAAsB,CAAC,OAAO,EAAE,CAAC;iBAClC,CAAC;gBAEF,OAAO,OAAO,CAAC;YACjB,CAAC;YAGD;AACA,kBAAa,mBAAmB;gBAGvB,OAAO,CAAC,OAAqB,EAAE,KAA8B;oBAClE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;oBACvB,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;iBACzB;gBAEM,OAAO,CAAC,OAAmB,EAAE,SAAyB;oBAC3D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;oBAC7B,IAAI,OAAO,IAAI,IAAI,EAAE;wBACnB,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;qBAC1B;oBACD,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE;wBACzC,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;qBAC1B;oBACD,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBAC1C,IAAI,KAAK,EAAE;wBACT,MAAM,eAAe,GAAG,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;wBACtD,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;wBAC9B,OAAO,eAAe,CAAC,cAAc,CAAC,GAAG,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;qBAC9D;oBAED,OAAO,OAAO,CAAC;iBAChB;gBAEM,OAAO;oBACZ,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;iBACrB;aACF;YAQD,SAAS,kBAAkB,CAAC,SAAiC;gBAC3D,OAAO,SAAS,IAAI,KAAK,CAAC,IAAI,kBAAkB,IAAI,SAAS,CAAC;YAChE,CAAC;YAED;YAEA,IAAa,gBAAgB,GAA7B,MAAa,gBAAgB;gBAW3B,YAAY,SAAqB,EAAE,UAAuB;oBACxD,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBAExB,IAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAE,CAAC;oBAC1B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAC7B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAAC,UAAU,GAAG,KAAK,CAAC,IAAK,KAAK,CAAC,EAAG,CAAC;oBAChF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,SAAU,CAAC;oBAC5C,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;iBACtB;gBAEM,QAAQ;oBACb,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;wBACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,SAAS,CAAC,yBAAyB,CAAC,QAAQ,IAAI,CAAC,iBAAiB,EAAE,CAAC,EAAE,CAAC,CAAC;wBAC9E,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;qBACvD;oBAED,OAAO,IAAI,CAAC,QAAQ,CAAC;iBACtB;gBAEM,QAAQ,CAAC,QAAiB,KAA4B;gBAEtD,QAAQ,CAA6C,KAAqB;oBAC/E,IAAI,IAAI,CAAC,UAAU,EAAE;wBACnB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,iCAAuC,CAAC;wBAC5F,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;qBACzB;iBACF;gBAEM,SAAS,CAA6C,UAAuB;oBAClF,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;wBACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;wBACpB,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,mBAAgB,CAAC;qBAC/D;oBACD,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;iBAChC;gBAEM,WAAW,CAA6C,UAAuB;oBACpF,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;oBAClC,IAAI,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;wBAC1C,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;wBACrB,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;qBAChD;iBACF;gBAEO,iBAAiB;oBACvB,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;oBAEtD,IAAI,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;wBACjD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC;qBAC9C;oBAED,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;iBACxB;aACF,CAAA;YAnEY,gBAAgB;gBAD5B,oBAAoB,EAAE;eACV,gBAAgB,CAmE5B;YAED;AACA,qBAAgB,YAAY,CAA0B,KAAmB;gBACvE,MAAM,UAAU,GAAqB,EAAE,CAAC;gBAExC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAC9C,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACzB,MAAM,SAAS,GAAG,qBAAqB,CAAI,OAAO,CAAC,CAAC;oBAEpD,IAAI,SAAS,IAAI,KAAK,CAAC,EAAE;wBACvB,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;qBAC5B;iBACF;gBAED,OAAO,UAAU,CAAC;YACpB,CAAC;;YCxaD,SAAS,cAAc,CAAC,IAAa;gBACnC,OAAQ,IAAqC,CAAC,WAAW,IAAI,KAAK,CAAC,CAAC;YACtE,CAAC;AAyBD,kBAAa,UAAU;gBAkDrB,YACE,KAAqB,EACrB,SAAoC,EACpC,SAAiC,EACjC,SAAwB,EACxB,aAAyD,EACzD,IAAmB,EACnB,OAA0C,EAC1C,UAA6B;oBAE7B,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEjC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAC1B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAE1B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAC3B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;oBAE3B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAC1B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAE1B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAE3B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;oBACvB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;oBAE1B,IAAI,CAAC,KAAK,gBAAc;oBAExB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;oBAE7B,IAAI,SAAS,IAAI,KAAK,CAAC,EAAE;wBACvB,IAAI,SAAS,IAAI,KAAK,CAAC,EAAE;;4BAEvB,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;yBAChF;wBACD,IAAI,SAAS,IAAI,KAAK,CAAC,EAAE;;4BAEvB,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;yBAChF;wBACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;wBAE3B,IAAI,CAAC,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC;wBAClC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;wBACxB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC;wBAE7B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;wBAEnB,IAAI,CAAC,MAAM,qBAA2B;wBAEtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;wBACpB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;wBAExB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;wBACpB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;wBACtB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;qBACxB;yBAAM;wBACL,IAAI,aAAa,IAAI,KAAK,CAAC,EAAE;;4BAE3B,MAAM,IAAI,KAAK,CAAC,6EAA6E,CAAC,CAAC;yBAChG;wBACD,IAAI,CAAC,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;wBAE9C,SAAyB,CAAC,WAAW,GAAG,IAAI,CAAC;wBAE9C,MAAM,IAAI,GAAG,SAAS,CAAC,WAAW,CAAC;wBACnC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;;4BAEzB,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;yBAChF;wBACD,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;wBAC7B,KAAK,IAAI,WAAW,CAAC,QAAQ,CAAC;wBAC9B,eAAe,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;wBAC/D,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;wBAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;wBAC3B,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAO,KAAK,EAAE,SAAS,CAAC,CAAC;wBAEhE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;wBAEjB,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI;4BACpB,KAAK,gBAAgB;gCACnB,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE;;oCAElB,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;iCAClF;gCAED,IAAI,CAAC,MAAM,yBAA+B;gCAE1C,MAAM,eAAe,GAAG,aAAa,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;gCAE5D,IAAI,QAAQ,GAAiC,KAAK,CAAC,CAAC;gCACpD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;oCACxB,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CACvC,KAAK,EACL,IAAI,EACJ,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC;0CACnB,QAAQ,CAAC,WAAW;0CACpB,OAAO,CAAC,KAAK,EACjB,aAAa,CACd,CAAC;oCAEF,IAAI,MAAM,IAAI,KAAK,CAAC,IAAI,oBAAoB,IAAI,MAAM,EAAE;wCACtD,QAAQ,GAAG,MAAM,CAAC,kBAAkB,CAAC,eAAe,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC;qCAC5E;iCACF;qCAAM;oCACL,MAAM,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oCACpC,QAAQ,GAAG,eAAe,CAAC,kBAAkB,CAAC,GAAG,EAAE,WAAW,EAAE,aAAa,EAAE,IAA0B,CAAC,CAAC;iCAC5G;gCAED,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;oCACvB,IAAI,KAAyC,CAAC;oCAC9C,IACE,QAAQ,CAAC,UAAU,IAAI,IAAI;wCAC3B,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC;wCAC7C,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC;yCAE7C,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAA6D,CAAC,KAAK,IAAI,KAAK,CAAC,CACpH,EACD;wCACA,IAAI,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,EAAE;4CAC3B,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC;yCAC9B;6CAAM;4CACL,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;yCACvB;qCACF;yCAAM;wCACL,MAAM,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAA4D,CAAC;wCACtH,IAAI,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,EAAE;4CAC3B,KAAK,GAAG,WAAW,CAAC,KAAqB,CAAC;yCAC3C;6CAAM;4CACL,KAAK,GAAG,EAAE,GAAG,OAAO,CAAC,KAAK,EAAE,GAAI,WAAW,CAAC,KAAsB,EAAE,CAAC;yCACtE;wCAED,IAAI,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;4CACtC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAM,CAAC,CAAC;yCACnD;qCACF;oCACD,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iCACpC;gCAED,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;gCAE5D,IAAI,CAAC,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC,mBAAmB,CACvE,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,IAAI,EACJ,IAAI,EACJ,WAAW,CACZ,CAAC;gCAEF,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;gCACvB,MAAM;4BACR,KAAK,kBAAkB;gCACrB,IAAI,CAAC,MAAM,2BAAiC;gCAE5C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;gCACpB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;gCAExB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;gCACpB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;gCACtB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;gCACvB,MAAM;4BACR;gCACE,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;yBACjE;wBAED,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;4BACzB,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;yBACpC;qBACF;iBACF;gBAEM,OAAO,gBAAgB,CAC5B,SAAiB,EACjB,aAA6C,EAC7C,IAAO,EACP,sBACA,UAAoC,QAAQ,CAAC,WAAW;oBAExD,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAA8B,CAAC;oBAC/E,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;wBACzB,UAAU,GAAG,IAAI,UAAU,CACzB,KAAK,EACL,KAAK,CAAC,EACN,KAAK,CAAC,EACN,SAAS,EACT,aAAa,EACb,IAAI,EACJ,OAAO,EACP,QAAQ,CAAC,UAAU,CACpB,CAAC;wBACF,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;qBACxC;oBACD,OAAO,UAAU,CAAC;iBACnB;gBAEM,OAAO,kBAAkB,CAC9B,SAAiB,EACjB,aAA6C,EAC7C,sBACA,aAAgC,QAAQ,CAAC,UAAU;oBAEnD,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAA8B,CAAC;oBAC/E,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;wBACzB,UAAU,GAAG,IAAI,UAAU,CACzB,KAAK,EACL,KAAK,CAAC,EACN,KAAK,CAAC,EACN,SAAS,EACT,aAAa,EACb,KAAK,CAAC,EACN,QAAQ,CAAC,WAAW,EACpB,UAAU,CACX,CAAC;wBACF,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;qBACxC;oBACD,OAAO,UAAU,CAAC;iBACnB;gBAEM,OAAO,gBAAgB,CAC5B,SAAwB,EACxB,SAAqB,EACrB;oBAEA,OAAO,IAAI,UAAU,CACnB,KAAK,EACL,SAAS,EACT,SAAS,EACT,KAAK,CAAC,EACN,KAAK,CAAC,EACN,KAAK,CAAC,EACN,QAAQ,CAAC,WAAW,EACpB,QAAQ,CAAC,UAAU,CACpB,CAAC;iBACH;gBAEM,SAAS,CAAC,KAAa;oBAC5B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,KAAK,+BAAyB;iBACpC;gBAEM,IAAI,CAAC,QAA4B;oBACtC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,sDAA0C;oBAClE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;iBAC1B;gBAEM,OAAO,CAAC,KAAqB;oBAClC,IAAI,CAAC,KAAK,4BAAsB;oBAChC,IAAI,CAAC,IAAI,CAAC,KAAK,0BAAuB,CAAC,EAAE;;wBAEvC,OAAO,IAAI,CAAC,SAAU,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;qBAC/C;oBAED,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;iBACrC;gBAEM,IAAI,CAAC,KAAqB,EAAE,KAAc;;;;;;;;;oBAS/C,KAAK,wBAA4B;oBACjC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBAC9C;4BACE,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBAChD;4BACE,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAC3C;iBACF;gBAEM,MAAM,CAAC,KAAqB;oBACjC,KAAK,0BAA8B;oBACnC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;wBACzC;4BACE,OAAO,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;wBAC3C;4BACE,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;qBACtC;iBACF;gBAEM,KAAK,CAAC,KAAqB;;oBAEhC,IAAI,CAAC,cAAe,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;iBACnC;gBAEM,OAAO,CAAC,KAAqB;;oBAElC,IAAI,CAAC,cAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;iBACrC;gBAEM,MAAM,CAAC,KAAqB;oBACjC,IAAI,CAAC,IAAI,CAAC,KAAK,qCAAkC,CAAC,IAAI,CAAC,KAAK,qCAAoC,CAAC,EAAE;wBACjG,OAAO;qBACR;oBAED,KAAK,2BAA8B;oBACnC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;4BAChC,MAAM;wBACR;4BACE,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;4BAClC,MAAM;wBACR;4BACE,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;qBAC/B;iBACF;gBAEM,MAAM,CAAC,KAAqB;oBACjC,IAAI,CAAC,IAAI,CAAC,KAAK,uCAAoC,CAAC,EAAE;wBACpD,OAAO;qBACR;oBAED,KAAK,2BAA8B;oBACnC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;4BAChC,MAAM;wBACR;4BACE,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;4BAClC,MAAM;wBACR;4BACE,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;qBAC/B;iBACF;gBAEM,QAAQ,CAAC,KAAqB;;oBAEnC,IAAI,CAAC,cAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;iBACtC;gBAEM,QAAQ,CAAC,KAAqB;;oBAEnC,IAAI,CAAC,cAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;iBACtC;gBAEM,KAAK,CAAC,KAAqB;oBAChC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;4BAC/B,MAAM;wBACR;4BACE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;qBAC9B;iBACF;gBAEM,OAAO,CAAC,KAAqB;oBAClC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;4BACjC,MAAM;wBACR;4BACE,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;qBAChC;iBACF;gBAEM,KAAK,CAAC,KAAqB;oBAChC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;4BAC/B,MAAM;wBACR;4BACE,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;4BACjC,MAAM;wBACR;4BACE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;qBAC9B;iBACF;gBAEM,iBAAiB,CAAC,YAAoB;oBAC3C,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBAC1B,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAK,CAAa,CAAC,cAAc,KAAK,YAAY,CAAY,CAAC;wBAC9F,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;4BACtB,OAAO,OAAO,CAAC,cAAc,CAAC;yBAC/B;qBACF;oBACD,OAAO,KAAK,CAAC,CAAC;iBACf;;gBAGO,iBAAiB,CAAC,KAAqB,EAAE,KAAc;oBAC7D,MAAM,MAAM,GAAG,IAAI,CAAC,KAAyB,CAAC;oBAE9C,IAAI,MAAM,CAAC,UAAU,IAAI,KAAK,CAAC,EAAE;wBAC/B,IACE,KAAK,IAAI,IAAI;4BACb,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC;4BAC1B,KAAK,CAAC,UAAU,KAAK,QAAQ,CAAC,WAAW,EACzC;4BACA,MAAM,CAAC,UAAU,GAAG,EAAE,GAAG,KAAK,CAAC,UAAU,EAAE,CAAC;yBAC7C;6BAAM,IAAI,IAAI,CAAC,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;4BAClD,MAAM,CAAC,UAAU,GAAG,EAAE,CAAC;yBACxB;wBAED,IAAI,MAAM,CAAC,UAAU,IAAI,KAAK,CAAC,EAAE;4BAC/B,MAAM,CAAC,UAAU,GAAG,QAAQ,CAAC,WAAW,CAAC;yBAC1C;6BAAM;4BACL,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;gCACtC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC;6BACtC;yBACF;qBACF;oBAED,IAAI,CAAC,KAAK,4CAA2C,CAAC,EAAE;wBACtD,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;wBACjC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,IAAI,CAAC,KAAK,sBAAoB,CAAC,EAAE;wBACpC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,KAAK,wBAA4B;oBAEjC,IAAI,CAAC,KAAK,sBAAoB;oBAE9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBAC7B,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;oBAEjC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;wBACzB,MAAM,GAAG,GAAI,IAAI,CAAC,cAAuC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACzE,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;4BACrB,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;yBAC7E;qBACF;oBAED,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBAC5C;gBAEO,mBAAmB,CAAC,KAAqB,EAAE,KAAc;oBAC/D,IAAI,CAAC,IAAI,CAAC,KAAK,sBAAoB,CAAC,EAAE;wBACpC,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,EAAE;4BACxB,OAAO,aAAa,CAAC,IAAI,CAAC;yBAC3B;wBAED,KAAK,wBAA4B;wBACjC,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBAEhC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BACd,OAAO,IAAI,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;yBAClE;qBACF;yBAAM;wBACL,KAAK,wBAA4B;qBAClC;oBAED,IAAI,CAAC,KAAK,sBAAoB;oBAE9B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBAE7B,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;wBACzB,MAAM,GAAG,GAAI,IAAI,CAAC,cAAuC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACzE,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;4BACrB,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;yBAC7D;qBACF;oBAED,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBACpB,OAAO,aAAa,CAAC,IAAI,CAAC;iBAC3B;gBAEO,aAAa,CAAC,KAAqB,EAAE,KAAc;oBACzD,IAAI,KAAK,IAAI,KAAK,CAAC,EAAE;wBACnB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;qBAC/C;oBAED,IAAI,CAAC,KAAK,4CAA2C,CAAC,EAAE;wBACtD,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBAChC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,IAAI,CAAC,KAAK,sBAAoB,CAAC,EAAE;wBACpC,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,iCAA2B,CAAC,EAAE;4BACnE,OAAO,aAAa,CAAC,IAAI,CAAC;yBAC3B;wBAED,KAAK,wBAA4B;wBACjC,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBAEhC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BACd,OAAO,IAAI,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;yBAClE;qBACF;yBAAM;wBACL,KAAK,wBAA4B;qBAClC;oBAED,IAAI,CAAC,IAAI,CAAC,KAAK,mCAA6B,CAAC,EAAE;wBAC7C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;qBACpB;oBAED,IAAI,CAAC,KAAK,sBAAoB;oBAE9B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBAC7B,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;oBAEhC,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;iBAC3C;gBAEO,YAAY,CAAC,KAAqB,EAAE,KAAa;oBACvD,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBAC1B,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;wBAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;4BAC/B,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;yBACjC;qBACF;iBACF;gBAEO,eAAe,CAAC,KAAqB,EAAE,KAAa;oBAC1D,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAgC,CAAC;oBAErC,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;wBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;4BAC/B,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;4BACzC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCACd,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;oCACpB,KAAK,GAAG,EAAE,CAAC;iCACZ;gCACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;6BAClB;yBACF;qBACF;oBAED,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBACpB,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBACD,OAAO,IAAI,yBAAyB,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBACxE;gBAEO,OAAO,CAAC,KAAqB;oBACnC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;wBACvB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBAChC;oBACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,uCAAmC;oBAC1D,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACjC;gBAEO,mBAAmB,CAAC,KAAqB;oBAC/C,IAAI,CAAC,IAAI,CAAC,KAAK,wBAAsB,CAAC,EAAE;wBACtC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,KAAK,wBAAsB;oBAEhC,KAAK,0BAA8B;oBACnC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;oBAE/B,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC3B,MAAM,GAAG,GAAI,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;wBAC3E,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;4BACrB,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;yBACvE;qBACF;oBAED,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;iBACtC;gBAEO,qBAAqB,CAAC,KAAqB;oBACjD,IAAI,CAAC,IAAI,CAAC,KAAK,wBAAsB,CAAC,EAAE;wBACtC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,KAAK,wBAAsB;oBAEhC,KAAK,0BAA8B;oBACnC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;oBAE/B,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC3B,MAAM,GAAG,GAAI,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;wBAC3E,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;4BACrB,OAAO,IAAI,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;yBAC/D;qBACF;oBAED,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;oBACtB,OAAO,aAAa,CAAC,IAAI,CAAC;iBAC3B;gBAEO,eAAe,CAAC,KAAqB;oBAC3C,IAAI,CAAC,IAAI,CAAC,KAAK,wBAAsB,CAAC,EAAE;wBACtC,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBAED,IAAI,CAAC,KAAK,wBAAsB;oBAEhC,KAAK,0BAA8B;oBACnC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;oBAE/B,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;iBACtC;gBAEO,cAAc,CAAC,KAAqB;oBAC1C,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBAC1B,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,KAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;4BAC7C,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;yBAC5B;qBACF;oBACD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBACvB;gBAEO,iBAAiB,CAAC,KAAqB;oBAC7C,IAAI,KAAK,GAAiC,KAAK,CAAC,CAAC;oBACjD,IAAI,IAAgC,CAAC;oBAErC,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,KAAK,IAAI,CAAC,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;4BAChD,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;4BACpC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gCACd,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;oCACpB,KAAK,GAAG,EAAE,CAAC;iCACZ;gCACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;6BAClB;yBACF;qBACF;oBAED,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;wBACpB,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;wBAC3B,OAAO,aAAa,CAAC,IAAI,CAAC;qBAC3B;oBACD,OAAO,IAAI,yBAAyB,CAAC,KAAK,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBAC/E;gBAEO,SAAS,CAAC,KAAqB;oBACrC,QAAQ,IAAI,CAAC,MAAM;wBACjB;4BACE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;4BACpB,MAAM;wBACR;4BACE,IAAI,CAAC,IAAI,CAAC,KAAK,mCAA6B,CAAC,EAAE;gCAC7C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;6BACrB;qBACJ;oBACD,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;wBACzB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBAClC;oBAED,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,4DAAwD;oBAChF,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACnC;;;gBAIO,mBAAmB,CAAC,KAAqB;oBAC/C,KAAK,2BAA8B;oBACnC,IAAI,CAAC,KAAK,wBAAsB;oBAEhC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC/B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAEhC,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC1B,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBAChE;oBAED,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;oBAE9B,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;wBAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACnC;oBAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,6CAAwC;oBAC/D,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACpC;gBAEO,qBAAqB,CAAC,KAAqB;oBACjD,KAAK,2BAA8B;oBACnC,IAAI,CAAC,KAAK,wBAAsB;oBAEhC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAEhC,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC1B,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBAChE;oBAED,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;wBAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACnC;oBAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,6CAAwC;oBAC/D,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACpC;gBAEO,eAAe,CAAC,KAAqB;oBAC3C,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,0BAAuB,CAAC,IAAI,KAAK,mCAAkC,CAAC,EAAE;wBACpF,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBAChC;yBAAM;wBACL,KAAK,2BAA8B;wBACnC,IAAI,CAAC,KAAK,wBAAsB;wBAEhC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;wBAC/B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;wBAEhC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;wBAE9B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,6CAAwC;wBAC/D,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;qBACpC;iBACF;gBAEO,mBAAmB,CAAC,KAAqB;oBAC/C,KAAK,2BAA8B;oBACnC,IAAI,CAAC,KAAK,yBAAsB;oBAEhC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAChC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAEjC,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC1B,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBAChE;oBAED,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;oBAE9B,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;wBAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACnC;oBAED,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,oEAA8D;oBACtF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACpC;gBAEO,qBAAqB,CAAC,KAAqB;oBACjD,KAAK,2BAA8B;oBACnC,IAAI,CAAC,KAAK,yBAAsB;oBAEhC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAEhC,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;wBAC1B,IAAI,CAAC,cAAuC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBAChE;oBAED,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;wBAC1B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACnC;oBAED,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,oEAA8D;oBACtF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACpC;gBAEO,eAAe,CAAC,KAAqB;oBAC3C,KAAK,2BAA8B;oBACnC,IAAI,CAAC,KAAK,yBAAsB;oBAEhC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAChC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAEjC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;oBAE9B,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,oEAA8D;oBACtF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBACpC;gBAEO,iBAAiB,CAAC,KAAqB;oBAC7C,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;wBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;4BAC/B,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBAC9B;qBACF;iBACF;gBAEO,iBAAiB,CAAC,KAAqB;oBAC7C,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,KAAK,IAAI,CAAC,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;4BAChD,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBAC9B;qBACF;iBACF;;;gBAIO,kBAAkB,CAAC,KAAqB;oBAC9C,IAAI,CAAC,IAAI,CAAC,KAAK,yBAAsB,CAAC,EAAE;wBACtC,OAAO;qBACR;oBAED,IAAI,CAAC,KAAK,uBAAoB;;oBAE9B,IAAI,CAAC,SAAU,CAAC,OAAO,CAAC,IAAI,CAAC,KAAM,CAAC,CAAC;iBACtC;gBAEO,cAAc,CAAC,KAAqB;oBAC1C,IAAI,CAAC,KAAK,uBAAoB;;oBAE9B,IAAI,CAAC,KAAM,CAAC,YAAY,CAAC,IAAI,CAAC,QAAS,CAAC,CAAC;iBAC1C;gBAEO,oBAAoB,CAAC,KAAqB;oBAChD,IAAI,CAAC,IAAI,CAAC,KAAK,2BAAwB,CAAC,EAAE;wBACxC,OAAO;qBACR;oBAED,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,4CAAsC;;oBAE9D,IAAI,CAAC,SAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAM,CAAC,CAAC;iBACnC;gBAEO,gBAAgB,CAAC,KAAqB;oBAC5C,IAAI,CAAC,IAAI,CAAC,KAAK,2BAAwB,CAAC,EAAE;wBACxC,OAAO,KAAK,CAAC;qBACd;oBAED,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,4CAAsC;;oBAE9D,IAAI,CAAC,KAAM,CAAC,MAAM,EAAE,CAAC;oBACrB,IAAI,CAAC,KAAM,CAAC,MAAM,EAAE,CAAC;oBAErB,IAAI,CAAC,IAAI,CAAC,KAAK,8BAAwB,CAAC,EAAE;wBACxC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,sDAA0C;;wBAElE,IAAI,IAAI,CAAC,SAAU,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;4BAC1C,IAAI,CAAC,KAAK,uBAAmB;4BAC7B,OAAO,IAAI,CAAC;yBACb;qBACF;oBACD,OAAO,KAAK,CAAC;iBACd;gBAEO,kBAAkB,CAAC,KAAqB;oBAC9C,KAAK,0BAA6B;oBAClC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;;wBAEzB,IAAI,CAAC,cAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrC;iBACF;gBAEO,oBAAoB,CAAC,KAAqB;oBAChD,KAAK,0BAA6B;oBAClC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;;wBAEzB,IAAI,CAAC,cAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACrC;oBAED,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;wBAC/B,KAAK,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;4BACpC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;yBAC7B;qBACF;iBACF;gBAEO,cAAc,CAAC,KAAqB;oBAC1C,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;oBAC7B,IAAI,WAAW,KAAK,KAAK,CAAC,EAAE;wBAC1B,MAAM,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC;wBAC/B,KAAK,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;4BACpC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;yBAC7B;qBACF;iBACF;;YAp5BuB,iBAAM,GAAgC,IAAI,OAAO,EAAE,CAAC;YAw5B9E,SAAS,eAAe,CACtB,SAAqB,EACrB,WAAwB,EACxB,KAAqB,EACrB,QAAoB;gBAEpB,MAAM,SAAS,GAAG,QAAQ,CAAC,UAAU,IAAI,KAAK,CAAC,CAAC;gBAChD,MAAM,SAAS,GAAiC,SAAS,GAAG,QAAQ,CAAC,UAA0C,GAAG,EAAE,CAAC;gBACrH,MAAM,SAAS,GAAG,WAAW,CAAC,SAA2D,CAAC;gBAC1F,MAAM,eAAe,GAAG,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;gBAC9D,MAAM,QAAQ,GAAG,CAAC,KAAK,4BAAmC,CAAC,CAAE;gBAE7D,MAAM,EAAE,MAAM,EAAE,GAAG,eAAe,CAAC;gBACnC,IAAI,IAAY,CAAC;gBACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;oBAC/B,IAAI,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;oBAE1B,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE;wBAC7B,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,YAAY,CAChC,SAAS,EACT,KAAK,EACL,QAAQ,GAAG,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,KAAK,GAAG,QAAQ,EAC/D,IAAI,EACJ,SAAS,CAAC,IAAI,CAAC,CAAC,QAAQ,CACzB,CAAC;qBACH;iBACF;gBAED,IAAI,CAAC,QAAQ,EAAE;oBACb,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,EAAE;wBAC7C,UAAU,EAAE,KAAK;wBACjB,KAAK,EAAE,SAAS;qBACjB,CAAC,CAAC;iBACJ;YACH,CAAC;YAED,SAAS,iBAAiB,CAA2C,KAAqB,EAAE,QAAoB;gBAC9G,IAAI,QAAQ,CAAC,OAAO,KAAK,IAAI,IAAI,CAAC,KAAK,8BAAqC,CAAC,EAAE;oBAC7E,OAAO,QAAgC,CAAC;iBACzC;gBAED,OAAO,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,KAA6B,CAAC;YAC3E,CAAC;;YCphCM,MAAM,UAAU,GAAG,EAAE,CAAC,eAAe,CAAa,YAAY,CAAC,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;YAEhH;AACA,kBAAa,SAAS;gBACb,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,OAAO,YAAY,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACrE;gBAEM,QAAQ,CACb,IAAW,EACX,SAAqB,EACrB,OAAwB,EACxB,kCACA,WAAoB;oBAEpB,KAAK,GAAG,KAAK,KAAK,KAAK,CAAC,kBAAyB,KAAK,CAAC;oBACvD,MAAM,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAC5C,SAAS,EACT,OAAyB,EACzB,IAAI,EACJ,KAAK,CACN,CAAC;oBACF,IAAI,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,wBAA4B,WAAW,CAAC,CAAC;oBACzE,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,UAAU,CAAC,MAAM,CAAC,KAAK,0BAA6B,CAAC;qBACtD;yBAAM;wBACL,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,0BAA6B,CAAC;qBACrG;oBACD,OAAO,IAAI,CAAC;iBACb;gBAEM,UAAU,CAAC,SAAqB,EAAE;oBACvC,MAAM,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAAC,SAAS,GAAG,KAAK,CAAC,IAAK,KAAK,CAAC,EAAG,CAAC;oBAChF,UAAU,CAAC,MAAM,CAAC,KAAK,0BAA6B,CAAC;oBACrD,OAAO,UAAU,CAAC,MAAM,CAAC,KAAK,yBAA6B,CAAC;iBAC7D;aACF;;YCzBD,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,EAAE,GAAG,QAAQ,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;YACvF,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,QAAQ,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;AAapF,kBAAa,eAAe;gBAc1B,YACE,MAAyB,EACzB,SAAqB;oBAErB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,MAAM,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;wBACzB,IAAI,SAAS,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;4BAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;yBAC1C;6BAAM;4BACL,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;yBAC5B;wBACD,YAAY,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBACnE,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;qBACzB;yBAAM,IAAI,SAAS,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;wBACrC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;wBAC3B,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,KAAK,CAAM,CAAC;qBACvC;yBAAM;wBACL,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;qBAC3C;oBACD,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC,GAAG,MAAM,CAAC,QAAQ,wBAAgC;oBAE3F,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;oBACxD,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC,UAAU,CAAC,MAAM,CAAY,CAAC;oBAErD,IAAI,CAAC,SAAS,GAAG,qBAAqB,CAAC,MAAM,CAAC,MAAM,CAAC,SAA+B,CAAC;0BACjF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAA0B;0BAC7D,MAAM,CAAC,SAAkC,CAAC;oBAE9C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAC3C,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAA2B,EAChC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,QAAkB,CACxB,CAAC;oBACF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAChD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAChD,IAAI,MAAM,CAAC,iBAAiB,KAAK,IAAI,EAAE;wBACrC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;qBAC9D;yBAAM;wBACL,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;qBACrC;oBACD,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;oBAC/B,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;oBACjC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;iBACjC;gBAEM,QAAQ,CAAC,UAA2B;oBACzC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBACvE,MAAM,KAAK,GAAG,QAAQ,4BAAgC;oBAEtD,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,IAAI,UAAU,IAAI,KAAK,CAAC,IAAI,UAAU,CAAC,IAAI,EAAE;4BAC3C,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;yBAC3E;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,UAAU,EAAE,SAAS,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;yBACxH;qBACF;yBAAM;wBACL,IAAI,UAAU,IAAI,KAAK,CAAC,IAAI,UAAU,CAAC,IAAI,EAAE;4BAC3C,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;yBAClH;6BAAM;4BACL,MAAM,kBAAkB,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;4BACnF,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,kBAAkB,EAAE,SAAS,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;yBAChI;qBACF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,UAAU,CAAC,UAA2B;oBAC3C,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;oBACtD,MAAM,KAAK,GAAG,QAAQ,2BAA+B;oBAErD,IAAI,IAAI,CAAC,IAAI,EAAE;wBACb,IAAI,UAAU,IAAI,KAAK,CAAC,IAAI,UAAU,CAAC,IAAI,EAAE;4BAC3C,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC,UAAU,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;yBACpD;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,UAAU,EAAE,SAAS,CAAC,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;yBACjG;qBACF;yBAAM;wBACL,IAAI,UAAU,IAAI,KAAK,CAAC,IAAI,UAAU,CAAC,IAAI,EAAE;4BAC3C,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;yBAC3F;6BAAM;4BACL,MAAM,kBAAkB,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;4BACnF,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,kBAAkB,EAAE,SAAS,CAAC,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;yBACzG;qBACF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;0DACF;AAED,kBAAa,OAAO;gBA4BlB,YAAY,YAAwB,EAAE,CAAC,eAAe,EAAE;oBACtD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;oBAC3B,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;oBAE/B,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBAEzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;oBAEpB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAE,CAAC;oBAEtB,YAAY,CAAC,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBAC1D;gBAvCD,IAAW,SAAS;oBAClB,OAAO,IAAI,CAAC,UAAU,CAAC;iBACxB;gBACD,IAAW,UAAU;oBACnB,OAAO,IAAI,CAAC,WAAW,CAAC;iBACzB;gBACD,IAAW,UAAU;oBACnB,OAAO,IAAI,CAAC,WAAW,CAAC;iBACzB;gBACD,IAAW,IAAI;oBACb,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,EAAE;wBACxB,IAAI,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;4BACvB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;yBACxC;wBACD,OAAO,IAAI,CAAC,IAAI,CAAC;qBAClB;oBACD,OAAO,IAAI,CAAC,KAAK,CAAC;iBACnB;gBAwBM,QAAQ,CAAC,GAAG,MAA0D;oBAC3E,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,CAAC;oBACnC,OAAO,IAAI,CAAC;iBACb;gBAEM,GAAG,CAAC,MAA6B;oBACtC,IAAI,CAAC,IAAI,GAAG,IAAI,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBAExD,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,KAAK,EAAE,CAAC;qBACd;oBAED,OAAO,IAAI,CAAC;iBACb;gBAEM,KAAK,CAAC,OAA2C,IAAI,CAAC,IAAI;oBAC/D,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE;wBAClB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;qBACjD;oBAED,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAEhB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;qBAC1B;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBAC7E;oBAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAE1C,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;qBACrC;yBAAM;wBACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBAC5E;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,IAAI,CAAC,OAA2C,IAAI,CAAC,KAAK;oBAC/D,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE;wBACrC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BAClB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;yBACzB;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;yBAC5E;wBAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAEvC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;4BAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;yBACpC;6BAAM;4BACL,IAAI,CAAC,IAAI,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;yBAC3E;qBACF;oBAED,OAAO,IAAI,CAAC,IAAI,CAAC;iBAClB;gBAEM,IAAI;oBACT,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,EAAmB,CAAC;iBAC1C;gBAEO,aAAa,CAAC,IAA4B;oBAChD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACpC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;oBAClB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;oBACxB,IAAI,QAAQ,CAAC,OAAO,EAAE;wBAAE,UAAU,EAAE,CAAC;qBAAE;iBACxC;gBAEO,YAAY,CAAC,IAAqB;oBACxC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;oBACvB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,kBAAkB,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;oBACvD,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,IAAiB,CAAC,CAAC;oBAC/D,IAAI,QAAQ,CAAC,OAAO,EAAE;wBAAE,UAAU,EAAE,CAAC;qBAAE;oBACvC,OAAO,aAAa,CAAC,IAAI,CAAC;iBAC3B;gBAEO,YAAY,CAAC,IAAqB;oBACxC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;oBACxB,IAAI,QAAQ,CAAC,OAAO,EAAE;wBAAE,SAAS,EAAE,CAAC;qBAAE;iBACvC;gBAEO,WAAW,CAAC,IAAqB;oBACvC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBACzC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;oBACpB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,IAAiB,CAAC,CAAC;oBAC/D,IAAI,QAAQ,CAAC,OAAO,EAAE;wBAAE,SAAS,EAAE,CAAC;qBAAE;oBACtC,OAAO,aAAa,CAAC,IAAI,CAAC;iBAC3B;gBAEO,aAAa,CAAC,IAAqB,EAAE,IAAY,EAAE,MAAiB;oBAC1E,MAAM,GAAG,eAAe,IAAI,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;oBACvD,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;iBAC3G;0CACF;YACA,QAAQ,CAAC,MAAsD,CAAC,OAAO,GAAG,OAAO,CAAC;AAEnF,kBAAa,eAAe,8BAAG,EAAE,CAAC,eAAe,CAAkB,iBAAiB,CAAC,CAAC,SAAS,EAAE;;YC/OjG,MAAMJ,OAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAOpC,qBAAgB,mBAAmB,CAAuB,eAAsB;gBAC9E,OAAO,SAAS,SAAS,CAAiB,MAA6D;;oBAErG,MAAM,eAAe,GAAG,UAAS,GAAG,IAAe;;;wBAGjD,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;wBACrC,QAAQ,CAAC,eAAe,GAAG,eAAe,CAAC;wBAC3C,OAAO,QAAQ,CAAC;qBACiD,CAAC;;oBAEpE,eAAe,CAAC,QAAQ,GAAG,SAAS,QAAQ,CAAC,SAAqB;wBAChE,OAAO,YAAY,CAAC,SAAS,CAAC,oBAAoB,EAAE,eAAe,CAAC,CAAC,QAAQ,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAC;qBAChH,CAAC;;;;oBAIF,MAAM,aAAa,GAAG,MAAM,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC;oBAC/D,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,CAAC,OAAO,CAAC,IAAI;wBAC1E,OAAO,CAAC,cAAc,CAAC,eAAe,EAAE,IAAI,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;qBACpE,CAAC,CAAC;oBACH,OAAO,eAAe,CAAC;iBACxB,CAAC;YACJ,CAAC;YAED;AACA,kBAAa,QAAQ;gBAOnB,YAAY,oBAA4C;oBACtD,MAAM,MAAM,GAAsD,IAAI,CAAC,oBAAoB,GAAG,EAAE,CAAC;oBACjG,oBAAoB,CAAC,OAAO,CAAC,IAAI;wBAC/B,MAAM,CAAC,IAAI,CAAC,eAAgB,CAAC,GAAG,IAAI,CAAC;qBACtC,CAAC,CAAC;iBACJ;gBAEM,OAAO,QAAQ,CAAC,SAAqB;oBAC1C,OAAO,YAAY,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACpE;;gBAGM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,OAAyB,EAAE,UAA8B,EAAE,IAAY,EAAE,KAA+B;oBACxM,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAClF,MAAM,kBAAkB,GAAG,UAAU,CAAC,YAAY,CAAC;oBACnD,MAAM,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,CAAC;oBAEvD,IAAI,OAAO,CAAC,MAAM,KAAK,kBAAkB,CAAC,MAAM,EAAE;wBAChD,IAAI,OAAO,CAAC,MAAM,GAAG,kBAAkB,CAAC,MAAM,EAAE;4BAC9C,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;yBAC1B;6BAAM;4BACL,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;yBAC1B;qBACF;oBACD,IAAI,YAAoC,CAAC;oBACzC,IAAI,MAAa,CAAC;oBAClB,IAAI,OAA6B,CAAC;oBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAChD,YAAY,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;wBACrC,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;wBAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BACrD,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;4BAC1B,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;yBACpG;qBACF;oBAED,IAAI,IAAI,EAAE;wBACR,MAAM,qBAAqB,GAAG,UAAU,CAAC,UAAU,CAAC;wBAEpD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;4BAC9D,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;4BACnC,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;yBAClG;qBACF;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;;YApDD;YACA;YACuB,eAAM,GAAgB,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC;AAqD3E,qBAAgB,gBAAgB,CAAQ,MAAyB,EAAE,SAAgB,EAAE,WAAwB;gBAC3G,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;oBACjC,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,CAAsC,CAAC;iBAClF;gBACD,OAAO,SAAmC,CAAC;YAC7C,CAAC;AAED,qBAAgB,UAAU,CAAC,UAAuB,EAAE,OAAiB;gBACnE,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,YAAY,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;iBAAE;gBACtF,IAAI,UAAU,CAAC,QAAQ,IAAI,KAAK,CAAC,EAAE;oBACjC,UAAU,CAAC,QAAQ,GAAG,CAAC,OAAO,CAAC,CAAC;iBACjC;qBAAM;oBACL,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACnC;gBACD,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;iBAAE;YACzC,CAAC;AAED,qBAAgB,YAAY,CAAC,UAAuB,EAAE,SAAsB;gBAC1E,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,cAAc,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;iBAAE;gBACxF,IAAI,UAAU,CAAC,WAAW,IAAI,KAAK,CAAC,EAAE;oBACpC,UAAU,CAAC,WAAW,GAAG,CAAC,SAAS,CAAC,CAAC;iBACtC;qBAAM;oBACL,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBACxC;gBACD,IAAI,MAAM,CAAC,OAAO,EAAE;oBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;iBAAE;YACzC,CAAC;AAED,qBAAgB,SAAS,CAAC,eAAuB;gBAC/C,IAAK,eAA+C,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;oBAC9E,OAAQ,eAA8C,CAAC,cAAc,CAAC;iBACvE;gBACD,OAAO,eAAe,CAAC;YACzB,CAAC;YAID,IAAa,mBAAmB;YADhC;YACA,MAAa,mBAAmB;gBAGvB,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAoC;oBACzJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,qBAAqB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC7F,SAAS,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,EAAkB,CAAC,GAAG,WAAW,CAAC,KAAc,CAAC;oBAC/E,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YARY,mBAAmB;gBAF/B,mBAAmB,wBAAqC;;eAE5C,mBAAmB,CAQ/B;YAID,IAAa,qBAAqB;YADlC;YACA,MAAa,qBAAqB;gBAGzB,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAa,EAAE,WAAuC;oBACtJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,uBAAuB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC/F,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,IAAK,EAAE,IAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;oBAC/G,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAS,gBAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;oBACzE,MAAM,oBAAoB,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,oBAAoB,CAAC;oBACzE,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;oBAEnD,MAAM,UAAU,GAAG,UAAU,CAAC,gBAAgB,CAC5C,SAAS,EACT,OAAO,EACP,MAAM,EACN,KAAK,EACL,WAAuC,CACxC,CAAC;oBAEF,IAAI,OAA6B,CAAC;oBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC1D,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;wBAC/B,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;qBACjG;oBAED,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBAErC,SAAS,CAAC,OAAO,EAAE,CAAC;oBACpB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YA7BY,qBAAqB;gBAFjC,mBAAmB,2BAAwC;;eAE/C,qBAAqB,CA6BjC;YAID,IAAa,uBAAuB;YADpC;YACA,MAAa,uBAAuB;gBAG3B,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAa,EAAE,WAAyC;oBACxJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,yBAAyB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACjG,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;oBACnF,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAS,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC3E,MAAM,oBAAoB,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,oBAAoB,CAAC;oBACzE,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;oBAEnD,MAAM,UAAU,GAAG,UAAU,CAAC,kBAAkB,CAC9C,SAAS,EACT,OAAO,EACP,KAAK,CACN,CAAC;oBAEF,IAAI,OAA6B,CAAC;oBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC1D,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;wBAC/B,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;qBACjG;oBAED,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBAErC,SAAS,CAAC,OAAO,EAAE,CAAC;oBACpB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YA3BY,uBAAuB;gBAFnC,mBAAmB,6BAA0C;;eAEjD,uBAAuB,CA2BnC;YAID,IAAa,0BAA0B;YADvC;YACA,MAAa,0BAA0B;gBAMrC,YAAY,eAAiC;oBAC3C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAa,EAAE,WAAuC,EAAE,KAA+B;oBACvL,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACpG,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,GAAG,EAAE,WAAW,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;oBACnF,MAAM,SAAS,GAAG,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC,uBAAuB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,CAAC;oBAC/I,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAS,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC3E,MAAM,oBAAoB,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,oBAAoB,CAAC;oBACzE,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;oBAEnD,MAAM,UAAU,GAAG,UAAU,CAAC,kBAAkB,CAC9C,SAAS,EACT,OAAO,EACP,KAAK,EACL,WAAW,CAAC,KAAK,IAAI,KAAK,CAAC;0BACvB,QAAQ,CAAC,UAAU;0BACnB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CACnC,CAAC;oBAEF,IAAI,WAAW,CAAC,IAAI,EAAE;wBACpB,MAAM,WAAW,GAAG,UAAU,CAAC,WAAY,CAAC;wBAC3C,SAAuD,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;qBACpG;oBAED,IAAI,OAA6B,CAAC;oBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC1D,OAAO,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;wBAC/B,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;qBACjG;oBAED,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBAErC,SAAS,CAAC,OAAO,EAAE,CAAC;oBACpB,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YA1CwB,iCAAM,GAAgB,CAAC,gBAAgB,CAAC,CAAC;YADrD,0BAA0B;gBAFtC,mBAAmB,sCAAmD;;eAE1D,0BAA0B,CA2CtC;YAID,IAAa,kBAAkB;YAD/B;YACA,MAAa,kBAAkB;gBAO7B,YAAY,MAAyB,EAAE,eAAiC;oBACtE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAa,EAAE,WAA0C;oBACzJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,oBAAoB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC5F,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;oBACnB,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAY,CAAC;oBACnD,MAAM,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC;oBAE5C,IAAI,gBAAwC,CAAC;oBAC7C,IAAI,IAA0B,CAAC;oBAC/B,IAAI,OAAmB,CAAC;oBACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;wBAC1D,gBAAgB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;wBACxC,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,CAAC,IAAI,6BAAgC,CAAC;wBAC3F,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC,eAAe,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;wBAChG,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;qBACjC;oBACD,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YA5BwB,yBAAM,GAAgB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;YADxE,kBAAkB;gBAF9B,mBAAmB,8BAA2C;;eAElD,kBAAkB,CA6B9B;YAID,IAAa,mBAAmB;YADhC;YACA,MAAa,mBAAmB;gBAO9B,YAAY,MAAyB,EAAE,eAAiC;oBACtE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAoC;oBACzJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,qBAAqB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC7F,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,wBAA0B,CAAC;oBACtF,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;oBACjG,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YAlBwB,0BAAM,GAAgB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;YADxE,mBAAmB;gBAF/B,mBAAmB,wBAAqC;;eAE5C,mBAAmB,CAmB/B;YAID,IAAa,kBAAkB;YAD/B;YACA,MAAa,kBAAkB;gBAM7B,YAAY,MAAyB;oBACnC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;iBACtB;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAmC;oBACxJ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,oBAAoB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBAC5F,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,mBAAoB,CAAC;oBAChF,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;oBAC1D,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YAhBwB,yBAAM,GAAgB,CAAC,iBAAiB,CAAC,CAAC;YADtD,kBAAkB;gBAF9B,mBAAmB,uBAAoC;;eAE3C,kBAAkB,CAiB9B;YAID,IAAa,4BAA4B;YADzC;YACA,MAAa,4BAA4B;gBAOvC,YAAY,MAAyB,EAAE,eAAiC;oBACtE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAsC;oBAC3J,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,8BAA8B,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACtG,IAAI,OAAyD,CAAC;oBAC9D,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,2BAA4B,CAAC;oBACxF,IAAI,IAAI,CAAC,OAAO,EAAE;wBAChB,OAAO,GAAG,IAAI,yBAAyB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;qBACrI;yBAAM;wBACL,OAAO,GAAG,IAAI,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;qBAC5J;oBACD,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YAvBwB,mCAAM,GAAgB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;YADxE,4BAA4B;gBAFxC,mBAAmB,0BAAuC;;eAE9C,4BAA4B,CAwBxC;YAID,IAAa,uBAAuB;YADpC;YACA,MAAa,uBAAuB;gBAOlC,YAAY,MAAyB,EAAE,eAAiC;oBACtE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAwC;oBAC7J,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,yBAAyB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACjG,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,6BAAgC,WAAW,CAAC,IAAI,CAAC,CAAC;oBAC/G,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;oBACtH,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YAlBwB,8BAAM,GAAgB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;YADxE,uBAAuB;gBAFnC,mBAAmB,4BAAyC;;eAEhD,uBAAuB,CAmBnC;YAID,IAAa,uBAAuB;YADpC;YACA,MAAa,uBAAuB;gBAOlC,YAAY,MAAyB,EAAE,eAAiC;oBACtE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;iBACxC;gBAEM,MAAM,CAAC,KAAqB,EAAE,GAAS,EAAE,OAAuB,EAAE,UAAuB,EAAE,MAAmB,EAAE,WAAwC;oBAC7J,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,CAAC,yBAAyB,EAAE,QAAQ,EAAEA,OAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;qBAAE;oBACjG,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,uBAAyB,CAAC;oBACrF,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;oBACxH,UAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;oBAChC,IAAI,MAAM,CAAC,OAAO,EAAE;wBAAE,MAAM,CAAC,KAAK,EAAE,CAAC;qBAAE;iBACxC;aACF,CAAA;YAlBwB,8BAAM,GAAgB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;YADxE,uBAAuB;gBAFnC,mBAAmB,4BAAyC;;eAEhD,uBAAuB,CAmBnC;;kBC9ZY,4BAA4B,2CAAG,eAA4B,EAAC;AACzE,kBAAa,sBAAsB,qCAAG,SAAsB,EAAC;AAC7D,kBAAa,qBAAqB,oCAAG,QAAqB,EAAC;YAE3D;;;;;;AAMA,YAAO,MAAM,iBAAiB,GAAG;gBAC/B,4BAA4B;gBAC5B,sBAAsB;gBACtB,qBAAqB;aACtB,CAAC;AAEF,kBAAa,cAAc,6BAAG,EAAe,EAAC;AAC9C,kBAAa,gBAAgB,+BAAG,IAAiB,EAAC;AAClD,kBAAa,kBAAkB,iCAAG,MAAmB,EAAC;AACtD,kBAAa,uBAAuB,sCAAG,WAAwB,EAAC;AAChE,kBAAa,gBAAgB,+BAAG,IAAiB,EAAC;AAClD,kBAAa,kCAAkC,iDAAG,sBAAmC,EAAC;AACtF,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,kCAAkC,iDAAG,sBAAmC,EAAC;AACtF,kBAAa,iCAAiC,gDAAG,qBAAkC,EAAC;AACpF,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,iCAAiC,gDAAG,qBAAkC,EAAC;AACpF,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,iCAAiC,gDAAG,qBAAkC,EAAC;AACpF,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;YAExF;;;;;;AAMA,kBAAa,gBAAgB,+BAAG;gBAC9B,cAAc;gBACd,gBAAgB;gBAChB,kBAAkB;gBAClB,uBAAuB;gBACvB,gBAAgB;gBAChB,kCAAkC;gBAClC,mCAAmC;gBACnC,kCAAkC;gBAClC,iCAAiC;gBACjC,mCAAmC;gBACnC,iCAAiC;gBACjC,mCAAmC;gBACnC,mCAAmC;gBACnC,iCAAiC;aAClC,EAAC;AAEF,kBAAa,+BAA+B,8CAAG,mBAAgC,EAAC;AAChF,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,iCAAiC,gDAAG,qBAAkC,EAAC;AACpF,kBAAa,wCAAwC,uDAAG,4BAAyC,EAAC;AAClG,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,8BAA8B,6CAAG,kBAA+B,EAAC;AAC9E,kBAAa,mCAAmC,kDAAG,uBAAoC,EAAC;AACxF,kBAAa,8BAA8B,6CAAG,kBAA+B,EAAC;AAC9E,kBAAa,+BAA+B,8CAAG,mBAAgC,EAAC;AAChF,kBAAa,sCAAsC,qDAAG,0BAAuC,EAAC;YAE9F;;;;;;;;;;;;;AAaA,YAAO,MAAM,gBAAgB,GAAG;gBAC9B,mCAAmC;gBACnC,mCAAmC;gBACnC,+BAA+B;gBAC/B,8BAA8B;gBAC9B,wCAAwC;gBACxC,+BAA+B;gBAC/B,iCAAiC;gBACjC,mCAAmC;gBACnC,sCAAsC;gBACtC,8BAA8B;aAC/B,CAAC;YAEF;;;;;;AAMA,kBAAa,yBAAyB,wCAAG;;;;gBAIvC,QAAQ,CAAC,SAAqB;oBAC5B,OAAO,SAAS,CAAC,QAAQ,CACvB,GAAG,iBAAiB,EACpB,GAAG,gBAAgB,EACnB,GAAG,gBAAgB,CACpB,CAAC;iBACH;;;;gBAID,eAAe;oBACb,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,eAAe,EAAE,CAAC,CAAC;iBAC5C;aACF;;kBCnIY,wBAAwB;gBAMnC,YAAY,IAAuC,EAAE,EAAU;oBAC7D,IAAI,CAAC,IAAI,4BAAyC;oBAElD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;4EACF;AAED,kBAAa,yBAAyB;gBAQpC,YAAY,IAAgC,EAAE,EAAU;oBACtD,IAAI,CAAC,IAAI,8BAA2C;oBAEpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC;oBAChC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;oBACpB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;8EACF;AAED,kBAAa,wBAAwB;gBAQnC,YAAY,IAAgC,EAAE,EAAU;oBACtD,IAAI,CAAC,IAAI,8BAA2C;oBAEpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC;oBAC/B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;4EACF;AAED,kBAAa,0BAA0B;gBAQrC,YAAY,IAAgC,EAAE,EAAU;oBACtD,IAAI,CAAC,IAAI,8BAA2C;oBAEpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,QAAQ,CAAC;oBACjC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;gFACF;AAED,kBAAa,wBAAwB;gBAQnC,YAAY,IAAgC,EAAE,EAAU;oBAPjD,SAAI,8BAAoF;oBAQ7F,IAAI,CAAC,IAAI,8BAA2C;oBAEpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC;oBAC/B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;4EACF;AAED,kBAAa,0BAA0B;gBAMrC,YAAY,IAA8B,EAAE,EAAU;oBACpD,IAAI,CAAC,IAAI,8BAA2C;oBAEpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;gFACF;AAED,kBAAa,sBAAsB;gBAMjC,YAAY,IAAgC,EAAE,EAAU;oBACtD,IAAI,CAAC,IAAI,0BAAuC;oBAEhD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;wEACF;AAED,kBAAa,qBAAqB;gBAKhC,YAAY,IAAgC;oBAC1C,IAAI,CAAC,IAAI,yBAAsC;oBAE/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClB;sEACF;AAED,kBAAa,sBAAsB;gBAMjC,YAAY,KAAc,EAAE,EAAU;oBACpC,IAAI,CAAC,IAAI,0BAAuC;oBAEhD,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;oBACb,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;iBACpB;wEACF;AAED,kBAAa,yBAAyB;gBAOpC,YAAY,GAAW,EAAE,YAAoC,EAAE,KAA2C;oBACxG,IAAI,CAAC,IAAI,6BAA0C;oBAEnD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;iBAChB;8EACF;AAED,kBAAa,2BAA2B;gBAMtC,YAAY,GAAW,EAAE,YAAoC;oBAC3D,IAAI,CAAC,IAAI,+BAA4C;oBAErD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;iBAChB;kFACF;AAED,kBAAa,yBAAyB;gBASpC,YACE,GAAwB,EACxB,GAAW,EACX,YAAoC,EACpC,IAAc,EACd,KAA2C;oBAE3C,IAAI,CAAC,IAAI,wCAAqD;oBAE9D,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;oBACnB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;iBAChB;8EACF;AAED,kBAAa,qBAAqB;gBAMhC,YAAY,YAAsC,EAAE,WAAoB;oBACtE,IAAI,CAAC,IAAI,gCAA6C;oBAEtD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;iBAChC;sEACF;AAED,kBAAa,qBAAqB;gBAMhC,YAAY,IAA2D,EAAE,EAAU;oBACjF,IAAI,CAAC,IAAI,yBAAsC;oBAE/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;oBACjB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;iBACd;aACF;;;;;;"}