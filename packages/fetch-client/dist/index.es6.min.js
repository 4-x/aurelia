function json(t,e){return JSON.stringify(void 0!==t?t:{},e)}function calculateDelay(t){const{interval:e,strategy,t:r,s:n,i:s}=t;if("function"==typeof strategy)return t.strategy(s);switch(strategy){case retryStrategy.fixed:return retryStrategies[retryStrategy.fixed](e);case retryStrategy.incremental:return retryStrategies[retryStrategy.incremental](s,e);case retryStrategy.o:return retryStrategies[retryStrategy.o](s,e);case retryStrategy.random:return retryStrategies[retryStrategy.random](s,e,r,n);default:throw Error("Unrecognized retry strategy")}}function rejectOnError(t){if(!t.ok)throw t;return t}function parseHeaderValues(t){const e={},r=void 0!==t?t:{};for(const name in r)r.hasOwnProperty(name)&&(e[name]="function"==typeof r[name]?r[name]():r[name]);return e}function getRequestUrl(t,e){return absoluteUrlRegexp.test(e)?e:(void 0!==t?t:"")+e}function setDefaultHeaders(t,e){const r=void 0!==e?e:{};for(const name in r)r.hasOwnProperty(name)&&!t.has(name)&&t.set(name,r[name])}function isJSON(t){try{JSON.parse(t)}catch(t){return 0}return 1}function identity(t){return t}function thrower(t){throw t}import{PLATFORM}from"@aurelia/kernel";import{DOM,IDOM}from"@aurelia/runtime";const retryStrategy={fixed:0,incremental:1,o:2,random:3},defaultRetryConfig={u:3,interval:1e3,strategy:retryStrategy.fixed};class RetryInterceptor{constructor(t){if(this.l={...defaultRetryConfig,...void 0!==t?t:{}},this.l.strategy===retryStrategy.o&&1e3>=this.l.interval)throw Error("An interval less than or equal to 1 second is not allowed when using the exponential retry strategy")}p(t){return t.l||(t.l={...this.l},t.l.i=0),t.l.g=t.clone(),t}response(t,e){return Reflect.deleteProperty(e,"retryConfig"),t}R(t,e,r){const{l:n}=e,{g:s}=n;return Promise.resolve().then(()=>{if(n.u>n.i){const i=void 0!==n.C?n.C(t,e):1;return Promise.resolve(i).then(i=>{if(i){n.i++;const t=calculateDelay(n);return new Promise(e=>PLATFORM.global.setTimeout(e,isNaN(t)?0:t)).then(()=>{const t=s.clone();return"function"==typeof n.m?n.m(t,r):t}).then(t=>{const e={...t,l:n};return r.fetch(e)})}throw Reflect.deleteProperty(e,"retryConfig"),t})}throw Reflect.deleteProperty(e,"retryConfig"),t})}}const retryStrategies=[t=>t,(t,e)=>e*t,(t,e)=>1===t?e:Math.pow(e,t)/1e3,(t,e,r=0,n=6e4)=>Math.random()*(n-r)+r];class HttpClientConfiguration{constructor(){this.S="",this.v={},this.O=[]}q(t){return this.S=t,this}H(t){return this.v=t,this}D(t){return this.O.push(t),this}T(){return Object.assign(this.v,{I:"same-origin"},this.v),this.M()}M(){return this.D({response:rejectOnError})}P(t){const e=new RetryInterceptor(t);return this.D(e)}}const absoluteUrlRegexp=/^([a-z][a-z0-9+\-.]*:)?\/\//i;class HttpClient{constructor(dom){if(void 0===dom.window.fetch)throw Error("HttpClient requires a Fetch API implementation, but the current environment doesn't support it. You may need to load a polyfill such as https://github.com/github/fetch");this.dom=dom,this.j=0,this.A=0,this.U=0,this.S="",this.v=null,this.O=[]}F(t){let e;if("object"==typeof t)e={v:t};else{if("function"!=typeof t)throw Error("invalid config");{(e=new HttpClientConfiguration).S=this.S,e.v={...this.v},e.O=this.O;const r=t(e);HttpClientConfiguration.prototype.isPrototypeOf(r)&&(e=r)}}const r=e.v;if(void 0!==r&&Headers.prototype.isPrototypeOf(r.headers))throw Error("Default headers must be a plain object.");const n=e.O;if(void 0!==n&&n.length){if(n.filter(t=>RetryInterceptor.prototype.isPrototypeOf(t)).length>1)throw Error("Only one RetryInterceptor is allowed.");const t=n.findIndex(t=>RetryInterceptor.prototype.isPrototypeOf(t));if(t>=0&&t!==n.length-1)throw Error("The retry interceptor must be the last interceptor defined.")}return this.S=e.S,this.v=r,this.O=void 0!==e.O?e.O:[],this.U=1,this}fetch(t,e){this.N();let r=this.L(t,e);return this.J(r,this.O).then(t=>{let e;if(Response.prototype.isPrototypeOf(t))e=Promise.resolve(t);else{if(!Request.prototype.isPrototypeOf(t))throw Error(`An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [${t}]`);r=t,e=fetch(r)}return this.k(e,this.O,r)}).then(t=>Request.prototype.isPrototypeOf(t)?this.fetch(t):t).then(t=>(this.B(),t),t=>{throw this.B(),t})}L(t,e){const r=null!==this.v?this.v:{};let n,s,i;const o=parseHeaderValues(r.headers);if(Request.prototype.isPrototypeOf(t))n=t,i=new Headers(n.headers).get("Content-Type");else{e||(e={});const o=void 0!==(s=e.body)?{body:s}:null,a={...r,headers:{},...e,...o};i=new Headers(a.headers).get("Content-Type"),n=new Request(getRequestUrl(this.S,t),a)}return i||(new Headers(o).has("content-type")?n.headers.set("Content-Type",new Headers(o).get("content-type")):void 0!==s&&isJSON(s)&&n.headers.set("Content-Type","application/json")),setDefaultHeaders(n.headers,o),void 0!==s&&Blob.prototype.isPrototypeOf(s)&&s.type&&n.headers.set("Content-Type",s.type),n}get(t,e){return this.fetch(t,e)}V(t,e,r){return this.Y(t,e,r,"POST")}put(t,e,r){return this.Y(t,e,r,"PUT")}$(t,e,r){return this.Y(t,e,r,"PATCH")}delete(t,e,r){return this.Y(t,e,r,"DELETE")}N(){if(this.A=!!++this.j,this.A){const t=DOM.G("aurelia-fetch-client-request-started",{bubbles:1,cancelable:1});PLATFORM.setTimeout(()=>{DOM.dispatchEvent(t)},1)}}B(){if(this.A=!!--this.j,!this.A){const t=DOM.G("aurelia-fetch-client-requests-drained",{bubbles:1,cancelable:1});PLATFORM.setTimeout(()=>{DOM.dispatchEvent(t)},1)}}J(t,e){return this.K(t,e,"request","requestError",this)}k(t,e,r){return this.K(t,e,"response","responseError",r,this)}K(t,e,r,n,...s){return(void 0!==e?e:[]).reduce((t,e)=>{const i=e[r],o=e[n];return t.then(i?value=>i.call(e,value,...s):identity,o?t=>o.call(e,t,...s):thrower)},Promise.resolve(t))}Y(t,e,r,n){return r||(r={}),r.method=n,e&&(r.body=e),this.fetch(t,r)}}HttpClient.inject=[IDOM];export{HttpClient,HttpClientConfiguration,RetryInterceptor,json,retryStrategy};
